{"version":3,"sources":["webpack:///./packages/fusioncharts/overlappedbar2d/index.js","webpack:///./packages/fusioncharts/viz/overlappedbar2d.js","webpack:///./packages/fc-charts/src/chart/overlappedbar2d/index.js","webpack:///./packages/fc-charts/src/dataset/overlappedbar2d/index.js"],"names":["name","type","requiresFusionCharts","extension","FusionCharts","addDep","crossline","OverlapperBar2D","Overlappedbar2d","isBar","registerFactory","datasetFactory","__setDefaultConfig","config","this","friendlyName","hasLegend","defaultDatasetType","getName","getDSdef","OverlappedBar","getDSGroupdef","OverlappedColumnManager","MSBarCartesian","visibleStr","preDefStr","hiddenStr","POSITION_MIDDLE","POSITION_START","POSITION_END","mathMax","Math","max","checkOverlap","currDataDimensions","prevDataDimensions","i","len","prevLabelXPos","prevlabelWidth","currentLabelXPos","x","currentLabelWidth","width","length","labelShown","_labeldimensionMap","drawLabel","dataObj","attr","j","setData","graphic","height","valuePadding","textY","textX","outsideColSpace","isNegative","yPos","xPos","setValue","textAnchor","textWidth","xAdjust","plotLabel","prevDataDims","currentDataDim","skipLabelDraw","plotLabelCheck","dim","tempGraphics","chart","getFromEnv","chartConf","conf","JSONData","animationManager","toolTipController","canvasConf","getChildren","style","dataLabelStyle","setDataArr","data","categories","is3D","isStacked","isstacked","catLen","dataSetLen","dataStore","getData","SmartLabel","yDepth","xDepth","numberFormatter","displayValue","BLANKSTRING","placeValuesInside","placevaluesinside","canvasWidth","canvasLeft","dataLabelContainer","getContainer","skipInfo","getSkippingInfo","skippingApplied","plotDrawArray","labelDraw","plotDrawArrayLength","currDatasetIndex","getJSONIndex","visible","getState","hideCallback","hide","showCallback","show","setStyle","UNDEF","labelSkip","graphics","_yPos","_xPos","getCleanValue","value","pluckNumber","_height","_width","label","showValue","obj","text","fill","color","backgroundColor","borderColor","borderThickness","borderPadding","borderRadius","borderDash","lineHeight","visibility","getOriSize","y","opacity","getDatasets","map","dataset","filter","Boolean","setAnimation","el","component","container","callback","outlineText","showTextOutline","showtooltip","abbrArr","enableToolTip","Bar"],"mappings":"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","file":"fusioncharts.overlappedbar2d.js","sourcesContent":["import OverlapperBar2D from '../viz/overlappedbar2d';\nimport crossline from '../features/crossline';\nexport { OverlapperBar2D };\n\nexport default {\n  name: 'overlappedbar2d',\n  type: 'package',\n  requiresFusionCharts: true,\n  extension: FusionCharts => {\n    FusionCharts.addDep(crossline);\n    FusionCharts.addDep(OverlapperBar2D);\n  }\n};\n","import Overlappedbar2d from '@fusioncharts/charts/src/chart/overlappedbar2d';\nexport default Overlappedbar2d;\n","/* eslint require-jsdoc: 'error', valid-jsdoc: [\"error\", { \"requireReturn\": false }] */\nimport MSBarCartesian from '../_internal/msbarcartesian';\nimport OverlappedBar from '../../dataset/overlappedbar2d';\nimport datasetFactory from '../../factories/multiseries-dataset';\nimport OverlappedColumnManager from '../../dataset/groups/column-overlapped';\n\nconst CHART_STR = 'Multi-series Bar Chart',\n  BAR2D_STR = 'bar2d';\n/**\n * class definition for overlapped bar chart API\n */\nclass OverlappedBar2D extends MSBarCartesian {\n  /**\n   * constructor fn\n   */\n  constructor () {\n    super();\n    this.isBar = true;\n    this.registerFactory('dataset', datasetFactory, ['vCanvas']);\n  }\n  /**\n   * parse defualt configuration of the chart\n   * @memberof OverlappedBar2D\n   */\n  __setDefaultConfig () {\n    super.__setDefaultConfig();\n    let config = this.config;\n    config.friendlyName = CHART_STR;\n    config.hasLegend = true;\n    config.defaultDatasetType = BAR2D_STR;\n  }\n  /**\n   * Sets the name of the component\n   * @return {string} name\n   */\n  getName () {\n    return 'OverlappedBar2D';\n  }\n\n  /**\n   * Provides the name of the chart extension\n   *\n   * @static\n   * @return {string} The name of the chart extension\n   */\n  static getName () {\n    return 'OverlappedBar2D';\n  }\n\n  /**\n   * This method return the dataset definations for this charts\n   * @return {class} overlappedbar dataset class definition\n   */\n  getDSdef () {\n    return OverlappedBar;\n  }\n  /**\n   * This method return the dataset-group definations for this charts\n   * @return {class} manager API for overlap column\n   */\n  getDSGroupdef () {\n    return OverlappedColumnManager;\n  }\n}\nexport default OverlappedBar2D;\n","\n/* eslint require-jsdoc: 'error', valid-jsdoc: [\"error\", { \"requireReturn\": false }] */\nimport { BLANKSTRING, pluckNumber, preDefStr } from '@fusioncharts/core/src/lib';\nimport Bar from '../bar2d';\n\nlet UNDEF,\n  visibleStr = preDefStr.visibleStr,\n  hiddenStr = preDefStr.hiddenStr,\n  POSITION_MIDDLE = preDefStr.POSITION_MIDDLE,\n  POSITION_START = preDefStr.POSITION_START,\n  POSITION_END = preDefStr.POSITION_END,\n  math = Math,\n  mathMax = math.max,\n  defined = function (obj) {\n    return obj !== UNDEF && obj !== null;\n  };\n/**\n * This methods checks if current datalabel overlaps with any of the datalabels of same index\n * @param {Object} currDataDimensions current data object\n * @param {Array} prevDataDimensions previous data objects of different series but of same index.\n * @returns {Boolean} a boolean value that indicates whether the value overlaps with previous values.\n */\nfunction checkOverlap (currDataDimensions, prevDataDimensions) {\n  let i,\n    len,\n    currentLabelXPos = currDataDimensions.x,\n    prevLabelXPos,\n    currentLabelWidth = currDataDimensions.width,\n    prevlabelWidth;\n  for (i = 0, len = prevDataDimensions.length; i < len; i++) {\n    prevlabelWidth = prevDataDimensions[i].width;\n    prevLabelXPos = prevDataDimensions[i].x;\n    if (prevDataDimensions[i].labelShown && (currentLabelXPos + currentLabelWidth >= prevLabelXPos) &&\n       (prevLabelXPos + prevlabelWidth >= currentLabelXPos)) {\n      return true;\n    }\n  }\n  return false;\n}\nclass OverlappedColumn extends Bar {\n  constructor () {\n    super();\n    // this map stores the dimensions of the datalabels.used for checking if two labels overlap\n    this._labeldimensionMap = {};\n  }\n  drawLabel () {\n    var dataSet = this,\n      chart = dataSet.getFromEnv('chart'),\n      chartConf = chart.config,\n      conf = dataSet.config,\n      JSONData = conf.JSONData,\n      animationManager = dataSet.getFromEnv('animationManager'),\n      toolTipController = dataSet.getFromEnv('toolTipController'),\n      canvasConf = chart.getChildren('canvas')[0].config,\n      style = chart.config.dataLabelStyle,\n      setDataArr = JSONData.data,\n      categories = chart.config.categories,\n      is3D = chart.config.is3D,\n      isStacked = chart.config.isstacked,\n      catLen = categories && categories.length,\n      dataSetLen = setDataArr && setDataArr.length,\n      len,\n      dataStore = dataSet.getData(),\n      SmartLabel = chart.getFromEnv('smartLabel'),\n      dataObj,\n      attr,\n      yDepth = canvasConf.yDepth,\n      xDepth = canvasConf.xDepth,\n      numberFormatter = chart.getFromEnv('number-formatter'),\n      i,\n      j,\n      displayValue = BLANKSTRING,\n      setData,\n      placeValuesInside = chartConf.placevaluesinside,\n      canvasWidth = chartConf.canvasWidth,\n      canvasLeft = chartConf.canvasLeft,\n      graphic,\n      height,\n      gutter = 2,\n      valuePadding,\n      textY,\n      textX,\n      outsideColSpace,\n      isNegative,\n      yPos,\n      xPos,\n      width,\n      setValue,\n      dataLabelContainer = dataSet.getContainer('labelGroup'),\n      textAnchor,\n      textWidth,\n      xAdjust,\n      GUTTER_4 = 4,\n      skipInfo = dataSet.getSkippingInfo && dataSet.getSkippingInfo(),\n      skippingApplied = skipInfo && skipInfo.skippingApplied,\n      plotDrawArray = (skipInfo && skipInfo.labelDraw) || [],\n      plotDrawArrayLength = plotDrawArray.length,\n      config,\n      plotLabel,\n      prevDataDims,\n      currentDataDim,\n      currDatasetIndex = dataSet.getJSONIndex(),\n      skipLabelDraw,\n      plotLabelCheck,\n      dim,\n      tempGraphics,\n      visible = dataSet.getState('visible'),\n      hideCallback = function () {\n        this.hide();\n      },\n      showCallback = function () {\n        this.show();\n      };\n\n    visible && dataLabelContainer.show();\n    SmartLabel.setStyle(style);\n    len = skippingApplied ? plotDrawArrayLength : (catLen < dataSetLen ? catLen : dataSetLen);\n\n    for (j = 0; j < len; j++) {\n      i = skippingApplied ? plotDrawArray[j] : j;\n      dataObj = dataStore[i];\n      config = dataObj && dataObj.config;\n      setValue = config && config.setValue;\n\n      if (dataObj === UNDEF || setValue === UNDEF || setValue === null || config.labelSkip === true) {\n        tempGraphics = dataObj && dataObj.graphics;\n        if (tempGraphics) {\n          tempGraphics.label && tempGraphics.label.hide();\n        }\n\n        config && (delete config.labelSkip);\n\n        continue;\n      }\n      graphic = dataObj.graphics;\n\n      if (!graphic) {\n        continue;\n      }\n\n      setData = setDataArr[i];\n      yPos = dataObj._yPos;\n      xPos = dataObj._xPos;\n      setValue = numberFormatter.getCleanValue(setData.value);\n      isNegative = pluckNumber(setValue) < 0;\n      height = dataObj._height;\n      width = dataObj._width;\n\n      valuePadding = config.valuePadding + gutter;\n\n      textAnchor = isStacked ? POSITION_MIDDLE : (isNegative\n      /** @todo this boolean check needs optimisation */\n        ? (placeValuesInside ? POSITION_START : POSITION_END)\n        : (placeValuesInside ? POSITION_END : POSITION_START));\n      displayValue = config.displayValue;\n      plotLabelCheck = graphic.label;\n      // Dont draw values if the respective conditions are not satisfied\n      if (config.showValue && defined(displayValue) && displayValue !== BLANKSTRING && setValue !== null) {\n        // Preparing the attributes of the text\n        attr = {\n          text: displayValue,\n          fill: style.color,\n          'text-bound': [style.backgroundColor, style.borderColor,\n            style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash\n          ],\n          'line-height': style.lineHeight,\n          visibility: dataSet.getState('visible') ? visibleStr : hiddenStr\n        };\n\n        dim = SmartLabel.getOriSize(displayValue);\n\n        textWidth = dim.width;\n        textWidth += valuePadding;\n        xAdjust = valuePadding;\n        textY = yPos + height * 0.5;\n\n        textX = xPos + (isNegative ? 0 : width);\n\n        if (isNegative) {\n          outsideColSpace = xPos - canvasLeft;\n        } else {\n          outsideColSpace = (canvasLeft + canvasWidth) - (xPos + width);\n        }\n\n        if (placeValuesInside) {\n          // If label fits inside the data plot\n          if (width >= textWidth) {\n            textX += isNegative ? xAdjust : -xAdjust;\n            if (is3D) {\n              textY += yDepth;\n              textX -= xDepth;\n            }\n          } else {\n            // If label fits outside the data plot\n            if (textWidth < outsideColSpace) {\n              textX += isNegative ? -xAdjust : xAdjust;\n              textAnchor = isNegative ? POSITION_END : POSITION_START;\n              if (is3D && isNegative) {\n                textX -= xDepth;\n              }\n            } else {\n              // Label management for negative values\n              if (isNegative) {\n                textX = (xPos + width) + mathMax((textWidth - xPos - width + canvasLeft), 0) - xAdjust;\n                // If negative value then drawing text from end\n                textAnchor = POSITION_END;\n              } else {\n                textX = xPos - mathMax(textWidth - (canvasLeft + canvasWidth - xPos), 0) + xAdjust;\n                textAnchor = POSITION_START;\n              }\n            }\n          }\n        } else {\n          // If space is available inside plot\n          if (outsideColSpace >= textWidth) {\n            textX += isNegative ? -xAdjust : xAdjust;\n            if (is3D && isNegative) {\n              textX -= xDepth;\n              textY += xDepth;\n            }\n          } else {\n            // If space not available inside plot\n            textX += isNegative ? xAdjust + textWidth : -(xAdjust + textWidth);\n          }\n        }\n\n        // If value gets out of canvas\n        if (textX > (canvasLeft + canvasWidth) || textX < canvasLeft) {\n          textX = canvasLeft + GUTTER_4;\n          textAnchor = POSITION_START;\n        }\n\n        attr['text-anchor'] = textAnchor;\n\n        // If label is not created then create it\n        attr.x = textX;\n        attr.y = textY;\n        attr['text-bound'] = [style.backgroundColor, style.borderColor,\n          style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash];\n        attr.opacity = visible ? 1 : 0;\n        // get the dimensions of datalabels of same index but of previous datasets\n        prevDataDims = chart.getDatasets().map(\n          /* eslint-disable-next-line */\n          dataset => {\n            return (dataset.getJSONIndex() < currDatasetIndex) && dataset._labeldimensionMap[j];\n          }\n        ).filter(Boolean);\n        // current datalabel dimensions\n        currentDataDim = {\n          x: textX,\n          y: textY,\n          width: dim.width,\n          height: dim.height\n        };\n        // check for overlap\n        skipLabelDraw = checkOverlap(currentDataDim, prevDataDims);\n        // update curent label dimensions\n        dataSet._labeldimensionMap[j] = currentDataDim;\n        if (!skipLabelDraw) {\n          plotLabel = animationManager.setAnimation({\n            el: plotLabelCheck || 'text',\n            container: dataLabelContainer,\n            component: dataSet,\n            attr: attr,\n            callback: !visible ? hideCallback : showCallback,\n            label: 'plotLabel'\n          });\n          plotLabel && plotLabel.outlineText(conf.showTextOutline, attr.fill);\n          if (chartConf.showtooltip && plotLabel.abbrArr && plotLabel.abbrArr.length) {\n            toolTipController.enableToolTip(plotLabel, UNDEF);\n          }\n          if (!plotLabelCheck) {\n            graphic.label = plotLabel;\n          }\n        } else if (graphic.label) {\n          graphic.label = animationManager.setAnimation({\n            el: graphic.label,\n            component: dataSet\n          });\n          dataSet._labeldimensionMap[j].labelShown = false;\n        }\n        if (visible && !skipLabelDraw) {\n          dataSet._labeldimensionMap[j].labelShown = true;\n        } else {\n          dataSet._labeldimensionMap[j].labelShown = false;\n        }\n      } else if (graphic.label) {\n        graphic.label = animationManager.setAnimation({\n          el: graphic.label,\n          component: dataSet\n        });\n        dataSet._labeldimensionMap[j].labelShown = false;\n      }\n    }\n  }\n}\n\nexport default OverlappedColumn;\n"],"sourceRoot":""}