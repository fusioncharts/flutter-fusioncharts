{"version":3,"sources":["webpack:///./packages/fusioncharts/zoomscatter/index.js","webpack:///./packages/fusioncharts/viz/zoomscatter.js","webpack:///./packages/fc-charts/src/chart/zoomscatter/index.js","webpack:///./packages/fc-charts/src/dataset/zoomscatter/index.js"],"names":["name","type","requiresFusionCharts","extension","FusionCharts","addDep","ZoomScatter","Zoomscatter","Raphael","getDep","addSymbol","symbolList","highlightEnabled","isXY","zoom","zoomX","zoomY","defaultZeroPlaneHighlighted","getName","__setDefaultConfig","config","this","friendlyName","defaultDatasetType","enablemousetracking","animation","configureAttributes","dataObj","chartAttr","conf","getFromEnv","chart","stepZoom","pluckNumber","stepzoom","showToolBarButtonTooltext","showtoolbarbuttontooltext","btnResetChartToolText","pluck","btnresetcharttooltext","btnZoomOutToolText","btnzoomouttooltext","btnZoomInToolText","btnzoomintooltext","btnSelectZoomToolText","btnselectzoomtooltext","btnPanToolText","btnpantooltext","includeInputOptions","getInputConfigurations","iapi","hookFn","addJob","_manageInteractiveSpace","priorityList","configure","dragZoomIn","scaleX","scaleY","boxStyle","dragendFn","tooltext","zoomDecimalLimit","zoomResetButton","zoomOutButton","zoomInButton","dragPan","dbTapZoom","pinchZoom","_checkInvalidSpecificData","dataset","getDatasets","dataSetArr","iterateComponents","child","getType","push","getDSdef","ZoomScatterDataset","getDSGroupdef","ScatterBase","prototype","win","window","hideFn","hide","pi","Math","PI","DEFAULT_CURSOR","preDefStr","DEFAULT","pi2","sameSign","a","b","lineIntersect","x1","y1","x2","y2","x3","y3","x4","y4","a1","a2","b1","b2","c1","c2","r1","r2","r3","r4","lineIntersectsGrid","grid","isNaN","x","y","xMinWPad","yMaxWPad","xMaxWPad","yMinWPad","getVisibilityRatio","axis","res","axisRange","max","min","getVisibleConfig","maxValue","minValue","round","numberNeighbours","n","inRange","c","inRangeMod","getFillColor","clr","opcty","opacity","color","parseFloat","isIE","hasSVG","replace","HEXtoRGB","toString","join","getVisibleGridsIndex","focus","focusedGrid","resArr","visibleConfig","visibleRangeDiff","visibleRangeMid","axisConfig","abs","isReverse","floor","unshift","datasetJSON","plotFillHoverColor","plotFillHoverAlpha","borderHoverColor","borderHoverThickness","borderHoverAlpha","showHoverEffect","staticRadius","chartConfig","userGivenBorderColor","anchorbordercolor","seriesAnchorBorderColor","getFirstColor","plotBorderColor","seriesAnchorBorderThickness","anchorborderthickness","seriesAnchorBgColor","anchorbgcolor","plotColor","seriesAnchorAlpha","anchoralpha","alpha","HUNDREDSTRING","seriesAnchorBgAlpha","anchorbgalpha","lineColorObj","lineColor","lineAlpha","plotCosmetics","lineWidth","lineThickness","toRaphaelColor","JSONData","anchorBorderThickness","chunkSize","data","length","staticradius","radius","anchorradius","plotfillhovercolor","hovercolor","plotfillhoveralpha","hoveralpha","borderhoverthickness","hoverCosmetics","tooltip","toolTipVisible","showtooltip","seriesNameInToolTip","seriesnameintooltip","toolTipSepChar","tooltipsepchar","lastViewPort","disableScrollBars","setState","hasDrawingRefChanged","xAxis","yAxis","dsConfig","currVizRatioX","currVizRatioY","xZoomScale","yZoomScale","prevCanvasHeight","canvasHeight","prevCanvasWidth","canvasWidth","saveScrollPos","xScrollPos","apparentScrollPos","yScrollPos","getChildren","scrollBar","setScrollType","calculateZoomedRadius","zoomedRadius","setupKdTree","i","setVal","datastore","components","ii","searchDataArr","setValue","index","r","dataTree","KdTree","buildKdTree","kdTree","_getHoveredPlot","xVal","yVal","getValue","getTranslation","getNeighbour","options","zoomRadiusOb","pointIndex","hovered","pointObj","_decideTooltipType","plotIndex","e","toolTipController","currentToolTip","toolText","finalTooltext","originalEvent","draw","_firePlotEvent","eventType","setLink","style","canvas","highlightPoint","plotEventHandler","getGraphicalElement","cursor","showHover","point","tracker","animationManager","trackerCheck","datasetConfig","fill","hoverEffects","anchorProps","borderColor","borderThickness","attrObj","link","stroke","cx","getPixel","cy","setAnimationState","setAnimation","el","attr","container","getContainer","component","doNotRemove","callback","show","addGraphicalElement","showValue","hoverColor","enabled","UNDEF","hoverAlpha","anchorBgColor","bgColor","anchorBgAlpha","anchorAlpha","anchorBorderColor","anchorRadius","anchorSides","sides","anchorStartAngle","startAngle","anchorHoverSides","lastHoveredPoint","drawCommonElements","animateCommonElements","remove","_deleteGridImages","drawPlots","containerLine","containerPlot","plotGroup","prevContainerLine","prevContainerPlot","quickRenderVisibleGrids","label","getState","addContainer","wasLastDrawPixelated","rx","ry","_graphics","_grid","_gridDraw","imageElem","lineImage","lineCanvas","canvasElem","gridElem","rowIndex","colIndex","row","datasetGraphics","imagePool","_imagePool","canvasPool","_canvasPool","lineImagePool","_lineImagePool","lineCanvasPool","_lineCanvasPool","batchDrawTimers","_batchDrawTimers","removeJob","shift","drawState","image","ctx","lineCtx","clearTimeout","timer","_gridManager","getAllGrids","element","xRightValue","xLeftValue","yTopValue","yBottomValue","appliedLeftXPad","appliedRightXPad","gridY","gridX","visibleXGrids","visibleYGrids","nineGridsXIndices","nineGridsYIndices","visibleArr","nearByArr","j","grids","noRow","ceil","noCol","startRow","endRow","startCol","endCol","cellWidth","getAxisConfig","axisLength","cellHeight","xAxisConfig","yAxisConfig","xMin","xMax","yMin","yMax","padPx","borderWidth","xRadiusPad","yRadiusPad","yRefPx","xRefPx","xPixel","width","yPixel","height","indexOf","focused","nearBy","allocatePosition","dsStore","dsStoreLength","props","polypath","gridsOb","_drawGrid","_drawGridArr","callBack","lineCanvasElem","drawLine","gridIndexArr","gridSubArr","document","createElement","setAttribute","getContext","fillStyle","strokeStyle","lineStrokeStyle","_batchDrawindex","_drawGridArrBatch","gridArr","doNotUpdateImage","cx1","cx2","cy1","cy2","storeX","leftElement","rightElement","regresionPoints","regressionLineColor","regressionLineThickness","regressionLineAlpha","leftElCx","leftElCy","arr","endIndex","dataSource","regressionStatus","showregressionline","_store","doStroke","regressionlinecolor","regressionlinethickness","regressionlinealpha","beginPath","moveTo","lineTo","arc","closePath","src","toDataURL","regressionPoints","globalAlpha","getRegressionPoints","regPointsLength","Infinity","lineGroup","legend","getItem","legendItemId","removeLegendState","setContainerVisibility","dataSet","xAxisZeroPos","xAxisFirstPos","groupMaxWidth","drawn","skippingApplied","getSkippingInfo","addToEnv","createContainer","hidePlots","skipCommonElements","drawLabel","scrollMinValForLabel","scrollMaxValForLabel","removePlots","setLegendState","_addLegend","legendItem","fillColor","strokeColor","includeInLegend","anchorSide","getFirstValue","seriesname","legendIconAlpha","legendiconalpha","includeinlegend","itemStyle","hiddenStyle","itemHiddenStyle","datasetVisible","hoverStyle","itemHoverStyle","createItem","addExtEventListener","itemClickFn","setStateCosmetics","symbol","bgAlpha","legendiconbgalpha","borderAlpha","legendiconborderalpha","rawFillColor","rawStrokeColor","disposeItem","_setConfigure","setData","toolTipValue","macroIndices","parserConfig","formatedVal","formatedValX","setDisplayValue","infMin","infMax","dataStore","setDataArr","datasetLen","numberFormatter","yAxisName","parseUnsafeString","yaxisname","xAxisName","xaxisname","lineDashed","lineDashStyle","regressionShowYonX","showyonx","parentYAxis","tooltipSepChar","getCleanValue","rightMostData","leftMostData","showRegressionLine","pointValueWatcher","regressionObj","_parseAnchorProperties","showvalue","showValues","dashed","dashStyle","dataLabels","displayvalue","displayValue","setTooltext","getValidValue","plotToolText","showTooltip","yaxisName","xaxisName","yDataValue","xDataValue","parseTooltext","BLANKSTRING","graphics","_parseHoverEffectOptions","isAnchorHoverRadius","slice","ErrorValueConfigure","Scatter"],"mappings":"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","file":"fusioncharts.zoomscatter.js","sourcesContent":["import ZoomScatter from '../viz/zoomscatter';\n\nexport { ZoomScatter };\n\nexport default {\n  name: 'zoomscatter',\n  type: 'package',\n  requiresFusionCharts: true,\n  extension: FusionCharts => {\n    FusionCharts.addDep(ZoomScatter);\n  }\n};\n","import Zoomscatter from '@fusioncharts/charts/src/chart/zoomscatter';\nexport default Zoomscatter;\n","\nimport ScatterBase from '../_internal/scatterbase';\nimport ZoomScatterDataset from '../../dataset/zoomscatter';\nimport { pluck, pluckNumber, _manageInteractiveSpace } from '@fusioncharts/core/src/lib';\nimport { symbolList } from '../_internal/utils/iconsymbol';\nimport { getDep } from '@fusioncharts/core/src/dependency-manager';\nimport { priorityList } from '@fusioncharts/core/src/schedular';\n\nlet Raphael = getDep('redraphael', 'plugin'),\n  UNDEF,\n  CHART_STR = 'ZoomScatter Chart',\n  ZOOMSCATTER_STR = 'zoomscatter';\n\nRaphael.addSymbol(symbolList);\n\nclass ZoomScatter extends ScatterBase {\n  /**\n   * Provides the name of the chart extension\n   *\n   * @static\n   * @return {string} The name of the chart extension\n   */\n  static getName () {\n    return 'ZoomScatter';\n  }\n\n  constructor () {\n    super();\n\n    this.highlightEnabled = false;\n    this.isXY = true;\n    this.zoom = true;\n    this.zoomX = true;\n    this.zoomY = true;\n    this.defaultZeroPlaneHighlighted = false;\n  }\n\n  /**\n   * Sets the name of the component\n   * @return {string} name\n   */\n  getName () {\n    return 'ZoomScatter';\n  }\n  __setDefaultConfig () {\n    super.__setDefaultConfig();\n    let config = this.config;\n    config.friendlyName = CHART_STR;\n    config.defaultDatasetType = ZOOMSCATTER_STR;\n    config.enablemousetracking = true;\n    config.animation = 0;\n  }\n  configureAttributes (dataObj) {\n    var chartAttr,\n      iapi = this,\n      conf = iapi.config;\n    super.configureAttributes(dataObj);\n    chartAttr = iapi.getFromEnv('dataSource').chart;\n    conf.stepZoom = 400 / (100 - pluckNumber(chartAttr.stepzoom, 25));\n    if (conf.stepZoom <= 2) {\n      conf.stepZoom = 1.9;\n    }\n    conf.showToolBarButtonTooltext = pluckNumber(chartAttr.showtoolbarbuttontooltext, 1);\n    conf.btnResetChartToolText = conf.showToolBarButtonTooltext ? pluck(chartAttr.btnresetcharttooltext, 'Reset Chart') : '';\n    conf.btnZoomOutToolText = conf.showToolBarButtonTooltext ? pluck(chartAttr.btnzoomouttooltext, 'Zoom out to previous level') : '';\n    conf.btnZoomInToolText = conf.showToolBarButtonTooltext ? pluck(chartAttr.btnzoomintooltext, '<strong>Zoom in</strong><br/>Or double-' +\n        'click on plot to zoom-in') : '';\n    conf.btnSelectZoomToolText = conf.showToolBarButtonTooltext ? pluck(chartAttr.btnselectzoomtooltext,\n      '<strong>Select a region to zoom-in</strong><br/>Click to enable pan mode.') : '';\n    conf.btnPanToolText = conf.showToolBarButtonTooltext ? pluck(chartAttr.btnpantooltext,\n      '<strong>Drag to move across chart</strong><br/>Click to enable select-zoom mode.') : '';\n  }\n\n  /**\n   * Function to state if inputOptions are to be used for this charts\n   * @return {Array} value\n   */\n  static includeInputOptions () {\n    return ['DragPan', 'DragZoomIn', 'ZoomResetButton', 'ZoomOutButton', 'ZoomInButton', 'DbTapZoom', 'PinchZoom'];\n  }\n\n  getInputConfigurations () {\n    var iapi = this,\n      config = iapi.config,\n      zoomDecimalLimit = 2,\n      hookFn = function () {\n        // Function to manage space during zoom interactions\n        iapi.addJob('spaceManage', function () {\n          iapi._manageInteractiveSpace();\n        }, priorityList.configure)\n        ;\n      },\n      inputComponents = {\n        dragZoomIn: {\n          scaleX: true,\n          scaleY: true,\n          boxStyle: {\n            'stroke-width': 1,\n            'stroke': 'red',\n            'fill': '#00FF00',\n            'opacity': 0.2,\n            'cursor': 'ne-resize'\n          },\n          dragendFn: hookFn,\n          tooltext: config.btnSelectZoomToolText,\n          zoomDecimalLimit\n        },\n        zoomResetButton: {\n          tooltext: config.btnResetChartToolText,\n          hookFn\n        },\n        zoomOutButton: {\n          tooltext: config.btnZoomOutToolText,\n          hookFn\n        },\n        zoomInButton: {\n          tooltext: config.btnZoomInToolText,\n          stepzoom: config.stepZoom,\n          zoomDecimalLimit,\n          hookFn\n        },\n        dragPan: {\n          tooltext: config.btnPanToolText\n        },\n        dbTapZoom: {\n          stepzoom: config.stepZoom,\n          zoomDecimalLimit,\n          hookFn\n        },\n        pinchZoom: {\n          zoomDecimalLimit\n        }\n      };\n\n    return inputComponents;\n  }\n\n  /**\n   * function to check if the chart specific data is proper is not\n   * this fn is define for specific chart types\n   * @return {boolean} if JSON data is valid or not\n   */\n  _checkInvalidSpecificData () {\n    let jsonData = this.getFromEnv('dataSource'),\n      datasetsJSON = jsonData.dataset;\n    if (!datasetsJSON) {\n      return true;\n    }\n  }\n  /**\n   * Returns the dataset array\n   * @return {Array} array of dataset objects\n   */\n  getDatasets () {\n    var iapi = this,\n      dataSetArr = [];\n\n    iapi.iterateComponents((child) => {\n      if ((child.getType && child.getType() === 'dataset')) {\n        dataSetArr.push(child);\n      }\n    });\n    return dataSetArr;\n  }\n  // This method return the dataset definations for this charts\n  getDSdef () {\n    return ZoomScatterDataset;\n  }\n  // This method return the dataset-group definations for this charts\n  getDSGroupdef () {\n    return UNDEF;\n  }\n}\n\nZoomScatter.prototype._manageInteractiveSpace = _manageInteractiveSpace;\n\nexport default ZoomScatter;\n","\nimport Scatter from '../scatter';\nimport KdTree from '../_internal/kdtree';\nimport { priorityList } from '@fusioncharts/core/src/schedular';\nimport {parseTooltext, BLANKSTRING, pluck, pluckNumber, getFirstValue, toRaphaelColor,\n  HUNDREDSTRING, hasSVG, isIE, parseUnsafeString, getValidValue, preDefStr, HEXtoRGB, getFirstColor }\n  from '@fusioncharts/core/src/lib';\nimport getLinearRegressionPoints from '@fusioncharts/features/src/regression-extension/linear-regression';\nvar UNDEF,\n  win = window,\n  hideFn = function () {\n    this.hide();\n  },\n  POINTER = 'pointer',\n  pi = Math.PI,\n  DEFAULT_CURSOR = preDefStr.DEFAULT,\n  pi2 = 2 * pi,\n  COLOR_WHITE = '#FFFFFF',\n  sameSign = function (a, b) {\n    return a * b >= 0;\n  },\n  lineIntersect = function intersect (x1, y1, x2, y2, x3, y3, x4, y4) {\n    var a1, a2, b1, b2, c1, c2,\n      r1, r2, r3, r4,\n      denom;\n\n    // Compute a1, b1, c1, where line joining points 1 and 2\n    // is \"a1 x + b1 y + c1 = 0\".\n    a1 = y2 - y1;\n    b1 = x1 - x2;\n    c1 = (x2 * y1) - (x1 * y2);\n\n    // Compute r3 and r4.\n    r3 = ((a1 * x3) + (b1 * y3) + c1);\n    r4 = ((a1 * x4) + (b1 * y4) + c1);\n\n    // Check signs of r3 and r4. If both point 3 and point 4 lie on\n    // same side of line 1, the line segments do not intersect.\n    if ((r3 !== 0) && (r4 !== 0) && sameSign(r3, r4)) {\n      return 0;\n      // return that they do not intersect\n    }\n\n    // Compute a2, b2, c2\n    a2 = y4 - y3;\n    b2 = x3 - x4;\n    c2 = (x4 * y3) - (x3 * y4);\n\n    // Compute r1 and r2\n    r1 = (a2 * x1) + (b2 * y1) + c2;\n    r2 = (a2 * x2) + (b2 * y2) + c2;\n\n    // Check signs of r1 and r2. If both point 1 and point 2 lie\n    // on same side of second line segment, the line segments do\n    // not intersect.\n    if ((r1 !== 0) && (r2 !== 0) && (sameSign(r1, r2))) {\n      return 0; // return that they do not intersect\n    }\n\n    // Line segments intersect: compute intersection point.\n    denom = (a1 * b2) - (a2 * b1);\n\n    if (denom === 0) {\n      return 1; // collinear\n    }\n\n    // lines_intersect\n    return 1; // lines intersect, return true\n  },\n  lineIntersectsGrid = function (a, b, grid) {\n    if (isNaN(a.x) || isNaN(a.y) || isNaN(b.x) || isNaN(b.y)) {\n      return;\n    }\n    return lineIntersect(a.x, a.y, b.x, b.y, grid.xMinWPad, grid.yMaxWPad, grid.xMaxWPad, grid.yMaxWPad) ||\n      lineIntersect(a.x, a.y, b.x, b.y, grid.xMaxWPad, grid.yMaxWPad, grid.xMaxWPad, grid.yMinWPad) ||\n      lineIntersect(a.x, a.y, b.x, b.y, grid.xMaxWPad, grid.yMinWPad, grid.xMinWPad, grid.yMinWPad);\n  },\n  // take how much was previously zoomed in case of pixelatedDraw\n  getVisibilityRatio = function (axis) {\n    var res = (axis.config.axisRange.max - axis.config.axisRange.min) / (axis.getVisibleConfig().maxValue - axis.getVisibleConfig().minValue);\n    res = Math.round(res * 1000) / 1000;\n    return res;\n  },\n  numberNeighbours = function (n) {\n    return [n - 1, n, n + 1];\n  },\n  /*\n   * A function to check if a in in range of b and c\n   * where b is smaller and c is greater value\n   * */\n  inRange = function (a, b, c) {\n    return a >= b && a <= c;\n  },\n  /*\n   * A function to check if a in in range of b and c,\n   * where either b or c could be greater value\n   * */\n  inRangeMod = function (a, b, c) {\n    return inRange(a, b, c) || inRange(a, c, b);\n  },\n  getFillColor = function (clr, opcty) {\n    var opacity = opcty,\n      color = clr;\n      // todo check if we have any similar library method\n    opacity = parseFloat(opacity / 100); // opacity is provided in [0-100] and needed to be in [0-1]\n    if (opacity < 0) { // opacity cannot be negative.\n      opacity = 0;\n    } else if (opacity > 1) { // opacity cannot be more than 1\n      opacity = 1;\n    }\n    if (!color) {\n      color = COLOR_WHITE; // white stays the default color\n    }\n\n    if (isIE && !hasSVG) { // if the version donot have SVG in IE.\n      return opacity ? color : 'transparent';\n    }\n    // convert to rgba code.\n    color = color.replace(/^#?([a-f0-9]+)/ig, '$1');\n    color = HEXtoRGB(color);\n    color[3] = opacity.toString();\n    return 'rgba(' + color.join(',') + ')';\n  },\n  getVisibleGridsIndex = function (axis) {\n    var resArr = [],\n      visibleConfig = axis.getVisibleConfig(),\n      visibleRangeDiff = (visibleConfig.maxValue - visibleConfig.minValue),\n      visibleRangeMid = visibleConfig.minValue + (visibleRangeDiff / 2),\n      focus,\n      axisConfig = axis.config,\n      axisRange = axisConfig.axisRange,\n      focusedGrid;\n\n    focus = Math.abs((visibleRangeMid - (axisConfig.isReverse ? axisRange.max : axisRange.min)) / visibleRangeDiff);\n    focusedGrid = resArr.focusedGrid = Math.floor(focus);\n\n    resArr.push(focusedGrid);\n\n    if (focus % 1 > 0.5) {\n      resArr.push(focusedGrid + 1);\n    } else if (focus % 1 < 0.5) {\n      resArr.unshift(focusedGrid - 1);\n    }\n    return resArr;\n  };\n/**\n * ZoomScatter - ZoomScatter is an extended version of FusionCharts Scatter chart.\n * It supports\n * - zooming\n * - panning\n * - scrolling\n * - pinch to zoom\n * - double tap to zoom\n * - drag to zoom\n * - drag to pan\n *\n * Note - All of these features can be added to any charts by adding the input components to the canvas\n * which are in the 'input' folder in 'renderer-javascript'.\n *\n * But the most important feature of ZoomScatter is that it supports 1 million data points, which is\n * also the most challenging part.\n *\n * The challenges of one million points -\n *\n * 1. Rendering 1 million points with svg will make the page drastically slow as there will be a burden of\n *    one million elements on the page.\n *\n * 2. Searching - Every time someone hovers mouse over zoomscatter chart search is fired. This is about 50 - 100\n *    times per second. That means we need minimum possible time to search. Linear searching is bad idea because\n *    iterating over one million data points would take huge time i.e O(n) complexity. Also binary search search is\n *    not applicable as binary search can only be used in cases where the search has to be done in one dimension.\n *    In ZoomScatter every point has two dimensions 'x' and 'y'.\n *\n * Solutions we came up with -\n *\n * 1. Since rendering a million point with svg is not posiible so we use canvas to render the points.\n *\n * 2. For searching we use KdTree algorithm which is basically a quick seach algorithm for 2 dimensional\n *    points. For more details on KdTree, visit: http://www.geeksforgeeks.org/k-dimensional-tree/\n *\n * Although KdTree was fine and solved our searching issues, rendering on canvas came up with multiple\n * more issues of its own.\n *\n * The issues faced in rendering with canvas are :\n *\n * 1. No interactivity available in canvas. Canvas is a one time paint and go. No elements or interactivity\n *    like svg.\n *\n * 2. When the ZoomScatter chart is zoomed all of the current drawings become invalid and we have to draw again.\n *    Rendering all points again takes a lot of time and blocks user for few seconds which causes major lag.\n *\n * How we overcome these problems:\n *\n * 1. For interactivity we do not make any changes in the canvas, instead we make one single svg. Now whenever a user\n *    hovers over a point, we fetch the point's x and y position and place the svg element over it. The svg element\n *    has size as same as the hovered canvas element with the extra hover attributes applied over it. Thus user\n *    gets a feeling that the hovered element has changed.\n *    And when user is not hovering over any element we simple hide the svg element, thus achieving the interactivity\n *    of the plot elements.\n *\n * 2. To overcome the burden of drawing of all element when zoom occurs, we avoid drawing of all elements\n *    at the time of zoom.\n *    ZoomScatter uses a 9 grid system. Whenever zoom occurs we divide the whole canvas into multiple grids,\n *    each of height and width as same as the canvas. There can be \"n * m\" number of grids depending on\n *    how many times it has been zoomed. So in zoomed state rendering all grids (even the grids that arent visible)\n *    is a total waste of cpu and user's time. So we pick what grid lies at the center and\n *    also pick all other grids lying beside it (i.e in directions: N, S, E, W, SW, SE, NW, NE).\n *    So we concentrate on those grids and draw them first. Although only a max of 4 grids can be\n *    visible at a time but we still choose to draw 9 grids so that even when user scrolls or pans the\n *    chart he/she can see the data points instantly.\n *\n * ***Code flow *** -\n *\n * **In initial rendering** - code flow in intitial is common as other cartesian charts. Please refer to cartesian\n *    docs for the flow. In short and specific manner, 'drawPlots' function of dataset is called\n *    from column's draw function.\n *\n * **When interacted with legend** - In case of legend interactivity, dataset's show or hide function is\n *    called which just changes the visibilty of canvas element where the dataset is rendered.\n *\n * **When zoomed or panned** - Zooming or panning is handled by the input components, all input components\n *    finally just changes the axis visible range (i.e axis.setVisibleConfig()) which either becomes\n *    zoomed state or panned\n *    state, depending on the interaction. Now whenever axis' visible config is changed it fires an event.\n *    The vCanvas is listening to the same event and when it event that event occurs it changes its\n *    panning accordingly\n *    and again fire an event 'vcanvasupdated' which datasets are listenting to. On 'vcanvasupdated' event\n *    all datasets draw themselves. Thus again 'drawPlots' function is called from column dataset's draw function.\n *\n * So apart from legend interaction every time drawPlot function is called.\n *\n * The drawPlots function always stores previous zoom state. Whenever it is called, it calculates current zoom\n * and compares with previous if zoom has changed or not.\n *\n * If the zoom has changed (i.e zoomed in or out), it clears all the canvas elements and commands to draw\n * everything again.\n *\n * If zoom hasnt occured(meaning pan), dataset lists all the nearby grids and draw them if they arent drawn,\n * which was previously explained in 9 grids system.\n */\nclass ZoomScatter extends Scatter {\n  /**\n   * Sets the type of the component\n   * @return {string} type\n   */\n  getType () {\n    return 'dataset';\n  }\n  /**\n   * Sets the name of the component\n   * @return {string} name\n   */\n  getName () {\n    return 'zoomScatter';\n  }\n  configureAttributes (datasetJSON) {\n    super.configureAttributes(datasetJSON);\n    var plotFillHoverColor,\n      plotFillHoverAlpha,\n      borderHoverColor,\n      borderHoverThickness,\n      borderHoverAlpha,\n      showHoverEffect,\n      staticRadius,\n      dataset = this,\n      conf = dataset.config,\n      chart = dataset.getFromEnv('chart'),\n      chartConfig = chart.config,\n      chartAttr = chart.getFromEnv('dataSource').chart,\n      // Following configurations are added or modified being speciifc to the 'zoom-scatter' chart\n      // We first look into dataset then chart obj and then default value.(plucking the cosmetics)\n      userGivenBorderColor = pluck(datasetJSON.anchorbordercolor, chartAttr.anchorbordercolor),\n      seriesAnchorBorderColor = getFirstColor(pluck(userGivenBorderColor,\n        conf.plotBorderColor)),\n      seriesAnchorBorderThickness = pluckNumber(datasetJSON.anchorborderthickness,\n        chartAttr.anchorborderthickness, userGivenBorderColor ? 1 : 0),\n      seriesAnchorBgColor = getFirstColor(pluck(datasetJSON.anchorbgcolor, datasetJSON.color,\n        chartAttr.anchorbgcolor, conf.plotColor)),\n      seriesAnchorAlpha = pluck(datasetJSON.anchoralpha, datasetJSON.alpha, chartAttr.anchoralpha,\n        HUNDREDSTRING),\n      seriesAnchorBgAlpha = pluck(datasetJSON.anchorbgalpha, datasetJSON.alpha, chartAttr.anchorbgalpha,\n        HUNDREDSTRING),\n      lineColorObj = {\n        color: conf.lineColor,\n        alpha: conf.lineAlpha\n      };\n\n    conf.plotCosmetics = {\n      'fillStyle': getFillColor(seriesAnchorBgColor, ((seriesAnchorAlpha * seriesAnchorBgAlpha) / 100)),\n      'strokeStyle': getFillColor(seriesAnchorBorderColor, seriesAnchorAlpha),\n      'borderWidth': seriesAnchorBorderThickness,\n      lineWidth: conf.lineThickness,\n      'lineStrokeStyle': toRaphaelColor(lineColorObj)\n    };\n\n    dataset.config.JSONData = datasetJSON;\n    /* If no border Thickness is given, the border thickness turns to 1 px in case there exists a\n              user-defined anchorBorderColor; orelse the anchorBorderThickness turns to zero. */\n    conf.anchorBorderThickness = pluckNumber(datasetJSON.anchorborderthickness, chartAttr.anchorborderthickness,\n      userGivenBorderColor ? 1 : 0);\n\n    // * @todo make this dynamic as per the browser performance\n    conf.chunkSize = Math.floor(Math.min(((datasetJSON.data || []).length) / 5, 50000));\n    // Turning staticRadius TRUE, keeps the radius of the plots intact even after zooming.\n    staticRadius = conf.staticRadius = pluckNumber(chartAttr.staticradius, 0);\n    // Applies to all the plots of a particular dataset.\n    conf.radius = pluckNumber(datasetJSON.radius, datasetJSON.anchorradius, chartAttr.radius,\n      chartAttr.anchorradius, (staticRadius ? 3 : 0.5));\n\n    showHoverEffect = conf.showHoverEffect;\n    // Hover Cosmetics\n    plotFillHoverColor = getFirstColor(pluck(datasetJSON.plotfillhovercolor, datasetJSON.hovercolor,\n      chartAttr.plotfillhovercolor, chartAttr.hovercolor, conf.anchorbgcolor));\n    plotFillHoverAlpha = pluck(datasetJSON.plotfillhoveralpha, datasetJSON.hoveralpha, chartAttr.plotfillhoveralpha,\n      chartAttr.hoveralpha, HUNDREDSTRING);\n    borderHoverColor = getFirstColor(pluck(datasetJSON.plotfillhovercolor, datasetJSON.hovercolor,\n      chartAttr.plotfillhovercolor, chartAttr.hovercolor, plotFillHoverColor));\n    borderHoverAlpha = pluck(datasetJSON.plotfillhoveralpha, datasetJSON.hoveralpha, chartAttr.plotfillhoveralpha,\n      chartAttr.hoveralpha, HUNDREDSTRING);\n    borderHoverThickness = pluckNumber(datasetJSON.borderhoverthickness, chartAttr.borderhoverthickness, 1);\n\n    conf.hoverCosmetics = {\n      'showHoverEffect': showHoverEffect,\n      'fill': getFillColor(plotFillHoverColor, plotFillHoverAlpha),\n      'borderColor': getFillColor(borderHoverColor, borderHoverAlpha),\n      'borderThickness': borderHoverThickness,\n      plotFillHoverColor,\n      plotFillHoverAlpha,\n      borderHoverColor,\n      borderHoverAlpha\n    };\n    // store the hoverCosmetics\n    // sending an examplory\n    // conf.hoverCosmetics = dataset._parseHoverEffectOptions();\n    // tooltip configurations\n    conf.tooltip = {\n      toolTipVisible: chartConfig.showtooltip,\n      seriesNameInToolTip: chartConfig.seriesnameintooltip,\n      toolTipSepChar: chartConfig.tooltipsepchar\n    };\n    // create the store to store last scale factors\n    conf.lastViewPort = {};\n    this.disableScrollBars();\n    this.setState('dirty', true);\n  }\n\n  /**\n   * Function to check if axis has zoomed or chart-dimensions has changed (resized)\n   */\n  hasDrawingRefChanged () {\n    var dataset = this,\n      xAxis = dataset.getFromEnv('xAxis'),\n      yAxis = dataset.getFromEnv('yAxis'),\n      dsConfig = dataset.config,\n      axisConfig = dsConfig.axisConfig = dsConfig.axisConfig || {},\n      res = false,\n      currVizRatioX = getVisibilityRatio(xAxis),\n      chartConfig = dataset.getFromEnv('chartConfig'),\n      currVizRatioY = getVisibilityRatio(yAxis);\n\n    res = axisConfig.xZoomScale !== currVizRatioX || axisConfig.yZoomScale !== currVizRatioY ||\n      dsConfig.prevCanvasHeight !== chartConfig.canvasHeight ||\n        dsConfig.prevCanvasWidth !== chartConfig.canvasWidth;\n\n    // Saving zoom state\n    axisConfig.xZoomScale = currVizRatioX;\n    axisConfig.yZoomScale = currVizRatioY;\n    dsConfig.prevCanvasHeight = chartConfig.canvasHeight;\n    dsConfig.prevCanvasWidth = chartConfig.canvasWidth;\n    return res;\n  }\n\n  saveScrollPos () {\n    var dataset = this,\n      xAxis = dataset.getFromEnv('xAxis'),\n      yAxis = dataset.getFromEnv('yAxis'),\n      dsConfig = dataset.config,\n      axisConfig = dsConfig.axisConfig = dsConfig.axisConfig || {};\n    // saving scroll state\n    axisConfig.xScrollPos = xAxis.config.apparentScrollPos;\n    axisConfig.yScrollPos = yAxis.config.apparentScrollPos;\n  }\n  /*\n  * Axis has default scroll type of smart, set it to none\n  */\n  disableScrollBars () {\n    var dataset = this,\n      chart = dataset.getFromEnv('chart'),\n      scrollBar = chart.getChildren() && chart.getChildren().scrollBar && chart.getChildren().scrollBar[0];\n    scrollBar && chart.setScrollType('none');\n  }\n  calculateZoomedRadius () {\n    var dataset = this,\n      dsConfig = dataset.config,\n      chartConfig = dataset.getFromEnv('chart').config,\n      axisConfig = dsConfig.axisConfig;\n\n    dsConfig.zoomedRadius = Math.min((dsConfig.staticRadius\n      ? dsConfig.radius : (dsConfig.radius * Math.min(axisConfig.xZoomScale,\n        axisConfig.yZoomScale))), chartConfig.canvasWidth / 2, chartConfig.canvasHeight / 2);\n  }\n  setupKdTree () {\n    var dataset = this,\n      data,\n      datastore = dataset.components.data,\n      ii = datastore.length,\n      i,\n      setVal,\n      searchDataArr = [];\n    for (i = 0; i < ii; ++i) {\n      data = datastore[i];\n      setVal = data.config.setValue;\n      if (isNaN(setVal.x) || isNaN(setVal.y)) {\n        continue;\n      }\n      setVal.index = i;\n      searchDataArr.push({\n        x: setVal.x,\n        y: setVal.y,\n        index: i,\n        data: data,\n        r: 1\n      });\n    }\n    // create the kdtree in a seperate thread\n    dataset.addJob('kdtree', function () {\n      dataset.dataTree = new KdTree().buildKdTree(searchDataArr);\n    }, priorityList.kdTree);\n  }\n  /*\n    * Using kdtree algo for searching\n  */\n  _getHoveredPlot (x, y) {\n    var res,\n      dataset = this,\n      xAxis = dataset.getFromEnv('xAxis'),\n      yAxis = dataset.getFromEnv('yAxis'),\n      xVal,\n      yVal;\n    xVal = xAxis.getValue(x + xAxis.getTranslation());\n    yVal = yAxis.getValue(y + yAxis.getTranslation());\n    res = dataset.dataTree && dataset.dataTree.getNeighbour({\n      x: xVal,\n      y: yVal,\n      options: dataset.zoomRadiusOb\n    }, true);\n    // searching neighbour from Kdtree with basic search flag on\n    if (res) {\n      res.data.x = res.x;\n      res.data.y = res.y;\n      return {\n        pointIndex: res.index || res.i,\n        hovered: true,\n        pointObj: res.data\n      };\n    }\n  }\n\n  // Helper function of _firePlotEvent which decides single/consolidated tooltip\n  _decideTooltipType (plotIndex, e) {\n    var dataset = this,\n      toolTipController = dataset.getFromEnv('toolTipController'),\n      currentToolTip = dataset.config.currentToolTip,\n      components = dataset.components,\n      dataStore = components.data,\n      data = dataStore[plotIndex],\n      toolText = data && (data.config.finalTooltext || data.config.toolText),\n      originalEvent = e.originalEvent;\n\n    if (toolText) {\n      if (currentToolTip) {\n        toolTipController.draw(originalEvent, toolText, currentToolTip);\n      } else {\n        currentToolTip = dataset.config.currentToolTip = toolTipController.draw(originalEvent, toolText);\n      }\n    }\n  }\n  /**\n   * This method handles all mouse events of an dataset.\n   * @param {String} eventType name of the event\n   * @param {number} plotIndex index of the plot where this event has been occured\n   * @param {Event} originalEvent reference of the original mouse event\n   */\n  _firePlotEvent (eventType, plotIndex, e) {\n    var dataset = this,\n      chart = dataset.getFromEnv('chart'),\n      components = dataset.components,\n      toolTipController = dataset.getFromEnv('toolTipController'),\n      dataStore = components.data,\n      data = dataStore[plotIndex],\n      // tip = toolTip,\n      // originalEvent = e.originalEvent,\n      style = dataset.getFromEnv('paper').canvas.style,\n      config,\n      setLink;\n\n    if (data) {\n      config = data.config;\n      setLink = config.setLink;\n      switch (eventType) {\n        case 'fc-mouseover' :\n          dataset._decideTooltipType(plotIndex, e);\n          dataset.highlightPoint(dataset.config.showHoverEffect, data);\n          chart.plotEventHandler(\n            dataset.getGraphicalElement('tracker'),\n            e,\n            'dataplotRollover'\n          );\n          setLink && (style.cursor = 'pointer');\n          break;\n        case 'fc-mouseout' :\n          toolTipController.hide(dataset.config.currentToolTip);\n          setLink && (style.cursor = DEFAULT_CURSOR);\n          dataset.highlightPoint(false);\n          chart.plotEventHandler(\n            dataset.getGraphicalElement('tracker'),\n            e,\n            'dataplotRollout'\n          );\n          break;\n        case 'fc-click':\n          chart.plotEventHandler(\n            dataset.getGraphicalElement('tracker'),\n            e,\n            'dataplotClick'\n          );\n          break;\n        case 'fc-mousemove' :\n          dataset._decideTooltipType(plotIndex, e);\n      }\n    }\n  }\n  /*\n    * Highlight the hovered element. It needs the index value to set the cosmetics according to the dataset\n    cosmetics\n    * @param showHover {Boolean} -\n    * @param cx {Number} - Pixel information about the x-cordinate of the center of the plot being hovered.\n    * @param cy {Number} - Pixel information about the y-cordinate of the center of the plot being hovered.\n    * @param point {Object} - Raw information about the point say its x and y.\n    * @param index {Number} - This refers to the dataset index to which the point being hovered belongs to.\n    * @param toolText {String} - Tooltext needed to be displayed for the point being hovered.\n  */\n  highlightPoint (showHover, point) {\n    var dataset = this,\n      chart = dataset.getFromEnv('chart'),\n      chartConfig = chart.config,\n      // chartComponents = chart.components,\n      // chartGraphics = chart.graphics,\n      animationManager = dataset.getFromEnv('animationManager'),\n      trackerCheck = dataset.getGraphicalElement('tracker'),\n      tracker,\n      xAxis = dataset.getFromEnv('xAxis'),\n      yAxis = dataset.getFromEnv('yAxis'),\n      datasetConfig = dataset && dataset.config,\n      radius = (datasetConfig && datasetConfig.zoomedRadius) || 0,\n      hoverCosmetics = datasetConfig && datasetConfig.hoverCosmetics,\n      fill = hoverCosmetics && hoverCosmetics.fill,\n      hoverEffects = point && point.config.hoverEffects,\n      anchorProps = point && point.config.anchorProps,\n      borderColor = hoverCosmetics && hoverCosmetics.borderColor,\n      borderThickness = hoverCosmetics && hoverCosmetics.borderThickness,\n      attrObj = {},\n      setLink = point && point.link;\n    // if hover cosmetics then add that in the attrObj\n    if (showHover) {\n      attrObj = {\n        r: radius,\n        fill: fill,\n        stroke: borderColor,\n        'stroke-width': borderThickness,\n        cx: xAxis.getPixel(point.x),\n        cy: yAxis.getPixel(point.y)\n      };\n    }\n    animationManager.setAnimationState(showHover ? 'mouseover' : 'mouseout');\n\n    tracker = animationManager.setAnimation({\n      el: trackerCheck || 'circle',\n      attr: showHover && attrObj,\n      container: dataset.getContainer('plotGroup'),\n      component: dataset,\n      doNotRemove: true,\n      callback: !showHover && hideFn\n    });\n    showHover && tracker.show();\n    if (!trackerCheck) {\n      dataset.addGraphicalElement('tracker', tracker);\n    }\n    // Attach the required information for the hovering element.\n    point && tracker.data('eventArgs', {\n      x: point.x,\n      y: point.y,\n      tooltip: point.config.toolText,\n      link: setLink,\n      showValue: point.config.showValue,\n      hoverColor: (point.config.hoverEffects.enabled === true) ? hoverCosmetics.plotFillHoverColor : UNDEF,\n      hoverAlpha: (point.config.hoverEffects.enabled === true) ? hoverCosmetics.plotFillHoverAlpha : UNDEF,\n      anchorBgColor: anchorProps.bgColor,\n      anchorBgAlpha: anchorProps.anchorBgAlpha,\n      anchorAlpha: anchorProps.anchorAlpha,\n      anchorBorderColor: anchorProps.borderColor,\n      anchorBorderThickness: (point.config.hoverEffects.enabled === true) ? borderThickness : anchorProps.borderThickness,\n      anchorRadius: anchorProps.radius,\n      anchorSides: anchorProps.sides,\n      anchorStartAngle: anchorProps.startAngle,\n      anchorHoverSides: hoverEffects.anchorSides\n    });\n\n    /* store the hovered point as last visible point. This is required to avoid redaundant calls if the same\n    point is hovered. */\n    chartConfig.lastHoveredPoint = point;\n\n    attrObj.cursor = setLink ? POINTER : '';\n  }\n  // eslint-disable-next-line\n  drawCommonElements () {\n    // Override and do nothing\n  }\n  // eslint-disable-next-line\n  animateCommonElements () {\n    // Override and do nothing\n  }\n\n  /**\n   * Function to remove a dataset\n   */\n  remove () {\n    super.remove();\n    this._deleteGridImages();\n  }\n\n  /**\n   * Function to draw the plots. When there is zooming or panning this function is called\n   * and it draws accordingly. Whenver there is zoom detected it clears all the graphics and redraws\n   * everything, in case of panning only visible or nearby grids are drawn.\n   * Zoomscatter uses 9 grid system, so whenever it is zoomed the visible grid/grids are rendered\n   * and on next thread nearby but not visible grids are rendered so that when user pans it sees the\n   * plots instantly. Grids are determined on baseis of zoom and canvas width and height.\n   * At a given instance max 4 grids could be visible, so all visible grids are drawn on same thread\n   * and nearby remaining(out of 9) grids are drawn on next thread, to reduce load.\n   * In case of pinch to zoom, only group is zoomed by corresponding input manager and at lastdraw is\n   * called.\n   */\n  drawPlots () {\n    var dataset = this,\n      animationManager = dataset.getFromEnv('animationManager'),\n      xAxis = dataset.getFromEnv('xAxis'),\n      yAxis = dataset.getFromEnv('yAxis'),\n      scaleX,\n      scaleY,\n      dsConfig = dataset.config,\n      plotGroup = dataset.getContainer('plotGroup'),\n      zoomedRadius,\n      containerLine,\n      containerPlot,\n      prevContainerLine = dataset.getContainer('containerLine'),\n      prevContainerPlot = dataset.getContainer('containerPlot'),\n      quickRenderVisibleGrids = false,\n      borderThickness = dataset.config.anchorBorderThickness;\n    /* a flag to check if there is a modification in the lastViewPort and determine\n      if the action is supposedly zoom or paning one. */\n    // Save current scroll position\n    dataset.saveScrollPos();\n    // TODO move to create containers\n    // create the image group if not being created\n    containerLine = animationManager.setAnimation({\n      el: prevContainerLine || 'group',\n      attr: {\n        name: 'lineGroup'\n      },\n      container: plotGroup,\n      component: dataset,\n      label: 'group'\n    });\n    containerPlot = animationManager.setAnimation({\n      el: prevContainerPlot || 'group',\n      attr: {\n        name: 'plotGroup'\n      },\n      container: plotGroup,\n      component: dataset,\n      label: 'group'\n    });\n\n    /*\n     * Consider the cases:\n     * 1. initiallyHidden is true\n     * 2. dataset is hidden by legend interactivity(and then chart is interacted)\n     *\n     * For the above the cases, dataset have visibility state set to false and should be hidden.\n    */\n    if (!dataset.getState('visible')) {\n      // when visible state of dataset is false, hide the plot and line\n      containerLine.hide();\n      containerPlot.hide();\n    } else {\n      // show when visible state is not explicitly set to false\n      containerLine.show();\n      containerPlot.show();\n    }\n\n    !prevContainerLine && dataset.addContainer('containerLine', containerLine);\n    !prevContainerPlot && dataset.addContainer('containerPlot', containerPlot);\n\n    // modifications in viewPortConfig indicates it is a zoom effect and not pan.\n    if (dataset.hasDrawingRefChanged() || dataset.wasLastDrawPixelated || dataset.getState('dirty')) {\n      dataset.wasLastDrawPixelated = false;\n      /* For zoomedRadius below 2 pixels, it becomes tough for tooltip display, hence minimum 2 pixels is\n      the lower cut-off.Similarily, zoomedDiameter can not be expected to be more than the canvasWidth or\n      canvasHeight becuase there is no point of letting the user zoom beyond a level where only a single\n      plot covers the entire canvas area */\n      dataset.calculateZoomedRadius();\n      scaleX = getVisibilityRatio(xAxis);\n      scaleY = getVisibilityRatio(yAxis);\n      zoomedRadius = dsConfig.radius * Math.min(scaleX, scaleY);\n      dataset.zoomRadiusOb = {\n        rx: xAxis.getValue(zoomedRadius + borderThickness) - xAxis.getValue(0),\n        ry: yAxis.getValue(0) - yAxis.getValue(zoomedRadius + borderThickness)\n      };\n      dataset._deleteGridImages(); // delete the old grids.\n      dataset._graphics._grid = {}; // initialise the _grid Object.\n      quickRenderVisibleGrids = true; // in case of zoom do not create a seperate thread for the first drawing\n    }\n    // now draw the grid image\n    dataset._gridDraw(quickRenderVisibleGrids);\n    dataset.setState('dirty', false);\n  }\n  /*\n    * Delete the already drawn images\n    * Delete previous drawing threads\n  */\n  _deleteGridImages () {\n    var imageElem,\n      lineImage,\n      lineCanvas,\n      canvasElem,\n      gridElem,\n      rowIndex,\n      colIndex,\n      row,\n      dataset = this,\n      datasetConfig = dataset.config,\n      datasetGraphics = dataset._graphics,\n      imagePool = datasetGraphics._imagePool || (datasetGraphics._imagePool = []),\n      canvasPool = datasetGraphics._canvasPool || (datasetGraphics._canvasPool = []),\n      lineImagePool = datasetGraphics._lineImagePool || (datasetGraphics._lineImagePool = []),\n      lineCanvasPool = datasetGraphics._lineCanvasPool || (datasetGraphics._lineCanvasPool = []),\n      grid = datasetGraphics._grid || [],\n      batchDrawTimers = datasetConfig._batchDrawTimers;\n\n    // delete previous drawing jobs\n    if (batchDrawTimers && batchDrawTimers.length) {\n      while (batchDrawTimers.length) {\n        dataset.removeJob(batchDrawTimers.shift());\n      }\n    }\n\n    for (rowIndex in grid) {\n      row = grid[rowIndex];\n      if (row) {\n        for (colIndex in row) {\n          gridElem = row[colIndex];\n          if (gridElem && gridElem.drawState) {\n            // unlink the image element\n            imageElem = gridElem.image;\n            // blanks the src of the image element.\n            imageElem.attr({\n              'src': '',\n              'width': 0,\n              'height': 0\n            });\n            imagePool.push(imageElem); // push the already drawn image in the image pool\n            delete gridElem.image;\n            // unlink the canvas element\n            canvasElem = gridElem.canvas;\n            canvasPool.push(canvasElem); // push the already drawn canvas in the canvas pool\n            delete gridElem.canvas;\n            delete gridElem.ctx;\n\n            if ((lineImage = gridElem.lineImage)) {\n              // blanks the src of the line image element.\n              lineImage.attr({\n                'src': '',\n                'width': 0,\n                'height': 0\n              });\n              lineImagePool.push(lineImage); // push the already drawn image in the image pool\n              delete gridElem.lineImage;\n              // unlink the canvas element\n              lineCanvas = gridElem.lineCanvas;\n              lineCanvasPool.push(lineCanvas); // push the already drawn canvas in the canvas pool\n              delete gridElem.lineCanvas;\n              delete gridElem.lineCtx;\n            }\n          }\n        }\n      }\n    }\n    // delete the grid store\n    delete datasetGraphics._grid;\n  }\n  /*\n    * Primarily updates the gridManager using _gridManager(). But in case of pan, it does in timer to avoid mouse\n    freezing. So even if the drawing part becomes heavy, they dont block mouse drag event, enriching the UI\n    experience,\n    * @param quickRenderVisibleGrids {Boolean} - The flag is TRUE for zooming action and FALSE during the panning actions.\n  */\n  _gridDraw (quickRenderVisibleGrids) {\n    var dataset = this,\n      datasetConfig = dataset.config;\n      // viewPortConfig = chartConfig.viewPortConfig;\n\n    // clear previous drading thread if any\n    // TODO - use job scheduler\n    clearTimeout(datasetConfig.timer);\n\n    /* Pan the image group to the latest viewPortConfigurations taking the scaling factors(due to zooming) in\n    account */\n    // datasetGraphics.container.transform('t' + Math.round(-viewPortConfig.x * viewPortConfig.scaleX) + ',' +\n    //           Math.round(-viewPortConfig.y * viewPortConfig.scaleY));\n\n    if (quickRenderVisibleGrids) { // Zoom actions\n      // draw grid members if required\n      dataset._gridManager();\n    } else {\n      // TODO - Use scheduler\n      // Pan(/Drag) actions.\n      // _gridManager() is called in setTimeout() to avoid frezzed mousemove as the drawing is heavy\n      datasetConfig.timer = dataset.addJob('_gridManagerId', function () {\n        // draw grid members if required\n        dataset._gridManager();\n      }, priorityList.label);\n    }\n  }\n  /**\n   * Function to get the 9 grids, divided by visible and invisible grids.\n   * A max of 4 and min 1 grid/s could be visible out of 9\n   */\n  getAllGrids () {\n    var dataset = this,\n      dsConfig = dataset.config,\n      chartConfig = dataset.getFromEnv('chart').config,\n      xAxis = dataset.getFromEnv('xAxis'),\n      yAxis = dataset.getFromEnv('yAxis'),\n      visibleXGrids = getVisibleGridsIndex(xAxis),\n      visibleYGrids = getVisibleGridsIndex(yAxis),\n      nineGridsXIndices = numberNeighbours(visibleXGrids.focusedGrid),\n      nineGridsYIndices = numberNeighbours(visibleYGrids.focusedGrid),\n      visibleArr = [],\n      nearByArr = [],\n      i = 0,\n      j = 0,\n      datasetGraphics = dataset._graphics,\n      grids = datasetGraphics._grid,\n      row = {},\n      element,\n      scaleX = getVisibilityRatio(xAxis),\n      scaleY = getVisibilityRatio(yAxis),\n      noRow = Math.ceil(scaleY),\n      noCol = Math.ceil(scaleX),\n      // Getting neigbour grids\n      startRow = Math.max(visibleYGrids.focusedGrid - 1, 0),\n      endRow = Math.min(visibleYGrids.focusedGrid + 1, noRow - 1),\n      startCol = Math.max(visibleXGrids.focusedGrid - 1, 0),\n      endCol = Math.min(visibleXGrids.focusedGrid + 1, noCol - 1),\n      cellWidth = xAxis.getAxisConfig('axisDimention').axisLength || chartConfig.canvasWidth,\n      cellHeight = yAxis.getAxisConfig('axisDimention').axisLength || chartConfig.canvasHeight,\n      xAxisConfig = xAxis.config,\n      yAxisConfig = yAxis.config,\n      xMin = xAxisConfig.axisRange.min,\n      xMax = xAxisConfig.axisRange.max,\n      yMin = yAxisConfig.axisRange.min,\n      yMax = yAxisConfig.axisRange.max,\n      radius = dsConfig.radius * Math.min(scaleX, scaleY),\n      borderWidth = dsConfig.plotCosmetics.borderWidth,\n      padPx = radius + borderWidth,\n      xRadiusPad = Math.abs(padPx / (cellWidth * scaleX / (xAxis.config.axisRange.max - xAxis.config.axisRange.min))),\n      yRadiusPad = Math.abs(padPx / (cellHeight * scaleY / (yAxis.config.axisRange.max - yAxis.config.axisRange.min))),\n      xRightValue,\n      xLeftValue,\n      yTopValue,\n      yBottomValue,\n      appliedLeftXPad,\n      appliedRightXPad,\n      gridY,\n      gridX,\n      yRefPx = yAxis.getPixel(yAxis.config.axisRange.max),\n      xRefPx = xAxis.getPixel(xAxis.config.axisRange.min);\n    // Make grids if not present\n    if (!grids) {\n      dataset.config.grids = grids = {};\n    }\n    for (i = startRow; i <= endRow; ++i) {\n      grids[i] = row = grids[i] || {};\n      gridY = yRefPx + (i * cellHeight);\n      yTopValue = yAxis.getValue(gridY);\n      yBottomValue = yAxis.getValue(gridY + cellHeight);\n      for (j = startCol; j <= endCol; ++j) {\n        appliedLeftXPad = j === 0 ? padPx : 0;\n        appliedRightXPad = j === (noCol - 1) ? padPx : 0;\n        gridX = xRefPx + (j * cellWidth) - appliedLeftXPad;\n        // Calculating values\n        xLeftValue = xAxis.getValue(gridX);\n        xRightValue = xAxis.getValue(gridX + cellWidth + appliedLeftXPad + appliedRightXPad);\n        row[j] = element = row[j] || {\n          xPixel: gridX,\n          width: Math.abs(xAxis.getPixel(xRightValue) - gridX),\n          yPixel: gridY,\n          height: yAxis.getPixel(yBottomValue) - gridY,\n          xLeftValue: xLeftValue,\n          yTopValue: yTopValue,\n          xRightValue: xRightValue,\n          yBottomValue: yBottomValue,\n          drawState: 0, // 0=> not drawn, 1=> drawn, 2=> is drawing\n\n          // padding to accomodate the partial drawing of the elements of neighbouring grid\n          xMinWPad: Math.max(Math.min(xLeftValue, xRightValue) - xRadiusPad, xMin),\n          yMinWPad: Math.max(Math.min(yTopValue, yBottomValue) - yRadiusPad, yMin),\n          xMaxWPad: Math.min(Math.max(xLeftValue, xRightValue) + xRadiusPad, xMax),\n          yMaxWPad: Math.min(Math.max(yTopValue, yBottomValue) + yRadiusPad, yMax),\n          i: i,\n          j: j\n        };\n\n        if (!element.drawState) {\n          if (~visibleXGrids.indexOf(j) && ~visibleYGrids.indexOf(i)) {\n            visibleArr.push(element);\n          } else if (~nineGridsXIndices.indexOf(j) && ~nineGridsYIndices.indexOf(i)) {\n            nearByArr.push(element);\n          }\n        }\n      }\n    }\n    return {\n      focused: visibleArr,\n      nearBy: nearByArr\n    };\n  }\n\n  /**\n   * Calculation of position during post space management\n   *\n   * @memberof ZoomScatter\n   */\n  allocatePosition () {\n    var dataset = this,\n      datasetConfig = dataset.config,\n      dsStore = dataset.components.data,\n      dsStoreLength = dsStore.length,\n      xAxis = dataset.getFromEnv('xAxis'),\n      yAxis = dataset.getFromEnv('yAxis'),\n      cx,\n      cy,\n      i,\n      element,\n      config,\n      radius = datasetConfig.zoomedRadius;\n\n    for (i = 0; i < dsStoreLength; i++) {\n      config = dsStore[i].config;\n      element = config.setValue;\n      cx = xAxis.getPixel(element.x); // value to pixel conversions\n      cy = yAxis.getPixel(element.y); // value to pixel conversions\n\n      config.props = {\n        element: {\n          attr: {\n            polypath: [0, cx, cy, radius || config.anchorProps.radius]\n          }\n        },\n        label: {\n          attr: {}\n        }\n      };\n    }\n  }\n  /*\n       * initially draw max 4 grid (grid of the 4 sample corner point) which are visible and then draw\n       the rest images\n      */\n  _gridManager () {\n    var dataset = this,\n      gridsOb = {},\n      callback;\n\n    gridsOb = dataset.getAllGrids();\n    dataset.config._drawGrid = gridsOb.focused;\n    // The visible images are drawn first and the rest images are drawn as a callback of the rest.\n    if (gridsOb.focused.length || gridsOb.nearBy.length) {\n      dataset.config._drawGrid = gridsOb.focused;\n      // create the call back function that will be called once these grids are created\n      callback = function () {\n        dataset.config._drawGrid = gridsOb.nearBy;\n        // No callback after the 2nd phase\n        dataset._drawGridArr();\n      };\n      // draw the images for 1st phase\n      dataset._drawGridArr(callback);\n    }\n  }\n  /*\n    *\n    * @param callBack {Function} - Once the four visible images are drawn, this function sets the _drawGrid to the\n    rest images, which are drawn again. Hence this callback is invoked at the end of the completion of drawing of\n    the first phase images.\n  */\n  _drawGridArr (callBack) {\n    // draw grids and delete them from the drawGridarr once completed\n    var gridElem,\n      canvasElem,\n      lineCanvasElem,\n      ctx,\n      lineCtx,\n      dataset = this,\n      datasetConfig = dataset.config,\n      drawLine = datasetConfig.drawLine,\n      gridIndexArr = datasetConfig._drawGrid,\n      // list of images to be drawn.\n      gridSubArr = [],\n      animationManager = dataset.getFromEnv('animationManager'),\n      containerLine = dataset.getContainer('containerLine'),\n      containerPlot = dataset.getContainer('containerPlot'),\n      xAxis = dataset.getFromEnv('xAxis'),\n      yAxis = dataset.getFromEnv('yAxis'),\n      width,\n      height,\n      scaleX = getVisibilityRatio(xAxis),\n      scaleY = getVisibilityRatio(yAxis),\n      imagePool = dataset._graphics._imagePool || [],\n      canvasPool = dataset._graphics._canvasPool || [],\n      lineImagePool = dataset._graphics._lineImagePool || [],\n      lineCanvasPool = dataset._graphics._lineCanvasPool || [],\n      plotCosmetics = datasetConfig.plotCosmetics,\n      // update the radius with every zoom configurations.\n      radius = datasetConfig.radius * Math.min(scaleX, scaleY),\n      // offset = (chart.components.xAxis[0].getAxisConfig('axisDimention').x || chartConfig.canvasLeft) -\n      //             chartConfig.canvasLeft,\n      gridX,\n      gridY;\n\n    if (gridIndexArr.length) {\n      while (gridIndexArr.length) {\n        gridElem = gridIndexArr.shift();\n\n        gridX = gridElem.xPixel;\n        gridY = gridElem.yPixel;\n        width = gridElem.width;\n        height = gridElem.height;\n\n        if (gridElem.drawState === 2) {\n          continue;\n        }\n        gridElem.drawState = 2;\n\n        // use another set of images for drawing the lines.\n        if (drawLine) {\n          // add the image from the pool\n          if (lineImagePool.length) {\n            gridElem.lineImage = lineImagePool.shift();\n          }\n          gridElem.lineImage = animationManager.setAnimation({\n            el: gridElem.lineImage || 'image',\n            attr: {\n              x: gridX,\n              y: gridY,\n              width: width,\n              height: height\n            },\n            container: containerLine,\n            component: dataset,\n            label: 'image'\n          });\n          if (lineCanvasPool.length) {\n            gridElem.lineCanvas = lineCanvasElem = lineCanvasPool.shift();\n          } else {\n            // create the canvas if it doesnot exist.\n            gridElem.lineCanvas = lineCanvasElem = win.document.createElement('canvas');\n          }\n\n          // set the canvas dimensions\n          lineCanvasElem.setAttribute('width', width);\n          lineCanvasElem.setAttribute('height', height);\n          // cache the context of the canvas element.\n          lineCtx = gridElem.lineCtx = lineCanvasElem.getContext('2d');\n\n          // apply the cosmetics of the anchors.\n          lineCtx.fillStyle = plotCosmetics.fillStyle;\n          lineCtx.strokeStyle = plotCosmetics.lineStrokeStyle;\n          lineCtx.lineWidth = plotCosmetics.lineWidth;\n        }\n        // add the image from the pool\n        if (imagePool.length) {\n          gridElem.image = imagePool.shift();\n        }\n        gridElem.image = animationManager.setAnimation({\n          el: gridElem.image || 'image',\n          attr: {\n            x: gridX,\n            y: gridY,\n            width: width,\n            height: height\n          },\n          container: containerPlot,\n          component: dataset,\n          label: 'image'\n        });\n\n        // add the canvas element from the pool\n        if (canvasPool.length) {\n          gridElem.canvas = canvasElem = canvasPool.shift();\n        } else {\n          // create the canvas if it doesnot exist.\n          gridElem.canvas = canvasElem = win.document.createElement('canvas');\n        }\n\n        // set the canvas dimensions\n        canvasElem.setAttribute('width', width);\n        canvasElem.setAttribute('height', height);\n        ctx = gridElem.ctx = canvasElem.getContext('2d');\n        // cache the context of the canvas element.\n        // apply the cosmetics of the anchors.\n        if (radius < 1) {\n          /* incase of very small radius, set the fill as stroke-style and draw a dot. This is acts as a\n          leverage on performance. */\n          ctx.strokeStyle = plotCosmetics.fillStyle;\n          ctx.lineWidth = 0.5;\n        } else {\n          ctx.fillStyle = plotCosmetics.fillStyle;\n          ctx.strokeStyle = plotCosmetics.strokeStyle;\n          ctx.lineWidth = plotCosmetics.borderWidth;\n        }\n        gridSubArr.push(gridElem);\n      }\n\n      // reset the batch drawing index\n      datasetConfig._batchDrawindex = (dataset.config.JSONData.data && dataset.config.JSONData.data.length - 1) || 0;\n      // start drawing the images in batches.\n      dataset._drawGridArrBatch(gridSubArr, callBack, !datasetConfig.animation.enabled);\n    } else {\n      // if there is nothing to draw then call the callBack\n      callBack && callBack();\n    }\n  }\n  /**\n    * Draw the grids of the array together in batch.\n    * At the batch end call the call back.\n    * Use grid's own image and canvas only.\n    * At the end set the drawState of the grids.\n    * Draw in batches so that it naver goes for script time out.\n    * Process - Loop is iteratedover every data item and if it falls in the rande of grids that is currently\n    * being drawn then it is renderedin that particular grid\n    * @param gridArr {Array} - Stores the grid Elements, which has its own indivual images, canvas elements and\n    contexts\n    * @param callBack {Function} - Function being called at the end of all drawings of the images in the gridArr.\n    * @param doNotUpdateImage {Boolean} - Flag to update the visual configurations. If set to true, At every batch\n    the images are viusally updated. Once set to false they are shown only if all the drawing is completed. This\n    is attained using showAnimation = 0\n  */\n  _drawGridArrBatch (gridArr, callBack, doNotUpdateImage) {\n    var cx,\n      cy,\n      cx1,\n      cx2,\n      cy1,\n      cy2,\n      storeX,\n      j,\n      gridElem,\n      ctx,\n      lineCtx,\n      element,\n      leftElement,\n      rightElement,\n      lineImage,\n      lineCanvas,\n      image,\n      canvas,\n      regresionPoints,\n      dataset = this,\n      datasetConfig = dataset.config,\n      drawLine = datasetConfig.drawLine,\n      plotCosmetics = datasetConfig.plotCosmetics,\n      i = datasetConfig._batchDrawindex,\n      arr = dataset.components.data,\n      chunkSize = datasetConfig.chunkSize,\n      endIndex = i - chunkSize,\n      xAxis = dataset.getFromEnv('xAxis'),\n      yAxis = dataset.getFromEnv('yAxis'),\n      chart = dataset.getFromEnv('chart'),\n      animationManager = dataset.getFromEnv('animationManager'),\n      dataSource = chart.getFromEnv('dataSource'),\n      JSONData = datasetConfig.JSONData,\n      radius = datasetConfig.zoomedRadius,\n      // If regression line should be drawn\n      regressionStatus = pluckNumber(JSONData.showregressionline, chart.config.showregressionline, 0),\n      regressionLineColor,\n      regressionLineThickness,\n      regressionLineAlpha,\n\n      // stores the already plotted pixels for caching and performance improvement.\n      _store = datasetConfig._store || [],\n      // doStroke for the plot is set to TRUE only if there exists a lineWidth or radius is less than 1 pixel\n      doStroke = (plotCosmetics.lineWidth || (radius < 1)),\n      leftElCx,\n      leftElCy;\n\n    if (regressionStatus) {\n      // Regression line color picking preference :\n      // regressionColor at dataset level > regressionColor at chart level > anchor border color of plots > line color\n      regressionLineColor = toRaphaelColor(pluck(JSONData.regressionlinecolor, dataSource.chart.regressionlinecolor, datasetConfig.anchorbordercolor,\n        datasetConfig.lineColor, 'fff000'));\n      // regressionLineThickness at dataset level > regressionLineThickness at chart level\n      regressionLineThickness = pluckNumber(JSONData.regressionlinethickness, dataSource.chart.regressionlinethickness, 1);\n      // regressionLineAlpha at dataset level > regressionThickness at chart level\n      regressionLineAlpha = pluckNumber(JSONData.regressionlinealpha, dataSource.chart.regressionlinealpha, 100) / 100;\n    }\n\n    // clear all the previous visual for the canvas grid and update its cosmetics.\n    for (j = 0; j < gridArr.length; j += 1) {\n      gridArr[j].ctx.beginPath();\n      if (drawLine) {\n        gridArr[j].lineCtx.beginPath();\n      }\n    }\n\n    endIndex = endIndex <= 0 ? 0 : endIndex; // lower limit is 0\n\n    for (; i >= endIndex; i -= 1) {\n      element = arr[i] && arr[i].config.setValue;\n      // Check for NaN value.\n      if (!element || isNaN(element.x) || isNaN(element.y)) {\n        continue;\n      }\n      // Check which grid is the element lying and draw it in that grid.\n      for (j = 0; j < gridArr.length; j += 1) {\n        gridElem = gridArr[j];\n        if (!inRangeMod(element.x, gridElem.xMinWPad, gridElem.xMaxWPad) ||\n          !inRangeMod(element.y, gridElem.yMinWPad, gridElem.yMaxWPad)) {\n          if (drawLine && i && lineIntersectsGrid(element,\n            arr[i - 1].config.setValue, gridElem)) {\n            // Draw only line if line goes through this grid\n            leftElement = arr[i - 1].config.setValue;\n            leftElCx = xAxis.getPixel(leftElement.x) - gridElem.xPixel;\n            leftElCy = yAxis.getPixel(leftElement.y) - gridElem.yPixel;\n            cx = xAxis.getPixel(element.x) - gridElem.xPixel;\n            cy = yAxis.getPixel(element.y) - gridElem.yPixel;\n            lineCtx = gridElem.lineCtx;\n            lineCtx.moveTo(Math.round(leftElCx), Math.round(leftElCy));\n            lineCtx.lineTo(cx, cy);\n          }\n          continue;\n        }\n\n        ctx = gridElem.ctx;\n        lineCtx = gridElem.lineCtx;\n\n        cx = xAxis.getPixel(element.x) - gridElem.xPixel; // value to pixel conversions\n        cy = yAxis.getPixel(element.y) - gridElem.yPixel; // value to pixel conversions\n        /* Incase there is already a point being drawn with exact same center pixelwise, there is no need to\n          draw again. This can happen when two data points are very closely placed. This caching is done in\n          _store */\n        storeX = _store[cx];\n\n        if (!storeX) {\n          storeX = _store[cx] = {};\n        }\n\n        if (!storeX[cy]) {\n          storeX[cy] = true; // set the flag of a circle being drawn at that pixel to TRUE\n          if (drawLine) {\n            leftElement = i && arr[i - 1].config.setValue;\n            rightElement = i < arr.length - 1 && arr[i + 1].config.setValue;\n            if (leftElement && !isNaN(leftElement.x) && !isNaN(leftElement.y)) {\n              leftElCx = xAxis.getPixel(leftElement.x) - gridElem.xPixel;\n              leftElCy = yAxis.getPixel(leftElement.y) - gridElem.yPixel;\n              lineCtx.moveTo(Math.round(leftElCx), Math.round(leftElCy));\n              lineCtx.lineTo(cx, cy);\n              if ((!inRangeMod(rightElement.x, gridElem.xMinWPad, gridElem.xMaxWPad) ||\n                !inRangeMod(rightElement.y, gridElem.yMinWPad, gridElem.yMaxWPad)) && !isNaN(rightElement.x) &&\n                !isNaN(rightElement.y)) {\n                lineCtx.lineTo(xAxis.getPixel(rightElement.x) - gridElem.xPixel,\n                  yAxis.getPixel(rightElement.y) - gridElem.yPixel);\n              }\n            }\n          }\n          if (radius < 1) {\n            /* Drawing a dot seemed to have a performance preference to drawing an arc. So if radius\n            turns less than 1 pixel, drawing a dot is prefered. */\n            ctx.moveTo(cx, cy);\n            ctx.lineTo(cx + 1, cy);\n          } else {\n            ctx.moveTo(cx + radius, cy);\n            ctx.arc(cx, cy, radius, 0, pi2);\n          }\n        }\n      }\n    }\n\n    // clear all the previous visual for the canvas grid and update its cosmetics.\n    for (j = 0; j < gridArr.length; j += 1) {\n      gridElem = gridArr[j];\n      ctx = gridElem.ctx;\n      ctx.fill();\n      doStroke && ctx.stroke();\n      ctx.closePath();\n\n      if (drawLine) {\n        lineCtx = gridElem.lineCtx;\n        // lineCtx.fill();\n        doStroke && lineCtx.stroke();\n        lineCtx.closePath();\n      }\n    }\n    // reset the _batchDrawindex\n    datasetConfig._batchDrawindex = i;\n\n    // if there is any remaning drawing to be drawn\n    if (i >= 0) {\n      if (!doNotUpdateImage) {\n        // update all the grid images for the visual clue.\n        for (j = 0; j < gridArr.length; j += 1) {\n          image = gridArr[j].image;\n          canvas = gridArr[j].canvas;\n          // update the src of the images.\n          animationManager.setAnimation({\n            el: image,\n            attr: {\n              src: canvas.toDataURL('image/png')\n            },\n            component: dataset\n          });\n          if (datasetConfig.drawLine) {\n            lineImage = gridArr[j].lineImage;\n            lineCanvas = gridArr[j].lineCanvas;\n            // update the src of the images.\n            animationManager.setAnimation({\n              el: lineImage,\n              src: canvas.toDataURL('image/png'),\n              component: dataset\n            });\n          }\n        }\n      }\n\n      // store the jobId for future cancellation\n      (datasetConfig._batchDrawTimers || (datasetConfig._batchDrawTimers = [])).push(\n        dataset.addJob('_drawGridArrBatchID', function () {\n          dataset.getFromEnv('chart') && dataset._drawGridArrBatch(gridArr, callBack, doNotUpdateImage);\n        }, priorityList.draw));\n    } else {\n      // drawing completed\n      // remove the temp store arr\n      dataset.setupKdTree();\n      delete datasetConfig._store;\n      // regresion line generalised for all images.\n      if (regressionStatus) {\n        // Fetch the regression points\n        regresionPoints = datasetConfig.regressionPoints;\n        // update all the grid images for the regressionLine.\n        for (j = 0; j < gridArr.length; j += 1) {\n          gridElem = gridArr[j];\n          image = gridElem.image;\n          canvas = gridElem.canvas;\n          ctx = gridElem.ctx;\n\n          if (!regresionPoints.length) {\n            continue;\n          }\n          // extend the points to make the regressionLine throughout the canvas.\n          cx1 = xAxis.getPixel(regresionPoints[0].x) - gridElem.xPixel;\n          cy1 = yAxis.getPixel(regresionPoints[0].y) - gridElem.yPixel;\n          cx2 = xAxis.getPixel(regresionPoints[1].x) - gridElem.xPixel;\n          cy2 = yAxis.getPixel(regresionPoints[1].y) - gridElem.yPixel;\n          ctx.beginPath();\n          ctx.strokeStyle = regressionLineColor;\n          ctx.lineWidth = regressionLineThickness;\n          // Apply opacity to regression line\n          ctx.globalAlpha = regressionLineAlpha;\n          ctx.moveTo(cx1, cy1);\n          ctx.lineTo(cx2, cy2);\n          ctx.stroke();\n          ctx.closePath();\n        }\n      }\n\n      // update all the grid images for the visual clue.\n      for (j = 0; j < gridArr.length; j += 1) {\n        gridElem = gridArr[j];\n\n        image = gridElem.image;\n        canvas = gridElem.canvas;\n        gridElem.drawState = 1; // set the drawState flag as drawn.\n\n        animationManager.setAnimation({\n          el: image,\n          attr: {\n            src: canvas.toDataURL('image/png')\n          },\n          component: dataset\n        });\n        if (drawLine) {\n          lineImage = gridElem.lineImage;\n          lineCanvas = gridElem.lineCanvas;\n          animationManager.setAnimation({\n            el: lineImage,\n            attr: {\n              src: lineCanvas.toDataURL('image/png')\n            },\n            component: dataset\n          });\n        }\n      }\n      // invoke the completion callBack\n      callBack && callBack();\n    }\n  }\n  /**\n   * API to find out the maximum and minimum values of regressionline path.\n   *\n   * @returns {Object} xMax, xMin, yMax, yMin\n   * @memberof ScatterDataset\n   */\n  getRegressionPoints () {\n    var dataset = this,\n      regressionPoints = dataset.config.regressionPoints,\n      xMax = -Infinity,\n      xMin = Infinity,\n      yMax = -Infinity,\n      yMin = Infinity,\n      i,\n      regPointsLength;\n\n    if (!regressionPoints || !regressionPoints.length) {\n      return;\n    }\n    regPointsLength = regressionPoints.length;\n    for (i = 0; i < regPointsLength; i++) {\n      xMax = Math.max(xMax, regressionPoints[i].x);\n      xMin = Math.min(xMin, regressionPoints[i].x);\n\n      yMax = Math.max(yMax, regressionPoints[i].y);\n      yMin = Math.min(yMin, regressionPoints[i].y);\n    }\n    return {\n      max: yMax,\n      min: yMin,\n      xMax: xMax,\n      xMin: xMin\n    };\n  }\n  /*\n    * This function is used to make a dataset visible when clicked on its respective legend.\n    * This fucntion is fired from drawGraph() every time a deactivated legend is clicked.\n    */\n  show () {\n    var dataSet = this,\n      lineGroup = dataSet.getContainer('containerLine'),\n      plotGroup = dataSet.getContainer('containerPlot'),\n      legend = dataSet.getFromEnv('legend');\n    if (legend && legend.getItem(dataSet.config.legendItemId)) {\n      legend.getItem(dataSet.config.legendItemId).removeLegendState('hidden');\n    }\n    dataSet.setState('visible', true);\n    lineGroup.show();\n    plotGroup.show();\n    dataSet.setState('dirty', true);\n  }\n  // eslint-disable-next-line\n  setContainerVisibility () {\n    // empty fn\n  }\n  /**\n   * Function for drawing zoomscatter plots.\n   */\n  draw () {\n    var dataSet = this,\n      conf = dataSet.config,\n      xAxis = dataSet.getFromEnv('xAxis'),\n      xAxisZeroPos = xAxis.getPixel(0),\n      xAxisFirstPos = xAxis.getPixel(1),\n      groupMaxWidth = dataSet.getFromEnv('groupMaxWidth'),\n      drawn = conf.drawn,\n      scrollMinValForLabel,\n      scrollMaxValForLabel,\n      skipInfo = (dataSet.getSkippingInfo && dataSet.getSkippingInfo()) || {},\n      skippingApplied = skipInfo.skippingApplied;\n\n    if (!groupMaxWidth) {\n      groupMaxWidth = Math.abs(xAxisFirstPos - xAxisZeroPos);\n      dataSet.addToEnv('groupMaxWidth', groupMaxWidth);\n    }\n\n    !drawn && dataSet.createContainer();\n    dataSet.setContainerVisibility(true);\n\n    if (skippingApplied) {\n      dataSet.hidePlots();\n    }\n    // Draw all the graphic elements\n    dataSet.drawPlots();\n\n    dataSet.drawCommonElements && !dataSet.config.skipCommonElements && dataSet.drawCommonElements();\n\n    // Datalabels are drawn in a different thread for the first time and later drawn in the same thread.\n    conf.drawn\n      ? dataSet.drawLabel(scrollMinValForLabel, scrollMaxValForLabel)\n      : dataSet.addJob('labelDrawID', function () {\n        dataSet.drawLabel(scrollMinValForLabel, scrollMaxValForLabel);\n      }, priorityList.label);\n\n    // Setting the drawn flag true to draw differently incase of real time draw.\n    conf.drawn = true;\n    dataSet.removePlots();\n  }\n  /*\n  * This function is used to make a dataset hidden when clicked on its respective legend.\n  * This fucntion is fired from drawGraph() every time an activated legend is clicked.\n  */\n  hide () {\n    var dataSet = this,\n      lineGroup = dataSet.getContainer('containerLine'),\n      plotGroup = dataSet.getContainer('containerPlot'),\n      legend = dataSet.getFromEnv('legend');\n    if (legend && legend.getItem(dataSet.config.legendItemId)) {\n      legend.getItem(dataSet.config.legendItemId).setLegendState('hidden');\n    }\n\n    lineGroup.hide();\n    plotGroup.hide();\n\n    dataSet.setState('dirty', true);\n    dataSet.setState('visible', false);\n  }\n\n  _addLegend () {\n    var dataset = this,\n      chart = dataset.getFromEnv('chart'),\n      chartAttr = chart.getFromEnv('dataSource').chart,\n      legend = chart.getFromEnv('legend'),\n      conf = dataset.config,\n      legendItem,\n      config,\n      JSONData = dataset.config.JSONData,\n      userGivenBorderColor = pluck(JSONData.anchorbordercolor, chartAttr.anchorbordercolor),\n      seriesAnchorBorderColor = getFirstColor(pluck(userGivenBorderColor,\n        conf.plotBorderColor)),\n      seriesAnchorBgColor = getFirstColor(pluck(JSONData.anchorbgcolor, JSONData.color,\n        chartAttr.anchorbgcolor, conf.plotColor)),\n      seriesAnchorAlpha = pluck(JSONData.anchoralpha, JSONData.alpha, chartAttr.anchoralpha,\n        HUNDREDSTRING),\n      seriesAnchorBgAlpha = pluck(JSONData.anchorbgalpha, JSONData.alpha, chartAttr.anchorbgalpha,\n        HUNDREDSTRING),\n      fillColor = getFillColor(seriesAnchorBgColor, ((seriesAnchorAlpha * seriesAnchorBgAlpha) / 100)),\n      strokeColor = getFillColor(seriesAnchorBorderColor, seriesAnchorAlpha);\n\n    config = {\n      enabled: conf.includeInLegend,\n      type: dataset.type,\n      anchorSide: 2,\n      label: getFirstValue(dataset.config.JSONData.seriesname),\n      legendIconAlpha: pluckNumber(JSONData.legendiconalpha)\n    };\n    if (conf.includeinlegend) {\n      legendItem = legend.getItem(dataset.config.legendItemId);\n      if (!legendItem) {\n        dataset.config.legendItemId = legend.createItem(dataset);\n        legendItem = legend.getItem(dataset.config.legendItemId);\n        dataset.addExtEventListener('fc-click', function () {\n          legendItem.itemClickFn();\n        }, legendItem);\n      } else {\n        legendItem.configure({style: legend.config.itemStyle,\n          hiddenStyle: legend.config.itemHiddenStyle,\n          datasetVisible: legend.config.datasetVisible,\n          hoverStyle: legend.config.itemHoverStyle});\n      }\n      legendItem.configure(config);\n      legendItem.setStateCosmetics('default', {\n        symbol: {\n          fill: fillColor,\n          bgAlpha: pluckNumber(JSONData.legendiconbgalpha, JSONData.legendiconalpha, chartAttr.legendiconbgalpha, chartAttr.legendiconalpha, seriesAnchorBgAlpha),\n          borderAlpha: pluckNumber(JSONData.legendiconborderalpha, JSONData.legendiconalpha, chartAttr.legendiconborderalpha, chartAttr.legendiconalpha, '100'),\n          stroke: strokeColor,\n          rawFillColor: seriesAnchorBgColor,\n          rawStrokeColor: conf.anchorbordercolor,\n          'stroke-width': conf.anchorBorderThickness\n        }\n      });\n      // check if dataset is initiallyhidden\n      if (!dataset.getState('visible')) {\n        legendItem.setLegendState('hidden');\n      } else { // remove hidden state of legend item is dataset is not hidden\n        legendItem.removeLegendState('hidden');\n      }\n    } else if (dataset.config.legendItemId) {\n      legend.disposeItem(dataset.config.legendItemId);\n    }\n  }\n\n  /*\n       * Sets the configurations for the set level attributes.\n      */\n  _setConfigure () {\n    var i,\n      config,\n      dataObj,\n      setData,\n      setValue,\n      toolText,\n      toolTipValue,\n      macroIndices,\n      parserConfig,\n      formatedVal,\n      formatedValX,\n      setDisplayValue,\n      infMin = -Infinity,\n      infMax = +Infinity,\n      yMax = infMin,\n      yMin = infMax,\n      xMin = infMax,\n      xMax = infMin,\n      dataset = this,\n      dataStore = dataset.components.data || (dataset.components.data = []),\n      chart = dataset.getFromEnv('chart'),\n      conf = dataset.config,\n      JSONData = dataset.config.JSONData,\n      // chart level JSON format\n      chartAttr = chart.getFromEnv('dataSource').chart,\n      setDataArr = JSONData.data || [],\n      datasetLen = setDataArr.length,\n      numberFormatter = dataset.getFromEnv('number-formatter'),\n      yAxisName = parseUnsafeString(chartAttr.yaxisname),\n      xAxisName = parseUnsafeString(chartAttr.xaxisname),\n      lineDashed = conf.lineDashed,\n      lineDashStyle = conf.lineDashStyle,\n      // If regression line should be drawn\n      regressionStatus = pluckNumber(JSONData.showregressionline, chart.config.showregressionline, 0),\n      // whether regressionline to be drawn by taking primary axis as x-axis or y-axis\n      regressionShowYonX = pluckNumber(JSONData.showyonx, chartAttr.showyonx, 1),\n      parentYAxis = conf.parentYAxis,\n      tooltipSepChar = conf.toolTipSepChar,\n      seriesname = conf.seriesname;\n    // Iterate through all set level data\n    for (i = 0; i < datasetLen; i += 1) {\n      setData = setDataArr[i];\n      dataObj = dataStore[i] || (dataStore[i] = {});\n      config = dataObj.config || (dataObj.config = {});\n      // The set data is given: {x: <Number>, y : <Number>}\n      config.setValue = setValue = {\n        x: numberFormatter.getCleanValue(setData.x),\n        y: numberFormatter.getCleanValue(setData.y),\n        index: i\n      };\n      if (xMax < setValue.x) {\n        xMax = setValue.x;\n        conf.rightMostData = dataObj;\n      }\n      if (xMin > setValue.x) {\n        xMin = setValue.x;\n        conf.leftMostData = dataObj;\n      }\n      yMax = Math.max(yMax, setValue.y);\n      yMin = Math.min(yMin, setValue.y);\n      // update the regression calulations.\n      conf.showRegressionLine && this.pointValueWatcher(setValue.x, setValue.y, conf.regressionObj);\n      config.setLink = pluck(setData.link);\n      // Parsing the anchor properties for set level\n      config.anchorProps = this._parseAnchorProperties(i);\n      config.showValue = pluckNumber(setData.showvalue, conf.showValues);\n      // Dashed, color and alpha configuration in set level is only for line chart\n      config.dashed = pluckNumber(setData.dashed, lineDashed);\n      config.color = pluck(setData.color, conf.lineColor);\n      config.alpha = pluck(setData.alpha, conf.lineAlpha);\n\n      config.dashStyle = config.dashed ? lineDashStyle : 'none';\n      config.toolTipValue = toolTipValue = numberFormatter.dataLabels(setValue.y, parentYAxis);\n      config.setDisplayValue = setDisplayValue = parseUnsafeString(setData.displayvalue);\n      formatedVal = (config.formatedVal = pluck(setData.toolTipValue,\n        numberFormatter.dataLabels(setValue.y, parentYAxis)));\n      formatedValX = numberFormatter.xAxis(setValue.x);\n      config.displayValue = pluck(setDisplayValue, toolTipValue);\n      config.setTooltext = getValidValue(parseUnsafeString(pluck(setData.tooltext,\n        conf.plotToolText), false));\n      // Initial tooltext parsing\n      if (!conf.showTooltip) {\n        toolText = false;\n      } else if (config.setTooltext !== UNDEF) {\n        macroIndices = [4, 5, 6, 7, 8, 9, 10, 11];\n        parserConfig = {\n          yaxisName: yAxisName,\n          xaxisName: xAxisName,\n          yDataValue: formatedVal,\n          xDataValue: formatedValX\n        };\n        toolText = parseTooltext(config.setTooltext, macroIndices, parserConfig, setData, chartAttr,\n          JSONData);\n      } else {\n        // determine the default tooltext then.\n        if (formatedVal === null) {\n          toolText = false;\n        } else {\n          toolText = seriesname ? seriesname + tooltipSepChar : BLANKSTRING;\n          toolText += setValue.x ? formatedValX + tooltipSepChar : BLANKSTRING;\n          toolText += toolTipValue;\n        }\n      }\n\n      config.toolText = toolText;\n      if (!dataObj) {\n        dataObj = dataStore[i] = {\n          graphics: {}\n        };\n      } else if (!dataObj.graphics) {\n        dataStore[i].graphics = {};\n      }\n      // parse the hover cosmetics.\n      config.hoverEffects = this._parseHoverEffectOptions(dataObj);\n      config.anchorProps.isAnchorHoverRadius = config.hoverEffects.anchorRadius;\n    }\n    conf.xMax = xMax;\n    conf.xMin = xMin;\n    conf.yMin = yMin;\n    conf.yMax = yMax;\n    // augment the regression line to be a line series.\n    if (regressionStatus) {\n      conf.regressionPoints = getLinearRegressionPoints(JSONData.data.slice(), regressionShowYonX)[1];\n    } else {\n      conf.regressionPoints = [];\n    }\n    dataset.ErrorValueConfigure && dataset.ErrorValueConfigure();\n  }\n}\nexport default ZoomScatter;\n"],"sourceRoot":""}