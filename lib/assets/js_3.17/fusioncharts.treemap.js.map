{"version":3,"sources":["webpack:///./packages/fusioncharts/treemap/index.js","webpack:///./packages/fusioncharts/viz/treemap.js","webpack:///./packages/fc-powercharts/src/chart/treemap/index.js","webpack:///./packages/fc-powercharts/src/dataset/treemap/index.js","webpack:///./packages/fc-powercharts/src/dataset/treemap/index.animation.js","webpack:///./packages/fc-powercharts/src/chart/treemap/helper.js"],"names":["name","type","requiresFusionCharts","extension","FusionCharts","addDep","Treemap","Raphael","getDep","addSymbol","backIcon","x","y","radius","rad","y3","y4","x5","y6","homeIcon","len","x2","x3","x7","y8","x9","y10","_lastAttached","hasGradientLegend","addToEnv","registerFactory","legendItemFactory","decideLegendCreation","createColorRangeManager","mousetrackerFactory","datasetFactory","getName","__setDefaultConfig","this","config","enablemousetracking","skipCanvasDrawing","valuefontbold","configureAttributes","dataObj","skipConfigureIteration","valuesset","parseChartAttr","createComponent","setTooltipStyle","configureChildren","mouseoutHandler","e","_lastDatasetIndex","_lastPointIndex","datasets","datasetOrder","getDatasets","mouseTracker","getChildren","_firePlotEvent","_mouseEvtHandler","data","dataset","hoveredInfo","j","l","derivedEvensInfo","chart","oriEvent","originalEvent","chartConfig","canvasLeft","canvasRight","canvasBottom","canvasTop","coordinate","getMouseCoordinate","getFromEnv","chartX","chartY","pointFound","i","length","plotOverFlow","_getHoveredPlot","hovered","datasetIndex","getMouseEvents","pointIndex","fireOut","UNDEF","events","mouseoutTimer","setTimeout","clearTimeout","_checkInvalidSpecificData","addData","ref","algorithmFactory","args","Array","prototype","slice","call","arguments","unshift","_getCleanValue","realTimeUpdate","apply","removeData","triggerKDTreePartioning","addJob","kdTreePartioning","bind","priorityList","tracker","resetSingleTracker","singleTracker","graphics","attr","width","height","stroke","_manageLegendSpace","manageGradientLegendSpace","allottedSpace","flushKDTree","kdTree","attachMenuButtons","toolBar","toolBarType","toolbarVAlign","toolConf","attachChild","Tool","getId","getChild","configure","Object","assign","isHidden","back","home","numberFormatter","value","getCleanValue","getDSdef","TreeMapDS","CommonSpaceManager","DEFAULT_CURSOR","preDefStr","DEFAULT","createGroup","groupName","parentContainer","setAnimation","el","container","state","component","doNotRemove","label","inRange","a","r1","r2","swap","arr","tmp","kdTreeAbs","arrVal","result","tolerance","plotDetails","rect","max","Math","floor","sqrt","min","log","exp","pow","r","tree","buildKdTree","leftVal","rightVal","isY","mid","ob","left","right","access","point","quickselectY","k","n","m","z","s","sd","newLeft","newRight","t","quickselectX","search","currentHovered","x1","y1","y2","currentDist","p","q","calcDist","res","lastHovered","lastDist","searchX","searchY","searchTreemap","sort","b","treeMapAnimation","datasetDefStore","components","conf","elemStore","highlight","hot","polypath","datasetJSON","JSONData","algorithm","maxDepth","showNavigationBar","dsConf","rawChartAttr","metaTreeInf","toLowerCase","range","horizontalPadding","pluckNumber","horizontalpadding","verticalPadding","verticalpadding","showParent","showparent","showChildLabels","showchildlabels","showHoverEffect","showhovereffect","highlightParentsOnHover","highlightparentsonhover","defaultParentBGColor","pluck","defaultparentbgcolor","defaultNavigationBarBGColor","defaultnavigationbarbgcolor","showTooltip","showtooltip","baseFontSize","basefontsize","labelFontSize","computeFontSize","labelfontsize","baseFont","basefont","labelFont","labelfont","showTextOutline","textoutline","baseFontColor","basefontcolor","replace","labelFontColor","labelfontcolor","labelFontBold","labelfontbold","labelFontItalic","labelfontitalic","plotBorderThickness","plotborderthickness","plotBorderColor","plotbordercolor","tooltipSeparationCharacter","tooltipsepchar","plotToolText","parseUnsafeString","plottooltext","parentLabelLineHeight","parentlabellineheight","labelGlow","labelglow","labelGlowIntensity","labelglowintensity","labelGlowColor","labelglowcolor","labelGlowRadius","labelglowradius","btnResetChartTooltext","btnresetcharttooltext","btnBackChartTooltext","btnbackcharttooltext","rangeOutBgColor","rangeoutbgcolor","rangeOutBgAlpha","rangeoutbgalpha","maxdepth","shownavigationbar","slicingMode","slicingmode","navigationBarHeight","navigationbarheight","navigationBarHeightRatio","navigationbarheightratio","navigationBarBorderColor","navigationbarbordercolor","navigationBarBorderThickness","navigationbarborderthickness","seperatorAngle","seperatorangle","PI","isConfigured","setState","createContainer","datasetGroup","datalabelGroup","trackerGroup","labelHighlightGroup","getLinkedParent","getChildContainer","getContainer","addContainer","defaultGroup","insertAfter","trackerElem","keys","pointObj","index","trackerConfigArray","trackerConfig","trackerObjPartition","node","meta","depth","push","_rolloverResponseSetter","elem","event","elData","getData","animationManager","getState","setAnimationState","setRolloverAttr","plotEventHandler","_getParentNode","nodePath","navigationBarNodes","nodePathLen","parent","self","isParentInNavBar","id","eventType","plotIndex","currentToolTip","setElement","plotItem","toolText","toolTipController","path","rectParent","polyPathItem","toFront","style","cursor","evtFns","hover","TRACKER_FILL","draw","hide","click","datasetLayer","drawTreeFn","shadeFilter","chartLevelAttr","chartConf","metaInf","rendererAPI","graphicPool","_graphicPool","drawingAreaCenterPoint","groupLabelCssProps","groupLabelCss","attrs","containerManager","removeNodeItemsObjectArr","parsexAxisStyles","fontFamily","fontSize","remove","css","colorRange","effectiveWidth","effectiveHeight","startX","startY","drawPolyPath","styleAttrs","pathElem","drawRect","_rect","overriddenAttrs","prop","beforeAnimationStateRect","overrideCss","visibility","props","__props","drawText","textVal","coordinates","_coordinates","overAttr","labelAttrs","highlightMask","mandatoryStyle","text","textAttrs","highlightsAttrs","highlightAttrs","fill","opacity","BLANKSTRING","outlineText","show","lineHeight","prevLabelGlowVisibility","newTextElem","newHighlightElem","disposeItems","disposeList","item","disposeNames","removed","disposeChild","parentNode","getParent","removeFn","currentNode","disposeSelectedChildren","disposeSelectedItems","addRemovalNodes","removeItems","hideNodes","itr","add","freeElement","dumpArr","splice","disposeComplimentary","targetNode","child","childrenArr","leftSiblingCount","getSiblingCount","removeLayers","_hotLayer","init","plotOnCanvas","applyShadeFiltering","addExtEventListener","d","start","maxMinArray","end","getType","setJSONIndex","getJSONIndex","ComponentInterface","canvasConfig","canvasYCentre","canvasHeight","canvasXCentre","canvasWidth","labelAnim","appearing","initialAttr","finalAttr","slot","updating","disappearing","pathAnim","inputJSON","plotAnim","prev","h","w","DRILLUP","afAPICreator","afAPI","iterator","visibleRoot","visibilityController","context","nextVisibileTreeRoot","restOfTheTreeArr","inProgress","attrVisible","AbstractTreeMaker","bucketIterationMode","cleansingFn","bucket","Bucket","get","orderFn","order","rec","root","level","pNewNode","children","newNode","key","notMetaKeys","TreeNode","svalue","addInBucket","setDepth","indexOf","setMeta","addChild","getBucket","getMaxDepth","setVisibleRoot","rootNode","controlOptions","it","exception","Iterable","iterAPI","initWith","df","nextNode","dfArr","isExhausted","next","fNode","shift","getDepth","reset","bf","bfArr","bfBatchArray","nextBatch","objContainer","C_","con","constructor","set","getInstance","_con","controlPreAnimVisibility","superNode","tempNode","dfItr","displayAll","controlPostAnimVisibility","textItem","dirtyNode","initConfigurationForlabel","padding","lineHeightVal","padX","padY","halfLineHeight","titleHideFlag","forcedLabel","availableHeight","isLeaf","textCalConf","rectShiftY","highlightAttr","getLabel","textRect","convertColor","fontcolor","normalizeColorCode","fontWeight","fontStyle","mapColorManager","isNavigationBar","parentColor","parentStyle","thisNodeColor","colorProp","cssConf","overriddenColor","fillcolor","nodeColorValue","getColorValue","isLegendEnabled","getColorByValue","isInRange","presentColor","rangeOutsideColor","strokeWidth","abstractEventRegisterer","algorithmAPI","dsStore","canvasMeasurement","backToParent","stateContext","resetTree","btns","drawTree","stateContextId","visibleState","plotClickEvt","plotRollOverEvt","plotRollOutEvt","dataUprootMap","colorValue","extractEventData","fillColor","fontColor","_intSR","raiseEventFlag","target","_t","_p","clickedState","fireChartInstanceEvent","withoutHead","virginNode","getVisibleRoot","drillUp","drillUpToTop","sender","fusionCharts","baseNode","eventName","thisVNode","onAnimationComplete","removeEventListener","addEventListener","mouseover","evtData","mouseout","setMaxDepth","algorithmFactoryCreator","algo","treeMaker","depthIncrement","postOrderTraversal","childNode","sumOfvalues","getValue","isNaN","areaBaseCalculator","sx","sy","posOffsetApplyFn","options","leftSibling","denominator","eHeight","eWidth","parentRect","negSpacesY","textMargin","getSibling","effectiveRect","effectiveArea","ratio","lastIsParent","bucketInstance","overrideEffect","rangeOutFn","setRangeOutEffect","resetPointers","limits","moveLowerShadePointer","moveHigherShadePointer","alternateModeManager","lastPoint","isDirectionVertical","dx","dy","childArea","lastRect","horizontalVerticalManager","isVerticalSlicing","Boolean","cNode","baseArea","getTextConf","_baseNode","csNode","drawRectFn","drawTextFn","drawHotFn","drawHot","xShift","yShift","smartLabel","getNextAreaBase","visController","localColorProvider","abstractEvtReg","clickEvtImpl","mouseoverEvtImpl","mouseoutEvtImpl","postNodeFetcher","useEllipsesOnOverflow","useEllipsesWhenOverflow","setStyle","_setStyle","drawingArea","_textRect","hotItem","labelItem","highlightItem","textConfObj","textConf","formattedValue","formattedsValue","colorDimension","yAxis","sYAxis","setPath","curr","getSmartText","parseTooltext","forcedTracker","targetElement","hoverContext","maskRgba","getLightColor","unmaskRgba","tooltip","callback","orderNodes","parseFloat","nodes","anyNode","layoutManager","RowLayout","totalValue","_rHeight","_rWidth","_rx","_ry","_rTotalArea","_prevAR","_hSegmented","addNode","nodeObj","area","snArea","snHeight","snWidth","_nextX","_nextY","remainingHeight","remainingWidth","aspectRatio","cRect","totalArea","_x","_y","valueSoFar","hRect","_hRect","isFinite","prevAR","pop","firstPassed","getNextLogicalDivision","bfItr","nextNodes","bfsQueue","bfsNode","totalValPlotted","__initRect","targetElementNew","row","nodeLimit","nextDiv","nodeIndex","queue","TreeMaker","orderNodeFn","makeTree","update","tempTree","plotTree","_args","modifier","api","treeOpt","algoName","flag","permitterDepth","shadeOutFN","setTreeBase","base","change","getNode","searchSibling","sibling","sanitized","str","trim","deleteData","setValue","oldValue","incremental","addChildren","containerManagerCreator","updateContainers","heightProportion","containers","drawNavigation","drawingAreaMeasurement","isStacked","navigationPath","offset","pathObj","segmentRect","pathText","allocatedWidth","startIndex","endIndex","segmentRectangle","pos","_width","resetAllocation","drawPathFn","navigationMapper","navigationHistory","clickFn","toolTipFn","navigationRatio","_heightProportion","navigationBar","_getVerticalPadding","navigationHeight","logicalFontSize","fontSizeStr","stacked","getPath","concat","setNavigationPath","createNavigationPath","getDrawFn","drawStackedNavigation","hasNavigationBar","singleLineRatio","treeMap","stackedNavigation","allocatedHeightProp","getDrawingArea","requiredHeightProp","round","Container","configuration","drawFn","setDrawingArea","containerConf","eventCallback","_temp","shape","_offset","centerHalfAngle","tan","_init","pathFetcher","_path","both","containersArr","visibleRootArr","containerElement","hex","MOTHER_OF_ALL_COLOR","_b","_css","rangeOurEffectApplyFn","stubFN","statePointerLow","statePointerHigh","targetIndex","val","minIndex","maxIndex","_i","_elemVal","abs","bucketElem","statePtr","stateIndex","stateVal","pointerAheadFlag","Number","NEGATIVE_INFINITY","rangeOutEffect","POSITIVE_INFINITY","getCSSconf","setParent","indexVal","side","counter","currentSibling","nSideStr","getMeta"],"mappings":"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","file":"fusioncharts.treemap.js","sourcesContent":["import Treemap from '../viz/treemap';\n\nexport { Treemap };\n\nexport default {\n  name: 'treemap',\n  type: 'package',\n  requiresFusionCharts: true,\n  extension: FusionCharts => FusionCharts.addDep(Treemap)\n};\n","import Treemap from '@fusioncharts/powercharts/src/chart/treemap';\nexport default Treemap;\n","/* eslint require-jsdoc: 'error', valid-jsdoc: [\"error\", { \"requireReturn\": false }] */\nimport CommonSpaceManager from '@fusioncharts/charts/src/chart/_internal/commonspacemanager';\nimport { priorityList } from '@fusioncharts/core/src/schedular';\nimport { getMouseCoordinate } from '@fusioncharts/core/src/lib';\nimport { Tool } from '@fusioncharts/core/src/toolbox';\nimport TreeMapDS from '../../dataset/treemap';\nimport _ref from './helper';\nimport { getDep } from '@fusioncharts/core/src/dependency-manager';\nimport datasetFactory from '@fusioncharts/charts/src/factories/singleseries-dataset';\nimport { _manageLegendSpace, manageGradientLegendSpace }\n  from '@fusioncharts/charts/src/chart/_internal/legend-spacemanager';\nimport legendItemFactory from '@fusioncharts/charts/src/factories/legend';\nimport createColorRangeManager from '@fusioncharts/charts/src/factories/colorrange';\nimport decideLegendCreation from '@fusioncharts/charts/src/factories/legendmanager';\nimport mousetrackerFactory from '@fusioncharts/charts/src/factories/mouse-tracker';\nimport raphaelShapesButton from '@fusioncharts/core/src/_internal/redraphael/redraphael-shapes/redraphael-shapes.button';\n\nlet Raphael = getDep('redraphael', 'plugin'),\n  // mathRound = Math.round,\n  MOUSEOUT = 'fc-mouseout',\n  UNDEF;\n  // TRACKER_FILL = 'rgba(255,0,0,' + (isIE ? 0.002 : 0.000001) + ')'; // invisible but clickable\n\n// Resolve dependency to draw button shape\nraphaelShapesButton(Raphael);\n\n// Icon drawing at toolbar. Back and reset button.\nRaphael.addSymbol({\n  backIcon: function (x, y, radius) {\n    var rad = radius - 1,\n      x1 = x, // eslint-disable-line good-practices/no-single-usage-variable\n      y1 = (y - rad), // eslint-disable-line good-practices/no-single-usage-variable\n\n      x2 = (x - rad), // eslint-disable-line good-practices/no-single-usage-variable\n      y2 = y, // eslint-disable-line good-practices/no-single-usage-variable\n\n      x3 = x,\n      y3 = (y + rad),\n\n      x4 = x3,\n      y4 = (y3 - (rad / 2)),\n\n      x5 = x4 + rad,\n      y5 = y4,\n\n      x6 = x5, // eslint-disable-line good-practices/no-single-usage-variable\n      y6 = y5 - rad, // eslint-disable-line good-practices/no-single-usage-variable\n\n      x7 = x5 - rad, // eslint-disable-line good-practices/no-single-usage-variable\n      y7 = y6; // eslint-disable-line good-practices/no-single-usage-variable\n\n    return [\n      'M',\n      x1, y1,\n      'L',\n      x2, y2,\n      x3, y3,\n      x4, y4,\n      x5, y5,\n      x6, y6,\n      x7, y7,\n      'Z'\n    ];\n  },\n\n  homeIcon: function (x, y, radius) {\n    var rad = radius - 1,\n      len = rad * 2,\n      x1 = x, // eslint-disable-line good-practices/no-single-usage-variable\n      y1 = (y - rad), // eslint-disable-line good-practices/no-single-usage-variable\n\n      x2 = (x - rad),\n      y2 = y,\n\n      x3 = (x2 + (len / 6)),\n      y3 = y2, // eslint-disable-line good-practices/no-single-usage-variable\n\n      x4 = x3,\n      y4 = (y + rad),\n\n      x5 = (x4 + (len / 4)),\n      y5 = y4,\n\n      x6 = x5,\n      y6 = (y5 - rad / 2),\n\n      x7 = (x6 + (len / 6)),\n      y7 = y6, // eslint-disable-line good-practices/no-single-usage-variable\n\n      x8 = x7, // eslint-disable-line good-practices/no-single-usage-variable\n      y8 = (y6 + rad / 2),\n\n      x9 = (x7 + (len / 4)),\n      y9 = y8,\n\n      x10 = x9, // eslint-disable-line good-practices/no-single-usage-variable\n      y10 = (y9 - rad),\n\n      x11 = (x9 + (len / 6)), // eslint-disable-line good-practices/no-single-usage-variable\n      y11 = y10; // eslint-disable-line good-practices/no-single-usage-variable\n\n    return [\n      'M',\n      x1, y1,\n      'L',\n      x2, y2,\n      x3, y3,\n      x4, y4,\n      x5, y5,\n      x6, y6,\n      x7, y7,\n      x8, y8,\n      x9, y9,\n      x10, y10,\n      x11, y11,\n      'Z'\n    ];\n  }\n});\n/**\n * chart API of treemap\n */\nclass TreeMap extends CommonSpaceManager {\n  /**\n   * Provides the name of the chart extension\n   *\n   * @static\n   * @return {string} The name of the chart extension\n   */\n  static getName () {\n    return 'TreeMap';\n  }\n\n  /**\n   * constructor function of this class\n   */\n  constructor () {\n    super();\n    this._lastAttached = {};\n    this.hasGradientLegend = true;\n    this.addToEnv('ref', _ref());\n    this.registerFactory('legend', legendItemFactory);\n    // decide and create legend after creating canvas\n    this.registerFactory('legend', decideLegendCreation, ['canvas']);\n\n    // create color manager after creating legend-decider\n    this.registerFactory('colormanager-decider', createColorRangeManager, ['legend']);\n    this.registerFactory('mouseTracker', mousetrackerFactory);\n    this.registerFactory('dataset', datasetFactory, ['vCanvas']);\n  }\n  /**\n   * Sets the name of the component\n   * @return {string} name\n   */\n  getName () {\n    return 'TreeMap';\n  }\n  /**\n   * parse defualt configuration of the chart\n   */\n  __setDefaultConfig () {\n    super.__setDefaultConfig();\n    this.config.enablemousetracking = true;\n    this.config.skipCanvasDrawing = true;\n    this.config.valuefontbold = 0;\n  }\n\n  /**\n   * Configures the chart component\n   * @param {Object} dataObj User input json\n   */\n  configureAttributes (dataObj) {\n    var iapi = this;\n    iapi.config.skipConfigureIteration = {};\n    iapi.config.valuesset = false;\n    iapi.parseChartAttr(dataObj);\n    iapi.createComponent(dataObj);\n\n    iapi.setTooltipStyle();\n    iapi.configureChildren();\n    // after configure chart calls its async draw\n  }\n  mouseoutHandler (e, _lastDatasetIndex, _lastPointIndex) {\n    let chart = this,\n      datasets = chart.config.datasetOrder || chart.getDatasets(), // eslint-disable-line good-practices/no-single-usage-variable\n      mouseTracker = chart.getChildren('mouseTracker')[0];\n    datasets[_lastDatasetIndex]._firePlotEvent(MOUSEOUT, _lastPointIndex, e);\n    // delete stored last ds details\n    delete mouseTracker._lastDatasetIndex;\n    delete mouseTracker._lastPointIndex;\n  }\n  /**\n   * This method delegates the handling of  mouse event to the chart's event handler\n   * @param  {Object} e The Event Object\n   * @param  {Object} data The data object\n   * @private\n   */\n  _mouseEvtHandler (e, data) {\n    let chart = this,\n      mouseTracker = data.mouseTracker,\n      oriEvent = e.originalEvent, // eslint-disable-line good-practices/no-single-usage-variable\n      chartConfig = chart.config,\n      canvasLeft = chartConfig.canvasLeft, // eslint-disable-line good-practices/no-single-usage-variable\n      canvasRight = chartConfig.canvasRight, // eslint-disable-line good-practices/no-single-usage-variable\n      canvasBottom = chartConfig.canvasBottom, // eslint-disable-line good-practices/no-single-usage-variable\n      canvasTop = chartConfig.canvasTop, // eslint-disable-line good-practices/no-single-usage-variable\n      datasets = chartConfig.datasetOrder || chart.getDatasets(),\n      coordinate = getMouseCoordinate(chart.getFromEnv('chart-container'), oriEvent, chart),\n      chartX = coordinate.chartX,\n      chartY = coordinate.chartY,\n      dataset,\n      hoveredInfo,\n      pointFound = false,\n      i = datasets.length,\n      j,\n      l,\n      derivedEvensInfo,\n      _lastDatasetIndex = mouseTracker._lastDatasetIndex,\n      _lastPointIndex = mouseTracker._lastPointIndex;\n    // @todo we have to implement this for charts with more than one canvas like candle stick\n\n    // if inside the canvas\n    if ((chartX > canvasLeft && chartX < canvasRight && chartY > canvasTop && chartY < canvasBottom) ||\n              chart.config.plotOverFlow) {\n      // @todo make sure the datasets are as per their z-order\n      while (i-- && !pointFound) {\n        dataset = datasets[i];\n        if (dataset) {\n          hoveredInfo = dataset._getHoveredPlot && dataset._getHoveredPlot(chartX, chartY);\n          if (hoveredInfo && hoveredInfo.hovered) {\n            pointFound = true;\n            hoveredInfo.datasetIndex = i;\n            derivedEvensInfo = mouseTracker.getMouseEvents(e, hoveredInfo.datasetIndex,\n              hoveredInfo.pointIndex);\n          }\n        }\n      }\n    }\n    // @todo instead of sending event names, create a event object of that type and send it\n\n    // fire out on last hovered plot\n    if ((!pointFound || (derivedEvensInfo && derivedEvensInfo.fireOut)) && _lastDatasetIndex !== UNDEF) {\n      if (datasets[_lastDatasetIndex] && datasets[_lastDatasetIndex]._firePlotEvent) {\n        // when mouseout is fired and there aren't any events that need to be fired over the current plot,\n        // call mouseouthandler through settimeout.\n        if (derivedEvensInfo && !derivedEvensInfo.events.length) {\n          mouseTracker.mouseoutTimer = setTimeout(function () {\n            chart.mouseoutHandler(e, _lastDatasetIndex, _lastPointIndex);\n          }, 20);\n        } else {\n          chart.mouseoutHandler(e, _lastDatasetIndex, _lastPointIndex);\n          clearTimeout(mouseTracker.mouseoutTimer);\n        }\n      }\n      // @todo scope to have sticky tracked tooltip\n    }\n    // fire remaining events\n    if (pointFound) {\n      l = derivedEvensInfo.events && derivedEvensInfo.events.length;\n      if (l) {\n        // store the index of the hovered DS and plot\n        mouseTracker._lastDatasetIndex = hoveredInfo.datasetIndex;\n        _lastPointIndex = mouseTracker._lastPointIndex = hoveredInfo.pointIndex;\n      }\n      for (j = 0; j < l; j += 1) {\n        dataset && dataset._firePlotEvent && dataset._firePlotEvent(derivedEvensInfo.events[j],\n          _lastPointIndex, e);\n      }\n    }\n  }\n  /**\n   * Checks whether the chart specific data is valid or not.\n   * @return {boolean} if JSON data is valid or not\n   */\n  _checkInvalidSpecificData () {\n    let jsonData = this.getFromEnv('dataSource'); // eslint-disable-line good-practices/no-single-usage-variable\n    if (!jsonData.data) {\n      return true;\n    }\n  }\n  /**\n    * Remove a node from the specified path.\n    * tree {Object} - A subtree or even a single node\n    * path {Array} - Specify the position of the node to be removed wrt the root node for the tree. The last\n    * value in path here denotes the insertion point of the tree. Elements insertion orders have a visual effect on\n    * the slice and dice algorithims.\n    * draw {Boolean} - A flag when set to false, will not update the visual after the removal.\n    */\n  addData () {\n    var ref = this.getFromEnv('ref'), // eslint-disable-line good-practices/no-single-usage-variable\n      algorithmFactory = ref.algorithmFactory, // eslint-disable-line good-practices/no-single-usage-variable\n      args = Array.prototype.slice.call(arguments, 0);\n    args.unshift('addData');\n    // attaching the data cleaning function for applying number formatting\n    args.unshift(this._getCleanValue());\n    algorithmFactory.realTimeUpdate.apply(this, args);\n  }\n  /**\n    * Remove a node from the specified path.\n    * path {Array} - Specify the position of the node to be removed wrt the root node for the tree.\n    * draw {Boolean} - A flag when set to false, will not update the visual after the removal.\n    */\n  removeData () {\n    var ref = this.getFromEnv('ref'), // eslint-disable-line good-practices/no-single-usage-variable\n      algorithmFactory = ref.algorithmFactory, // eslint-disable-line good-practices/no-single-usage-variable\n      args = Array.prototype.slice.call(arguments, 0);\n    args.unshift('deleteData');\n    // attaching the data cleaning function for applying number formatting\n    args.unshift(this._getCleanValue());\n    algorithmFactory.realTimeUpdate.apply(this, args);\n  }\n  /**\n   * to trigger kd tree partitioning\n   */\n  triggerKDTreePartioning () {\n    var dataset = this.getDatasets()[0];\n    dataset.addJob('partitioning', dataset.kdTreePartioning.bind(dataset), priorityList.tracker);\n  }\n  /**\n   * to reset css property of tracker element\n   */\n  resetSingleTracker () {\n    var dataset = this.getDatasets()[0],\n      singleTracker = dataset && dataset.graphics && dataset.graphics.singleTracker;\n    singleTracker && singleTracker.attr({\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      stroke: 'rgba(255,255,255,0)',\n      'fill-opacity': 0\n    });\n  }\n  /**\n   * function to calculate and allote space for legend\n   */\n  _manageLegendSpace () {\n    _manageLegendSpace.call(this);\n  }\n  /**\n * function to calculate and allote space for gradient legend\n * @param {number} allottedSpace alloted space for gradient legend\n * @return {Object} calculated dimension\n */\n  manageGradientLegendSpace (allottedSpace) {\n    return manageGradientLegendSpace.call(this, allottedSpace);\n  }\n  /**\n   * to flush out kdTree\n   */\n  flushKDTree () {\n    var dataset = this.getDatasets()[0]; // eslint-disable-line good-practices/no-single-usage-variable\n    dataset.kdTree = {};\n  }\n  /**\n   * Create a toolbox with a context menu.\n   * Add context menus for export and print options if enabled.\n   * Create the chart Menu bar as a chart component.\n   */\n  attachMenuButtons () {\n    super.attachMenuButtons();\n    let chart = this,\n      config = chart.config,\n      toolBar,\n      toolBarType = config.toolbarVAlign === 't' ? 'chartMenuBar' : 'actionBar',\n      toolConf = chart.getFromEnv('tool-config');\n    toolBar = chart.getChildren(toolBarType)[0];\n    for (let i = 0; i < 2; i++) {\n      toolBar.attachChild(Tool, 'tool', `${i === 0 ? 'home' : 'back'}-${toolBar.getId()}-${chart.getId()}`);\n    }\n\n    toolBar.getChild(`back-${toolBar.getId()}-${chart.getId()}`).configure(Object.assign({},\n      toolConf, {\n        name: 'backIcon',\n        isHidden: true\n      }));\n    toolBar.getChild(`home-${toolBar.getId()}-${chart.getId()}`).configure(Object.assign({},\n      toolConf, {\n        name: 'homeIcon',\n        isHidden: true\n      }));\n\n    chart.addToEnv('toolbarBtns', {\n      back: toolBar.getChild(`back-${toolBar.getId()}-${chart.getId()}`),\n      home: toolBar.getChild(`home-${toolBar.getId()}-${chart.getId()}`)\n    });\n  }\n  /**\n    * return a valid value as per the input [either number or null]\n    * @return {Function} Returning the number formatted value.\n    */\n  _getCleanValue () {\n    let numberFormatter = this.getFromEnv('number-formatter'); // eslint-disable-line good-practices/no-single-usage-variable\n    // storing the reference for number formatter for future use.\n    return function (value) {\n      return numberFormatter.getCleanValue(value);\n    };\n  }\n  /**\n   * This method return the dataset definations for this charts\n   * @return {Object}       TreeMap dataset definition\n   */\n  getDSdef () {\n    return TreeMapDS;\n  }\n}\nexport default TreeMap;\n","/* eslint require-jsdoc: 'error', valid-jsdoc: [\"error\", { \"requireReturn\": false }] */\nimport { ComponentInterface } from '@fusioncharts/core/src/component-interface';\nimport { priorityList } from '@fusioncharts/core/src/schedular';\nimport { pluck, pluckNumber, parsexAxisStyles, extend2 as fcExtend, BLANKSTRING,\n  preDefStr, parseUnsafeString, TRACKER_FILL } from '@fusioncharts/core/src/lib';\nimport { addDep } from '@fusioncharts/core/src/dependency-manager';\nimport treeMapAnimation from './index.animation';\n\nvar UNDEF,\n  HIDDEN = 'hidden',\n  DEFAULT_CURSOR = preDefStr.DEFAULT,\n  POINTER = 'pointer',\n  MOUSEOVER = 'mouseOver',\n  ROLLOVER = 'DataPlotRollOver',\n  HIDDEN_STR = 'hidden',\n  ROUND_STR = 'round',\n  /**\n   * Helper function to create a RedRaphael group.\n   * @param  {string} groupName                Name of the group to be created.\n   * @param  {Element} parentContainer         The parent container in which the group will be appended.\n   * @param {Object} dataset The concerned dataset\n   * @return {Element}                         The group that was created.\n   */\n  createGroup = function (groupName, parentContainer, dataset) {\n    return dataset.getFromEnv('animationManager').setAnimation({\n      el: 'group',\n      attr: { name: groupName },\n      container: parentContainer,\n      state: 'appearing',\n      component: dataset,\n      doNotRemove: true,\n      label: 'group'\n    });\n  },\n  // Check a point is in range w.r.t\n  // to given range\n\n  inRange = function (a, r1, r2) {\n    return a >= r1 && a <= r2;\n  },\n  swap = function (arr, i, j) {\n    var tmp = arr[i]; // eslint-disable-line good-practices/no-single-usage-variable\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  },\n  /* eslint-disable require-jsdoc */\n  kdTreeAbs = function (arrVal) {\n    'use strict';\n    // Max radius will be tolerance\n    var arr = arrVal,\n      tolerance = (arr && arr[0] && arr[0].plotDetails.rect) || 5,\n      i,\n      max = Math.max,\n      floor = Math.floor,\n      sqrt = Math.sqrt,\n      min = Math.min,\n      log = Math.log,\n      exp = Math.exp,\n      pow = Math.pow,\n      result = {}; // eslint-disable-line good-practices/no-single-usage-variable\n    arr = arr || [];\n    // Find tolerance as the max radius\n    // of the element\n    for (i = arr.length; i--;) {\n      if (arr[i].r > tolerance) {\n        tolerance = arr[i].r;\n      }\n      // Setting the index\n      arr[i].x = +arr[i].plotDetails.rect.x;\n      arr[i].y = +arr[i].plotDetails.rect.y;\n    }\n    // KdTree Definition below\n\n    function buildKdTree (arr, leftVal, rightVal, isY) { // eslint-disable-line\n      var ob = {},\n        mid,\n        left = leftVal,\n        right = rightVal,\n        access = isY ? 'y' : 'x';\n      if (left === right) {\n        ob.point = arr[left];\n        return ob;\n      }\n      if (right - left === 1) {\n        if (arr[left][access] > arr[right][access]) {\n          ob.point = arr[left];\n          ob.left = {\n            point: arr[right]\n          };\n        } else {\n          ob.point = arr[right];\n          ob.left = {\n            point: arr[left]\n          };\n        }\n        return ob;\n      }\n\n      mid = (left + right) >> 1;\n\n      if (isY) {\n        quickselectY(arr, mid, left, right);\n      } else {\n        quickselectX(arr, mid, left, right);\n      }\n\n      ob.point = arr[mid];\n      ob.left = buildKdTree(arr, left, mid - 1, !isY);\n      ob.right = buildKdTree(arr, mid + 1, right, !isY);\n      return ob;\n    }\n\n    function quickselectX (arr, k, leftVal, rightVal) {  // eslint-disable-line\n      var left = leftVal,\n        right = rightVal,\n        n, m, z, s, sd, newLeft, newRight, t, i, j;  // eslint-disable-line\n\n      while (right > left) {\n        if (right - left > 600) {\n          n = right - left + 1;\n          m = k - left + 1;\n          z = log(n);\n          s = 0.5 * exp(2 * z / 3);\n          sd = 0.5 * sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n          newLeft = max(left, floor(k - m * s / n + sd));\n          newRight = min(right, floor(k + (n - m) * s / n + sd));\n          quickselectX(arr, k, newLeft, newRight);\n        }\n\n        t = arr[k];\n        i = left;\n        j = right;\n\n        swap(arr, left, k);\n        if (arr[right].x > t.x) {\n          swap(arr, left, right);\n        }\n\n        while (i < j) {\n          swap(arr, i, j);\n          i++;\n          j--;\n          while (arr[i].x < t.x) {\n            i++;\n          }\n          while (arr[j].x > t.x) {\n            j--;\n          }\n        }\n\n        if (arr[left].x === t.x) {\n          swap(arr, left, j);\n        } else {\n          j++;\n          swap(arr, j, right);\n        }\n\n        if (j <= k) {\n          left = j + 1;\n        }\n        if (k <= j) {\n          right = j - 1;\n        }\n      }\n    }\n\n    function quickselectY (arr, k, leftVal, rightVal) {  // eslint-disable-line\n      var left = leftVal,\n        right = rightVal,\n        n,\n        m,\n        z,\n        s,\n        sd,\n        newLeft,\n        newRight,\n        t,\n        i, // eslint-disable-line\n        j;\n\n      while (right > left) {\n        if (right - left > 600) {\n          n = right - left + 1;\n          m = k - left + 1;\n          z = log(n);\n          s = 0.5 * exp(2 * z / 3);\n          sd = 0.5 * sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n          newLeft = max(left, floor(k - m * s / n + sd));\n          newRight = min(right, floor(k + (n - m) * s / n + sd));\n          quickselectY(arr, k, newLeft, newRight);\n        }\n\n        t = arr[k];\n        i = left;\n        j = right;\n\n        swap(arr, left, k);\n        if (arr[right].y > t.y) {\n          swap(arr, left, right);\n        }\n\n        while (i < j) {\n          swap(arr, i, j);\n          i++;\n          j--;\n          while (arr[i].y < t.y) {\n            i++;\n          }\n          while (arr[j].y > t.y) {\n            j--;\n          }\n        }\n\n        if (arr[left].y === t.y) {\n          swap(arr, left, j);\n        } else {\n          j++;\n          swap(arr, j, right);\n        }\n\n        if (j <= k) {\n          left = j + 1;\n        }\n        if (k <= j) {\n          right = j - 1;\n        }\n      }\n    }\n    result = { // eslint-disable-line good-practices/no-single-usage-variable\n      tree: buildKdTree(arr, 0, arr.length - 1, false),\n      search: function (x, y) {\n        // Helper function for search\n        // to apply data if found\n        // eslint-disable-next-line\n        function apply (ob) {\n          var currentHovered = inRange(x, ob.x1, ob.x2) && inRange(y, ob.y1, ob.y2),\n            currentDist = calcDist(x, y, ob.point.x, ob.point.y);\n          if (!res) {\n            res = ob;\n            lastHovered = currentHovered;\n            lastDist = currentDist;\n            return;\n          }\n          if (currentHovered) {\n            if (lastHovered) {\n              if (ob.point.i > res.point.i) {\n                res = ob;\n                lastHovered = currentHovered;\n                lastDist = currentDist;\n              }\n            } else {\n              res = ob;\n              lastHovered = currentHovered;\n              lastDist = currentDist;\n            }\n          } else {\n            if (!lastHovered) {\n              if (currentDist < lastDist) {\n                res = ob;\n                lastHovered = currentHovered;\n                lastDist = currentDist;\n              }\n            }\n          }\n        }\n        // Calculate  distance between two points\n        // eslint-disable-next-line\n        function calcDist (x, y, p, q) {\n          return sqrt(pow(x - p, 2) + pow(y - q, 2));\n        }\n        // X and Y searching different for\n        // maintaing performance\n        function searchX (ob) {\n          // Not found\n          if (!ob || !ob.point) {\n            return;\n          }\n          // If match found return\n          if (inRange(ob.point.x, x1, x2) && inRange(ob.point.y, y1, y2)) {\n            apply(ob);\n          }\n          // If smaller x1 go left\n          if (x1 <= ob.point.x) {\n            searchY(ob.left);\n          }\n          // If bigger x2 goto right\n          if (x2 >= ob.point.x) {\n            searchY(ob.right);\n          }\n        }\n        function searchY (ob) {\n          // Not found\n          if (!ob || !ob.point) {\n            return;\n          }\n          // If match found return\n          if (inRange(ob.point.x, x1, x2) && inRange(ob.point.y, y1, y2)) {\n            apply(ob);\n          }\n          // If smaller x1 go left\n          if (y1 <= ob.point.y) {\n            searchX(ob.left);\n          }\n          // If bigger x2 goto right\n          if (y2 >= ob.point.y) {\n            searchX(ob.right);\n          }\n        }\n        // Actual search logic\n        var tree = this.tree, // eslint-disable-line good-practices/no-single-usage-variable\n          res,\n          x1 = x - tolerance,\n          x2 = x + tolerance,\n          y1 = y - tolerance,\n          y2 = y + tolerance,\n          lastHovered = false,\n          lastDist = 0; // eslint-disable-line good-practices/no-single-usage-variable\n        searchX(tree);\n        // Return point otherwise undefined value\n        return (res && res.point) || res;\n      },\n      // eslint-disable-next-line good-practices/no-function-dependency\n      searchTreemap: function (x, y) {\n        var res,\n          // Higher index will be the result\n          apply = function (ob) {\n            if (!res) {\n              res = ob;\n              return;\n            }\n            if (ob.i > res.i) {\n              res = ob;\n            }\n          },\n          search = function (ob, isY) {\n            // Not found\n            if (!ob || !ob.point) {\n              return;\n            }\n            var x1 = ob.point.x,\n              x2 = x1 + ob.point.plotDetails.rect.width,\n              y1 = ob.point.y,\n              y2 = y1 + ob.point.plotDetails.rect.height;\n            ob.point.x2 = x2;\n            ob.point.y2 = y2;\n\n            // Found\n            if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {\n              apply(ob.point);\n            }\n\n            search(ob.left, !isY);\n            search(ob.right, !isY);\n          };\n        search(this.tree, false);\n        return res;\n      }\n    }; // ------\n    // eslint-disable-next-line good-practices/no-function-dependency\n    arr.sort(function (a, b) {\n      return a.i - b.i;\n    });\n    return result;\n  };\n/* eslint-enable require-jsdoc */\naddDep({\n  name: 'treeMapAnimation',\n  type: 'animationRule',\n  extension: treeMapAnimation\n});\n/**\n * Dataset for treemap\n */\nclass TreeMapDS extends ComponentInterface {\n  /**\n   * constructor fn\n   */\n  constructor () {\n    super();\n    var datasetDefStore = this;\n    // Stub for saving all the child component\n    datasetDefStore.components = { };\n    // Stub for saving all the computed configuration\n    datasetDefStore.conf = { };\n    // Stub for saving all the graphics component\n    datasetDefStore.graphics = {\n      elemStore: {\n        rect: [],\n        label: [],\n        highlight: [],\n        hot: [],\n        polypath: []\n      }\n    };\n  }\n  /**\n   * Sets the name of the component\n   * @return {string} name\n   */\n  getName () {\n    return 'treeMap';\n  }\n  /**\n    * Function for parsing all the attributes and value given by the user at chart,dataset and set level.\n    * This function is called once from the init() function of the Column class.\n    * @param  {Object} datasetJSON JSON for dataset configurations\n    */\n  configureAttributes (datasetJSON) {\n    if (!datasetJSON) {\n      return;\n    }\n    this.config.JSONData = datasetJSON.data[0];\n    let algorithm,\n      maxDepth,\n      showNavigationBar,\n      datasetDefStore = this,\n      chart = datasetDefStore.getFromEnv('chart'), // eslint-disable-line good-practices/no-single-usage-variable\n      dsConf = datasetDefStore.conf,\n      rawChartAttr = chart.getFromEnv('chart-attrib');\n\n    dsConf.metaTreeInf = {};\n\n    algorithm = rawChartAttr.algorithm || 'squarified'; // eslint-disable-line good-practices/no-single-usage-variable\n    dsConf.algorithm = algorithm.toLowerCase();\n    dsConf.range = UNDEF;\n\n    // horizontalPadding and verticalPadding is the separation space between parent drawing area\n    // and child drawing area\n    dsConf.horizontalPadding = pluckNumber(rawChartAttr.horizontalpadding, 5);\n    dsConf.horizontalPadding = (dsConf.horizontalPadding < 0) ? 0 : dsConf.horizontalPadding;\n    dsConf.verticalPadding = pluckNumber(rawChartAttr.verticalpadding, 5);\n    dsConf.verticalPadding = (dsConf.verticalPadding < 0) ? 0 : dsConf.verticalPadding;\n\n    // Hides the node which are not leaf nodes by using all the available spaces.\n    // This attribute including horizontalPadding and verticalPadding is used to display only the child nodes\n    dsConf.showParent = pluckNumber(rawChartAttr.showparent, 1);\n    dsConf.showChildLabels = pluckNumber(rawChartAttr.showchildlabels, 0);\n\n    dsConf.showHoverEffect = pluckNumber(rawChartAttr.showhovereffect, 1);\n\n    // Hovers on all the leaf nodes which belong to a particular parent. Disbales single leaf hovering\n    dsConf.highlightParentsOnHover = pluckNumber(rawChartAttr.highlightparentsonhover, 0);\n\n    // Background color of nodes which are not leaf nodes. The leaf nodes color is managed by\n    // the colorRangeManager\n    dsConf.defaultParentBGColor = pluck(rawChartAttr.defaultparentbgcolor, UNDEF);\n    dsConf.defaultNavigationBarBGColor = pluck(rawChartAttr.defaultnavigationbarbgcolor,\n      dsConf.defaultParentBGColor);\n\n    dsConf.showTooltip = pluckNumber(rawChartAttr.showtooltip, 1);\n    // Font cosmetics\n    dsConf.baseFontSize = pluckNumber(rawChartAttr.basefontsize, 10);\n    dsConf.baseFontSize = (dsConf.baseFontSize < 1) ? 1 : dsConf.baseFontSize;\n    dsConf.labelFontSize = pluckNumber(this.computeFontSize(rawChartAttr.labelfontsize), UNDEF);\n    dsConf.labelFontSize = (dsConf.labelFontSize < 1) ? 1 : dsConf.labelFontSize;\n    dsConf.baseFont = pluck(rawChartAttr.basefont, 'Verdana, Sans');\n    dsConf.labelFont = pluck(rawChartAttr.labelfont, UNDEF);\n    dsConf.showTextOutline = pluckNumber(rawChartAttr.textoutline, 0);\n    dsConf.baseFontColor = pluck(rawChartAttr.basefontcolor, '#000000').replace(/^#?([a-f0-9]+)/ig, '#$1');\n    dsConf.labelFontColor = pluck(rawChartAttr.labelfontcolor, UNDEF);\n    dsConf.labelFontColor &&\n          (dsConf.labelFontColor = dsConf.labelFontColor.replace(/^#?([a-f0-9]+)/ig, '#$1'));\n    dsConf.labelFontBold = pluckNumber(rawChartAttr.labelfontbold, 0);\n    dsConf.labelFontItalic = pluckNumber(rawChartAttr.labelfontitalic, 0);\n\n    // Border cosmetics\n    dsConf.plotBorderThickness = pluckNumber(rawChartAttr.plotborderthickness, 1);\n    dsConf.plotBorderThickness = (dsConf.plotBorderThickness < 0) ? 0\n      : (dsConf.plotBorderThickness > 5) ? 5 : dsConf.plotBorderThickness;\n    dsConf.plotBorderColor = pluck(rawChartAttr.plotbordercolor, '#000000')\n      .replace(/^#?([a-f0-9]+)/ig, '#$1');\n\n    // Extended tooltip support\n    dsConf.tooltipSeparationCharacter = pluck(rawChartAttr.tooltipsepchar, ',');\n    dsConf.plotToolText = parseUnsafeString(pluck(rawChartAttr.plottooltext, ''), false);\n\n    // Parent label line height configuration\n    dsConf.parentLabelLineHeight = pluckNumber(rawChartAttr.parentlabellineheight, 12);\n    dsConf.parentLabelLineHeight = (dsConf.parentLabelLineHeight < 0) ? 0\n      : dsConf.parentLabelLineHeight;\n\n    // Label glow is required since if the user choose a background that is as same as the color of the label,\n    // the glow is required to work as a layer between text and background that will make the label stand out\n    // Note: label glow will not be applied if textOutline is enabled\n    dsConf.labelGlow = dsConf.showTextOutline ? 0 : pluckNumber(rawChartAttr.labelglow, 1);\n    dsConf.labelGlowIntensity = pluckNumber(rawChartAttr.labelglowintensity, 100) / 100;\n    dsConf.labelGlowIntensity = ((dsConf.labelGlowIntensity < 0) ? 0\n      : (dsConf.labelGlowIntensity > 1) ? 1 : dsConf.labelGlowIntensity);\n    dsConf.labelGlowColor = pluck(rawChartAttr.labelglowcolor, '#ffffff')\n      .replace(/^#?([a-f0-9]+)/ig, '#$1');\n    dsConf.labelGlowRadius = pluckNumber(rawChartAttr.labelglowradius, 2);\n    dsConf.labelGlowRadius = (dsConf.labelGlowRadius < 0) ? 0\n      : (dsConf.labelGlowRadius > 10) ? 10 : dsConf.labelGlowRadius;\n\n    // Tool bar configuration\n    dsConf.btnResetChartTooltext = pluck(rawChartAttr.btnresetcharttooltext, 'Back to Top');\n    dsConf.btnBackChartTooltext = pluck(rawChartAttr.btnbackcharttooltext, 'Back to Parent');\n\n    // Legend Effects Configuration\n    dsConf.rangeOutBgColor = pluck(rawChartAttr.rangeoutbgcolor, '#808080')\n      .replace(/^#?([a-f0-9]+)/ig, '#$1');\n    dsConf.rangeOutBgAlpha = pluckNumber(rawChartAttr.rangeoutbgalpha, 100);\n    dsConf.rangeOutBgAlpha = ((dsConf.rangeOutBgAlpha < 1) || (dsConf.rangeOutBgAlpha > 100))\n      ? 100 : dsConf.rangeOutBgAlpha;\n\n    // maximum levels to display in the tree at a time.\n    maxDepth = pluckNumber(rawChartAttr.maxdepth);\n    dsConf.maxDepth = (maxDepth !== UNDEF) ? Math.max(maxDepth, 1) : UNDEF;\n\n    showNavigationBar = dsConf.showNavigationBar = pluckNumber(rawChartAttr.shownavigationbar, 1); // eslint-disable-line good-practices/no-single-usage-variable\n    dsConf.slicingMode = pluck(rawChartAttr.slicingmode, 'alternate');\n    dsConf.navigationBarHeight = pluckNumber(rawChartAttr.navigationbarheight);\n    dsConf.navigationBarHeightRatio = pluckNumber(rawChartAttr.navigationbarheightratio);\n    dsConf.navigationBarBorderColor = pluck(rawChartAttr.navigationbarbordercolor, dsConf.plotBorderColor)\n      .replace(/^#?([a-f0-9]+)/ig, '#$1');\n    dsConf.navigationBarBorderThickness = showNavigationBar ? pluckNumber(\n      rawChartAttr.navigationbarborderthickness, dsConf.plotBorderThickness) : 0;\n    dsConf.seperatorAngle = pluckNumber(rawChartAttr.seperatorangle) * (Math.PI / 180);\n\n    dsConf.isConfigured = true;\n    datasetDefStore.setState('dirty', true);\n  }\n  /**\n   * function to create group for dataset\n   */\n  createContainer () {\n    var dataset = this,\n      datasetGroup,\n      datalabelGroup,\n      trackerGroup,\n      labelHighlightGroup,\n      parentContainer = dataset.getLinkedParent().getChildContainer();\n\n    datasetGroup = dataset.getContainer('plots') || // eslint-disable-line good-practices/no-single-usage-variable\n      dataset.addContainer('plots', createGroup('plots', parentContainer.defaultGroup, dataset));\n    datalabelGroup = dataset.getContainer('datalabels') || dataset.addContainer('datalabels',\n      createGroup('datalabels', parentContainer.defaultGroup, dataset).insertAfter(datasetGroup));\n\n    trackerGroup = dataset.getContainer('tracker') || dataset.addContainer('tracker', // eslint-disable-line good-practices/no-single-usage-variable\n      createGroup('tracker', parentContainer.defaultGroup, dataset));\n\n    !dataset.getContainer('line-hot') && dataset.addContainer('line-hot', createGroup('line-hot', trackerGroup, dataset));\n\n    labelHighlightGroup = dataset.getContainer('labelhighlight') || // eslint-disable-line good-practices/no-single-usage-variable\n      dataset.addContainer('labelhighlight', createGroup('labelhighlight', datalabelGroup, dataset));\n\n    !dataset.getContainer('labelfloat') &&\n      dataset.addContainer('labelfloat', createGroup('labelfloat', datalabelGroup, dataset).insertAfter(labelHighlightGroup));\n  }\n  /**\n   * Function that retunr the nearest plot details\n   * @param {number} chartX x-axis position of the mouse cordinate\n   * @param {number} chartY x-axis position of the mouse cordinate\n   * @return {Object} return an object with details of nearest polt and whether it is hovered or not\n   */\n  _getHoveredPlot (chartX, chartY) {\n    var dataset = this,\n      trackerElem,\n      m,\n      keys;\n\n    keys = Object.keys(dataset.config.kdTree || {});\n    for (m = keys.length - 1; m > -1; m--) {\n      if ((dataset.config.kdTree[keys[m]].searchTreemap(chartX, chartY))) {\n        trackerElem = (dataset.config.kdTree[keys[m]].searchTreemap(chartX, chartY));\n        break;\n      }\n    }\n\n    if (trackerElem) {\n      dataset.pointObj = trackerElem;\n      return {\n        pointIndex: trackerElem.i || trackerElem.index,\n        hovered: true,\n        pointObj: trackerElem\n      };\n    }\n  }\n  // eslint-disable-next-line\n  kdTreePartioning () {\n    var dataset = this,\n      trackerConfigArray = dataset.getFromEnv('chartConfig').trackerConfig,\n      m,\n      keys,\n      trackerObjPartition = {};\n\n    for (m = trackerConfigArray.length; m--;) {\n      trackerConfigArray[m].i = m;\n      if (trackerObjPartition[trackerConfigArray[m].node.meta.depth] === UNDEF) {\n        trackerObjPartition[trackerConfigArray[m].node.meta.depth] = [];\n      }\n      trackerObjPartition[trackerConfigArray[m].node.meta.depth].push(trackerConfigArray[m]);\n    }\n    dataset.config.kdTree = {};\n    keys = Object.keys(trackerObjPartition);\n    for (m = keys.length - 1; m > -1; m--) {\n      dataset.config.kdTree[keys[m]] = kdTreeAbs && kdTreeAbs(trackerObjPartition[keys[m]]);\n    }\n  }\n  /**\n   * function to handle hover in effect on element\n   * @param {Object} elem    graphics element\n   * @param {Object} event   original event reference\n   * @param {Component} dataset - dataset component\n   */\n  _rolloverResponseSetter (elem, event, dataset) {\n    var elData = elem.getData(),\n      animationManager = dataset.getFromEnv('animationManager'),\n      chart = this.getFromEnv('chart');\n    // Check whether the plot is in dragged state or not if\n    // drag then dont fire rolloverevent\n    if (elData && (elData.showHoverEffect !== 0)) {\n      // when drill animation is occuring, then rollover effect must be disabled\n      if (!chart.getState('drill')) {\n        animationManager.setAnimationState(MOUSEOVER);\n        animationManager.setAnimation({\n          el: elem,\n          label: 'rect',\n          component: dataset,\n          attr: elem.getData().setRolloverAttr\n        });\n      }\n      chart.plotEventHandler(elem, event, ROLLOVER);\n    }\n  }\n  /**\n   * Returns parent of the hovered node. When the parent node is in navigation bar, hovered node is returned\n   *\n   * @param {any} [nodePath=[]] list of nodes from root to currently hovered node\n   * @returns {boolean | Object} if drill depth is less than 2, false is returned. Else corresponding parent is returned\n   * @memberof TreeMapDS\n   */\n  _getParentNode (nodePath = []) {\n    let navigationBarNodes = this.conf.navigationBarNodes || [],\n      i,\n      len = navigationBarNodes.length, // eslint-disable-line good-practices/no-single-usage-variable\n      nodePathLen = nodePath.length,\n      parent = nodePath[nodePathLen - 2],\n      self = nodePath[nodePathLen - 1], // eslint-disable-line good-practices/no-single-usage-variable\n      isParentInNavBar = false; // eslint-disable-line good-practices/no-single-usage-variable\n\n    if (nodePathLen < 2) {\n      return false;\n    }\n    for (i = 0; i < len; i++) {\n      if (navigationBarNodes[i].id === parent.id) {\n        isParentInNavBar = true;\n        break;\n      }\n    }\n    return isParentInNavBar ? self : parent;\n  }\n  /**\n   * This method handles all mouse events of an dataset.\n   * @param {string} eventType    name of the event\n   * @param {number} plotIndex    index of the plot where this event has been occured\n   * @param {Event}  e            reference of the original mouse event\n   */\n  _firePlotEvent (eventType, plotIndex, e) {\n    var dataset = this,\n      currentToolTip = dataset.config.currentToolTip,\n      data = dataset.getFromEnv('chartConfig').trackerConfig[plotIndex || 0],\n      setElement = data && data.node && data.node.plotItem,\n      toolText = data && data.plotDetails && data.plotDetails.toolText,\n      toolTipController = dataset.getFromEnv('toolTipController'),\n      originalEvent = e.originalEvent,\n      singleTracker = dataset.graphics.singleTracker,\n      plotDetails = dataset.pointObj.plotDetails,\n      attr,\n      parent = dataset._getParentNode(data && data.node.path),\n      rectParent = parent && parent.rect;\n    if (!setElement) {\n      setElement = data && (data.node.plotItem || data.node.polyPathItem);\n      plotDetails = {};\n      plotDetails.rect = {};\n    } else if (dataset.conf.highlightParentsOnHover && parent) {\n      attr = {\n        x: rectParent.x,\n        y: rectParent.y,\n        width: rectParent.width,\n        height: rectParent.height,\n        stroke: 'rgba(255,255,255,0)'\n      };\n    } else {\n      attr = {\n        x: plotDetails.rect.x || 0,\n        y: plotDetails.rect.y || 0,\n        width: plotDetails.rect.width || 0,\n        height: plotDetails.rect.height || 0,\n        stroke: 'rgba(255,255,255,0)'\n      };\n    }\n    singleTracker = dataset.graphics.singleTracker = dataset.getFromEnv('animationManager').setAnimation({\n      el: dataset.graphics.singleTracker || 'rect',\n      attr: attr,\n      component: dataset,\n      label: 'tracker',\n      container: dataset.getContainer('tracker'),\n      doNotRemove: true\n    }).toFront();\n    if (setElement) {\n      setElement.node.style.cursor = POINTER;\n      singleTracker.node.style.cursor = POINTER;\n      switch (eventType) {\n        case 'fc-mouseover' :\n          if (dataset.conf.showHoverEffect) {\n            data.evtFns.hover[0](singleTracker);\n          } else {\n            // added tracker fill to update the cosmetics when hover effect is not required\n            // but it is necessary to show pointer in text as well so tracker is not removed\n            // but updated\n            singleTracker.attr('fill', TRACKER_FILL);\n          }\n\n          if (toolText) {\n            if (currentToolTip) {\n              toolTipController.draw(originalEvent, toolText, currentToolTip);\n            } else {\n              currentToolTip = dataset.config.currentToolTip =\n                toolTipController.draw(originalEvent, toolText);\n            }\n          }\n          // dataset._rolloverResponseSetter(setElement, originalEvent);\n          break;\n        case 'fc-mouseout' :\n          setElement.node.style.cursor = DEFAULT_CURSOR;\n          singleTracker.node.style.cursor = POINTER;\n          singleTracker.attr({\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n            stroke: '#ffffff',\n            'stroke-width': '0px'\n          });\n          singleTracker.toFront();\n          toolTipController.hide(currentToolTip);\n          data.evtFns.hover[1](singleTracker);\n          break;\n        case 'fc-click' :\n          // plotEventHandler.call(setElement, chart, originalEvent);\n          // style.cursor = POINTER;\n          data && data.evtFns && data.evtFns.click && data.evtFns.click[0]();\n          dataset.config.kdTree = {};\n\n          // @todo - get the schedular and add the job\n          dataset.addJob('click', dataset.kdTreePartioning.bind(dataset), priorityList.tracker);\n          break;\n        case 'fc-mousemove' :\n          // style.cursor = POINTER;\n          if (toolText) {\n            if (currentToolTip) {\n              toolTipController.draw(originalEvent, toolText, currentToolTip);\n            } else {\n              currentToolTip = dataset.config.currentToolTip = toolTipController.draw(originalEvent, toolText);\n            }\n          }\n      }\n    }\n  }\n  /**\n   * function to handle drawing job of treemap dataset\n   */\n  draw () {\n    var datasetDefStore = this,\n      dsConf = datasetDefStore.conf,\n      chart = datasetDefStore.getFromEnv('chart'),\n      // jobList = chart.getJobList(),\n      chartConf = datasetDefStore.getFromEnv('chartConfig'),\n      trackerConfig = chartConf.trackerConfig,\n      canvasLeft = chartConf.canvasLeft,\n      canvasTop = chartConf.canvasTop,\n      datasetLayer,\n      metaInf = dsConf.metaTreeInf,\n      elemStore = datasetDefStore.graphics.elemStore,\n      rendererAPI = {},\n      graphicPool = dsConf._graphicPool || (dsConf._graphicPool = {}),\n      drawingAreaCenterPoint = {},\n      groupLabelCssProps = ['fontFamily', 'fontSize', 'fontWeight', 'fontStyle'],\n      groupLabelCss = { cursor: POINTER }, // for cursor on the top group labels text\n      // groupLabelCss = {},\n      nodeRect,\n      tree,\n      attrs = dsConf,\n      // legend = datasetDefStore.getFromEnv('gLegend'),\n      drawTreeFn,\n      shadeFilter,\n      ref = this.getFromEnv('ref'),\n      // afAPI = ref.afAPI,\n      // visController = afAPI.visibilityController,\n      index,\n      length,\n      animationManager = datasetDefStore.getFromEnv('animationManager'),\n      containerManager = ref.containerManager,\n      chartLevelAttr,\n      algorithmFactory = ref.algorithmFactory,\n      // object to store the nodes which needs to be removed\n      removeNodeItemsObjectArr = {},\n      attr;\n\n    trackerConfig && (trackerConfig.length = 0);\n    datasetDefStore.createContainer();\n\n    chartLevelAttr = parsexAxisStyles.apply(this, [{}, {},\n      datasetDefStore.getFromEnv('chart-attrib'),\n      { fontFamily: 'Verdana,sans', fontSize: '10px' }]);\n\n    // Extract the required css from the list of css (guard for IE)\n    for (index = 0, length = groupLabelCssProps.length; index < length; index++) {\n      attr = groupLabelCssProps[index];\n\n      if (attr in chartLevelAttr) {\n        groupLabelCss[attr] = chartLevelAttr[attr];\n      }\n    }\n\n    // transport all the previously drawn elements to graphic pool.(graphics reusability)\n    containerManager.remove();\n\n    datasetLayer = datasetDefStore.getContainer('plots');\n\n    datasetDefStore.getContainer('datalabels').css(groupLabelCss);\n\n    // lineHotLayer = datasetDefStore.getContainer('line-hot');\n\n    dsConf.colorRange = datasetDefStore.getFromEnv('colorManager');\n\n    // Measurement for available drawing area\n    metaInf.effectiveWidth = chartConf.canvasRight - canvasLeft;\n    metaInf.effectiveHeight = chartConf.canvasBottom - canvasTop;\n    metaInf.startX = canvasLeft;\n    metaInf.startY = canvasTop;\n\n    // Starting point of animation. Animation starts from the center of the paper.\n    drawingAreaCenterPoint.x = metaInf.effectiveWidth / 2;\n    drawingAreaCenterPoint.y = metaInf.effectiveHeight / 2;\n\n    // Starting point of animation. Animation starts from the center of the paper.\n    drawingAreaCenterPoint.x = metaInf.effectiveWidth / 2;\n    drawingAreaCenterPoint.y = metaInf.effectiveHeight / 2;\n\n    /**\n      * A function to draw a polygon of specific path and style configuration\n      * @param {Object}  config - configuration of node\n      * @param {Object} styleAttrs - The style object needed to be applied on the polygon element.\n      * @param {TreeNode}  node   - single treenode\n      * @return {graphicsElement} - newly created or reused graphics path element\n      */\n    rendererAPI.drawPolyPath = function (config, styleAttrs, node) {\n      var pathElem;\n      // the current node should not be removed, so deleting it from the removeNodeItemsObjectArr object\n      removeNodeItemsObjectArr[node.id] && (delete removeNodeItemsObjectArr[node.id]);\n      // look up for dumped 'polypathItem' inside the garbage pool or create a new path.\n      pathElem = animationManager.setAnimation({\n        el: rendererAPI.graphicPool(false, 'polyPathItem') || 'path',\n        container: datasetLayer,\n        attr: { path: config.path },\n        css: styleAttrs,\n        state: chart.getState('drill') ? 'updating' : 'appearing',\n        label: 'path',\n        component: datasetDefStore\n      });\n\n      pathElem && elemStore.polypath.push(pathElem);\n\n      // return the polygon path element.\n      return pathElem;\n    };\n    // eslint-disable-next-line\n    rendererAPI.drawRect = function (rect, styleAttrs, _rect, overriddenAttrs, node) {\n      var prop,\n        pVal,\n        beforeAnimationStateRect = {},\n        overrideCss = {},\n        // clicked = (chart.getState('state') === 'click'),\n        // accordianTrue = (chart.getState('state') === 'initial') || (chart.getState('state') === 'update'),\n        // resize = (chart.getState('state') === 'resize'),\n        newElem;\n      // the current node should not be removed, so deleting it from the removeNodeItemsObjectArr object\n      removeNodeItemsObjectArr[node.id] && (delete removeNodeItemsObjectArr[node.id]);\n\n      for (prop in rect) {\n        pVal = rect[prop];\n        if (pVal < 0) {\n          // If value of any rect proerty is negative, give it zero pixel, so it become invisible\n          rect[prop] = 0;\n          // Explicit visibility hidden required for IE8\n          overrideCss.visibility = HIDDEN_STR;\n        }\n      }\n      // If animation is applied. For animation to happen we need a 'from state' and a 'to state'.\n      // During the time duration the transition happens 'from state'  to 'to states'.\n\n      fcExtend(beforeAnimationStateRect, rect);\n\n      // From state measurement of the animation\n      beforeAnimationStateRect.x = drawingAreaCenterPoint.x;\n      beforeAnimationStateRect.y = drawingAreaCenterPoint.y;\n      beforeAnimationStateRect.height = 0;\n      beforeAnimationStateRect.width = 0;\n      nodeRect = animationManager.setAnimation({ // eslint-disable-line good-practices/no-single-usage-variable\n        el: rendererAPI.graphicPool(false, 'plotItem') || 'rect',\n        container: datasetLayer,\n        attr: rect,\n        css: Object.assign(styleAttrs, overrideCss),\n        state: chart.getState('drill') ? 'updating' : 'appearing',\n        props: node.__props,\n        label: 'rect',\n        component: datasetDefStore\n      }).toFront();\n      // Store the reference, so that we canus retrieve it later.\n      // todo: remove...\n      newElem && elemStore.rect.push(newElem);\n\n      return nodeRect;\n    };\n\n    /*\n      * Draw a text on the paper. This texts are drawn under datalabel layer.\n      * @param textVal {String} - text to be drawn on paper\n      * @param coordinates {Object} - Start co ordinate of the text. In {x: 10, y: 10} format\n      * @return {Element} - the element which is drawn on paper\n      */\n    // eslint-disable-next-line\n    rendererAPI.drawText = function (textVal, coordinates, attrs, _coordinates, overAttr = {}, node) {\n      // previously _coordinates is used 'from state' to 'to state' animation\n      var mandatoryStyle = {},\n        newTextElem,\n        text = textVal,\n        newHighlightElem,\n        state,\n        label,\n        labelAttrs,\n        highlightMask,\n        visibility,\n        textAttrs = attrs.textAttrs,\n        highlightsAttrs = attrs.highlightAttrs;\n      state = chart.getState('drill') ? 'updating' : 'appearing';\n      // the current node should not be removed, so deleting it from the removeNodeItemsObjectArr object\n      removeNodeItemsObjectArr[node.id] && (delete removeNodeItemsObjectArr[node.id]);\n      // There are two layers of datalabel placement happens here. The 1st layer from the top is the\n      // real text. And below this is the text that brings the highlight effect. This effect is acheived\n      // by making the strong-width bigger.\n\n      fcExtend(mandatoryStyle, textAttrs);\n\n      delete mandatoryStyle.fill;\n      mandatoryStyle['stroke-linejoin'] = ROUND_STR;\n      delete overAttr.opacity;\n      // If the coordinates are negative valued, texts are made BLANK.\n      text = (coordinates.x < 0 || coordinates.y < 0) ? BLANKSTRING : text;\n      labelAttrs = Object.assign({}, textAttrs, overAttr, {\n        text: text,\n        x: coordinates.x,\n        y: coordinates.y,\n        visibility: 'visible'\n      });\n      label = animationManager.setAnimation({\n        el: rendererAPI.graphicPool(false, 'labelItem') ||\n          rendererAPI.graphicPool(false, 'pathlabelItem') || 'text',\n        container: datasetDefStore.getContainer('labelfloat'),\n        component: datasetDefStore,\n        attr: labelAttrs,\n        state: state,\n        label: 'labelItem'\n      });\n      label.outlineText(datasetDefStore.conf.showTextOutline, labelAttrs.fill);\n      label.show();\n\n      visibility = highlightsAttrs.visibility !== HIDDEN;\n      delete highlightsAttrs.visibility;\n      highlightMask = animationManager.setAnimation({\n        el: rendererAPI.graphicPool(false, 'highlightItem') ||\n          rendererAPI.graphicPool(false, 'pathhighlightItem') || 'text',\n        container: datasetDefStore.getContainer('labelhighlight'),\n        component: datasetDefStore,\n        attr: Object.assign({}, overAttr, highlightsAttrs, {\n          x: coordinates.x,\n          y: coordinates.y,\n          text: visibility ? text : '',\n          visibility: 'visible'\n        }),\n        css: { lineHeight: mandatoryStyle.fontSize * 1.2 + 'px' },\n        state: state,\n        label: 'highlightItem'\n      });\n      (datasetDefStore.prevLabelGlowVisibility !== visibility) && (visibility === true) && highlightMask.show();\n      datasetDefStore.prevLabelGlowVisibility = visibility;\n      // Store the reference in the array\n      elemStore.label.push(newTextElem);\n      elemStore.highlight.push(newHighlightElem);\n\n      return {\n        label: label,\n        highlightMask: highlightMask\n      };\n    };\n\n    /*\n      * Dispose the graphic elements related to a node element.\n      * @param node - {TreeNode} - The node element reference wrt whom the graphic elements needs to be detached.\n      * @param disposeList - {Array} - The  disposing graphics elements names which are to be only removed.\n    */\n    rendererAPI.disposeItems = function (node, disposeList) {\n      var i,\n        item,\n        prop,\n        disposeNames = disposeList || ['plotItem', 'labelItem', 'hotItem', 'highlightItem', 'polyPathItem',\n          'pathlabelItem', 'pathhighlightItem', 'stackedpolyPathItem', 'stackedpathlabelItem',\n          'stackedpathhighlightItem'];\n\n      for (i = 0; i < disposeNames.length; i += 1) {\n        prop = disposeNames[i];\n        item = node[prop];\n        // push these elements in the graphic pool for reusing in future.\n        item && (item.type === 'text') && item.attr({\n          text: '',\n          'text-bound': []\n        });\n        item && !item.removed && (item = animationManager.setAnimation({\n          el: item,\n          component: datasetDefStore\n        }));\n        // hide the elements.\n        // detach the node and the graphic element linkage.\n        node[prop] = UNDEF;\n      }\n    };\n\n    /*\n      * Recursively destroy all childs of the tree node.\n    */\n    rendererAPI.disposeChild = (function () {\n      var rendererAPI, // eslint-disable-line\n        disposeItems = function () {\n          return rendererAPI.disposeItems;\n        },\n        removeFn = function (currentNode, depth) {\n          var index, // eslint-disable-line\n            childrenArr;\n\n          // dispose the graphics elements for the element.\n          disposeItems(currentNode);\n          // todo: put it in closure\n          for (index = 0; index < (currentNode.getChildren() || []).length; index++) {\n            childrenArr = currentNode.getChildren();\n            index = removeFn(childrenArr[index], index);\n          }\n          return depth;\n        };\n      return function (node) {\n        var parentNode = node.getParent();\n        if (!rendererAPI) {\n          rendererAPI = this;\n          disposeItems = disposeItems();\n        }\n        // check if its not the global origin\n        if (parentNode) {\n          rendererAPI.disposeChild(parentNode);\n        } else {\n          /* dispose the graphics elements, if any. Store it for future re-use and unlink its reference\n          from the node element */\n          removeFn(node, 0);\n        }\n      };\n    })();\n\n    /**\n     * Utility function to dispose child nodes\n     */\n    rendererAPI.disposeSelectedChildren = (function () {\n      var rendererAPI, // eslint-disable-line\n        disposeSelectedItems = function () {\n          return rendererAPI.addRemovalNodes;\n        },\n        removeItems = function (currentNode, depth) {\n          var index, // eslint-disable-line\n            childrenArr;\n\n          disposeSelectedItems(currentNode);\n\n          for (index = 0; index < (currentNode.getChildren() || []).length; ++index) {\n            childrenArr = currentNode.getChildren();\n            index = removeItems(childrenArr[index], index);\n          }\n          return depth;\n        };\n\n      return function (node) {\n        var parentNode = node.getParent();\n        if (!rendererAPI) {\n          rendererAPI = this;\n          disposeSelectedItems = disposeSelectedItems();\n        }\n        if (parentNode) {\n          rendererAPI.addRemovalNodes(parentNode);\n        } else {\n          removeItems(node, 0);\n        }\n      };\n    })();\n    /**\n     * Function to add a particular node to removeNodeItemsObjectArr\n     * @param {Object} node - The tree-node\n     */\n    rendererAPI.addRemovalNodes = function (node) {\n      removeNodeItemsObjectArr[node.id] = node;\n    };\n\n    /**\n     * Function to animate and hide the graphical elements of node present in removeNodeItemsObjectArr\n     */\n    rendererAPI.hideNodes = function () {\n      var i,\n        item,\n        node,\n        prop,\n        disposeNames = ['plotItem', 'labelItem', 'hotItem', 'highlightItem', 'polyPathItem',\n          'pathlabelItem', 'pathhighlightItem', 'stackedpolyPathItem', 'stackedpathlabelItem',\n          'stackedpathhighlightItem'];\n      for (let itr in removeNodeItemsObjectArr) {\n        node = removeNodeItemsObjectArr[itr];\n        for (i = 0; i < disposeNames.length; i += 1) {\n          prop = disposeNames[i];\n          item = node[prop];\n\n          item && (item.type === 'text') && item.attr({\n            text: '',\n            'text-bound': []\n          });\n          item = item && !item.removed && animationManager.setAnimation({\n            el: item,\n            component: datasetDefStore,\n            label: 'gen'\n          });\n          // detach the node and the graphic element linkage.\n          node[prop] = UNDEF;\n        }\n      }\n    };\n    /**\n     * store or fetch an element of the type.\n     * param add {boolean} - If to add the element or fetch an element.\n     * param type {'string'} - If a hot element, rectangle, texts...\n     * param elem {svg element}\n     */\n    rendererAPI.graphicPool = (function () {\n      // eslint-disable-next-line good-practices/no-function-dependency\n      return function (add, type, elem) {\n        var freeElement,\n          dumpArr = graphicPool[type];\n        // create a storage array for the specified type if not existing.\n        if (!dumpArr) {\n          dumpArr = graphicPool[type] = [];\n        }\n        if (type === 'hotItem' || type === 'pathhotItem') {\n          elem.remove();\n        }\n        // adds the elemnt to the graphics pool\n        if (add) {\n          dumpArr.push(elem);\n        } else {\n          // fectches an element from the pool and remove that from the free pool.\n          // slice out the first element from the array of free elements.\n          freeElement = dumpArr.splice(0, 1)[0];\n          if (freeElement) {\n            freeElement.show();\n            return freeElement;\n          }\n        }\n      };\n    })();\n\n    // dispose the complimentary tree.\n    // eslint-disable-next-line good-practices/no-function-dependency\n    rendererAPI.disposeComplimentary = function (targetNode) {\n      var child,\n        childrenArr,\n        rendererAPI = this, // eslint-disable-line\n        parentNode = targetNode.getParent(),\n        leftSiblingCount = targetNode.getSiblingCount('left');\n      if (parentNode) {\n        childrenArr = parentNode.getChildren();\n        // set parent node to undefined, to break the parent-child links.\n        child = childrenArr.splice(leftSiblingCount, 1)[0];\n        // generically dispose the discontinous tree.\n        rendererAPI.disposeChild(targetNode);\n        // re-eastablish the broken parent-child relationships for the node.\n        childrenArr.splice(leftSiblingCount, 0, child);\n      }\n      // bridge code: Cannot dispose hotItems.\n      rendererAPI.removeLayers();\n    };\n\n    /**\n      * Remove everything that has been drawn in the layers. It doesnot remove the layer directly.\n      * Instead it removes the children. All the children of datasetLayer, datalabelLayer, hotLayer\n      * are removed\n      */\n    rendererAPI.removeLayers = function () {\n      var index, // eslint-disable-line\n        length, // eslint-disable-line\n        /* dataset,\n        datalabel,\n        highlight, */\n        hot,\n        /* _datasetLayer,\n        _datalabelLayer,\n        _highlightLayer, */\n        _hotLayer;\n        /* datasetLayerLength,\n        datalabelLayerLength,\n        highlightLayerLength, */\n\n      /* _datasetLayer = elemStore.rect, datasetLayerLength = _datasetLayer.length;\n        _datalabelLayer = elemStore.label, datalabelLayerLength = _datalabelLayer.length;\n        _highlightLayer = elemStore.highlight, highlightLayerLength = _highlightLayer.length; */\n      _hotLayer = elemStore.hot;\n\n      // Get the length of maximum element inside among three layers\n      // length = Math.max(datasetLayerLength, datalabelLayerLength, highlightLayerLength, hotLayerLength);\n      length = _hotLayer.length; // eslint-disable-line good-practices/no-single-usage-variable\n\n      for (index = 0; index < length; index++) {\n        /* dataset = _datasetLayer[index];\n        datalabel = _datalabelLayer[index];\n        highlight = _highlightLayer[index]; */\n        hot = _hotLayer[index];\n\n        // Remove the element from DOM\n        /* dataset && dataset.remove();\n        datalabel && datalabel.remove();\n        highlight && highlight.remove(); */\n        hot && hot.remove();\n      }\n\n      // Empty the arry which was holding the reference\n      /* _datasetLayer.length = 0;\n      _datalabelLayer.length = 0; */\n      _hotLayer.length = 0;\n    };\n\n    if (datasetDefStore.getState('dirty')) {\n      algorithmFactory.init(dsConf.algorithm, true, dsConf.maxDepth);\n      // Retrieves draw function of algorithm\n      drawTreeFn = algorithmFactory.plotOnCanvas(datasetDefStore.config.JSONData, chart._getCleanValue());\n      // initialise the container manager.\n      containerManager.init(datasetDefStore, metaInf, rendererAPI, tree, drawTreeFn);\n    }\n    // draw the indivual containers inside the container manager.\n    containerManager.draw();\n\n    shadeFilter = algorithmFactory.applyShadeFiltering({ // eslint-disable-line good-practices/no-single-usage-variable\n      fill: attrs.rangeOutBgColor,\n      opacity: (attrs.rangeOutBgAlpha * 0.01)\n    }, function (css) { // eslint-disable-line good-practices/no-function-dependency\n      var nodeInf = this;\n      nodeInf.plotItem && nodeInf.plotItem.css(css);\n    });\n\n    // if (legend && legend.enabled) {\n    //   legend.resetLegend();\n    //   // legend.clearListeners();\n    // }\n    // listen to event fired by legends and decide what to do\n    // eslint-disable-next-line\n    datasetDefStore.addExtEventListener('legendUpdate', function (e, d) {\n      shadeFilter.call(this, {\n        start: d.maxMinArray[0].min,\n        end: d.maxMinArray[0].max\n      });\n      dsConf.range = {\n        min: d.maxMinArray[0].min,\n        max: d.maxMinArray[0].max\n      };\n    }, datasetDefStore.getFromEnv('colorManager'));\n\n    dsConf.isConfigured = false;\n    // add the job to build kd tree\n    datasetDefStore.addJob('buildKDTreeID', datasetDefStore.kdTreePartioning.bind(datasetDefStore),\n      priorityList.tracker);\n  }\n  /**\n   * Returns the type of the component\n   * @return {string} The type of the component, in this case a dataset.\n   */\n  getType () {\n    return 'dataset';\n  }\n  /**\n   * function to set index for the dataset component\n   * @param {number} index    index according to the index JSON\n   */\n  setJSONIndex (index) {\n    this.config.index = index;\n  }\n\n  /**\n   * function to return index for the dataset component\n   * @return {number}    index according to the index JSON\n   */\n  getJSONIndex () {\n    return this.config.index || 0;\n  }\n}\nexport default TreeMapDS;\n","export default {\n  '*.dataset.treeMap': function () {\n    let dataset = this,\n      canvasConfig = dataset.getFromEnv('canvasConfig'),\n      canvasYCentre = canvasConfig.canvasLeft + canvasConfig.canvasHeight / 2,\n      canvasXCentre = canvasConfig.canvasWidth / 2 + canvasConfig.canvasTop,\n      labelAnim = {\n        appearing: [{\n          initialAttr: {\n            opacity: 0\n          },\n          finalAttr: {\n            opacity: 1\n          },\n          slot: 'final'\n        }],\n        updating: [{\n          initialAttr: {\n            opacity: 0\n          },\n          finalAttr: {\n            opacity: 1\n          },\n          slot: 'final'\n        }],\n        disappearing: [{\n          initialAttr: {\n            opacity: 1\n          },\n          finalAttr: {\n            opacity: 0\n          },\n          slot: 'initial'\n        }]\n      },\n      pathAnim = {\n        appearing: [{\n          initialAttr: {\n            opacity: 0\n          },\n          finalAttr: {\n            opacity: 1\n          },\n          slot: 'final'\n        }],\n        updating: (inputJSON) => {\n          let elPresent = typeof inputJSON.el !== 'string';\n          return [{\n            initialAttr: {\n              opacity: 0,\n              path: elPresent ? inputJSON.el.attr('path') : inputJSON.attr.path\n            },\n            finalAttr: {\n              opacity: 1,\n              path: inputJSON.attr.path\n            },\n            slot: 'final'\n          }];\n        }\n      },\n      plotAnim = {\n        appearing: () => {\n          return [{\n            initialAttr: {\n              x: canvasXCentre,\n              y: canvasYCentre,\n              width: 0,\n              height: 0,\n              opacity: 0\n            },\n            finalAttr: {\n              opacity: 1\n            },\n            slot: 'plot'\n          }];\n        },\n        disappearing: [{\n          finalAttr: {\n            opacity: 0\n          },\n          slot: 'initial'\n        }],\n        updating: (inputJSON) => {\n          let x = inputJSON.props.prev && inputJSON.props.prev.x === inputJSON.attr.x,\n            y = inputJSON.props.prev && inputJSON.props.prev.y === inputJSON.attr.y,\n            h = inputJSON.props.prev && inputJSON.props.prev.height === inputJSON.attr.height,\n            w = inputJSON.props.prev && inputJSON.props.prev.width === inputJSON.attr.width;\n\n          if (x && y && h && w) {\n            return [{\n              initialAttr: {\n                opacity: 0\n              },\n              finalAttr: {\n                opacity: 1\n              },\n              slot: 'final'\n            }];\n          }\n          if (inputJSON.props.prev) {\n            return [{\n              initialAttr: {\n                x: inputJSON.props.prev.x,\n                y: inputJSON.props.prev.y,\n                width: inputJSON.props.prev.width,\n                height: inputJSON.props.prev.height\n              },\n              slot: 'plot'\n            }];\n          }\n          return [{\n            initialAttr: {\n              x: inputJSON.attr.x,\n              y: inputJSON.attr.y,\n              width: inputJSON.attr.width,\n              height: inputJSON.attr.height\n            },\n            slot: 'plot'\n          }];\n        }\n      };\n\n    return {\n      'rect.appearing': plotAnim.appearing,\n      'rect.updating': plotAnim.updating,\n      'rect.disappearing': plotAnim.disappearing,\n      'path.appearing': pathAnim.appearing,\n      'path.updating': pathAnim.updating,\n      'path.disappearing': plotAnim.disappearing,\n      'labelItem.appearing': labelAnim.appearing,\n      'labelItem.updating': labelAnim.updating,\n      'labelItem.disappearing': labelAnim.disappearing,\n      'highlightItem.appearing': labelAnim.appearing,\n      'highlightItem.updating': labelAnim.updating,\n      'highlightItem.disappearing': labelAnim.disappearing,\n      'gen.disappearing': labelAnim.disappearing,\n      '*': null\n    };\n  }\n};\n","/* eslint require-jsdoc: 'error', valid-jsdoc: [\"error\", { \"requireReturn\": false }] */\nimport { pluckNumber, stubFN, convertColor, getLightColor,\n  BLANKSTRING, parseTooltext, parseUnsafeString } from '@fusioncharts/core/src/lib';\nimport { priorityList } from '@fusioncharts/core/src/schedular';\nlet UNDEF,\n  DRILLUP = 'drillup',\n  HIDDEN_STR = 'hidden',\n  VISIBLE_STR = 'visible',\n  NONE = 'none',\n  CLICK_STR = 'click',\n  CLICKEDSTATE = 'ClickedState',\n  VISIBLEROOT = 'VisibileRoot',\n  DATAPLOTCLICK = 'dataplotclick',\n  DATAPLOTROLLOVER = 'dataplotrollover',\n  DATAPLOTROLLOUT = 'dataplotrollout',\n  HOVER = 'hover',\n  DRILLDOWN = 'drilldown',\n  BOTH = 'both',\n  LEFT = 'left',\n  NO = 'no',\n  RIGHT = 'right',\n  STACKED_STR = 'stacked',\n  id = 1,\n  afAPICreator = function (afAPI, containerManager) {\n    var iterator,\n      maxDepth,\n      visibleRoot,\n      visibilityController,\n      context;\n\n    /**\n      * AbstractTreeMaker is kind of an abstract class that converts fusioncharts configuration to tree.\n      * This can directly be used and initialized  if no ordering is required. If any particular ordering\n      * is needed, it is the subclass needs to implement order function.\n      */\n    class AbstractTreeMaker {\n      /**\n       * constructor\n       * @param {Object}   node                 root node of the configuration. This would be root of the returned tree as well\n       * @param {boolean}  bucketIterationMode  whether bucket is needed or not\n       * @param {Function} cleansingFn          cleansing fn\n       */\n      constructor (node, bucketIterationMode, cleansingFn) {\n        this.node = node;\n        this.bucket = bucketIterationMode ? new Bucket() : UNDEF;\n        this.cleansingFn = cleansingFn;\n      }\n      /**\n        * Create the tree from configuration.\n        * @return {TreeNode} - newly created tree\n        */\n      get () {\n        var orderFn = this.order,\n          bucket = this.bucket,\n          cleansingFn = this.cleansingFn;\n\n        /**\n          * Recursively prepare the tree from the configuration.\n          * @param {number}   level    - The depth of the current root element.\n          * @param {TreeNode} root     - The current base root in the full tree trversal.\n          */\n        return (function rec (root, level) {\n          var pNewNode,\n            index,\n            children,\n            childNode,\n            newNode,\n            notMetaKeys = ['label', 'value', 'data', 'svalue'], // eslint-disable-line good-practices/no-single-usage-variable\n            key;\n\n          if (root) {\n            // If root node is present add in the existing tree.\n            // This also acts as a break condition of recursion.\n            pNewNode = new TreeNode(parseUnsafeString(root.label), cleansingFn(root.value), cleansingFn(root.svalue));\n            children = root.data || [];\n            if (children.length === 0 && bucket) {\n              bucket.addInBucket(pNewNode);\n            }\n            // sets the depth information in the 'meta' object for the Tree node element.\n            pNewNode.setDepth(level);\n            // Support for set label attributes. All the set label attributes are stored in meta object.\n            for (key in root) {\n              // label, value and data is non-meta attribute\n              if (notMetaKeys.indexOf(key) !== -1) {\n                continue;\n              }\n              pNewNode.setMeta(key, root[key]);\n            }\n          }\n\n          if (orderFn) {\n            // For ordered treemaps. If the subclass give implementation of orderFn\n            children = orderFn(children);\n          }\n\n          for (index = 0; index < children.length; index++) {\n            childNode = children[index];\n            // Recursively iterate to complete the tree along with the incremental level information.\n            newNode = rec(childNode, level + 1);\n            pNewNode.addChild(newNode);\n          }\n\n          return pNewNode;\n        })(this.node, 0); // The depth for the initial global node remains '0'.\n      }\n\n      /**\n        * Get the  bucket formation created by ordering and grouping the leaf nodes. This can be accessed if the\n        * legend is enabled.\n        * @return {Bucket} - The bucket of leaf nodes\n        */\n      getBucket () {\n        return this.bucket;\n      }\n      /**\n       * return maximum level of tree\n       * @return {number} maximum level of tree\n       */\n      static getMaxDepth () {\n        return maxDepth;\n      }\n    }\n    /**\n     * set maximum level of tree\n     * @param {number} value maximum level of tree\n     * @return {number} maximum level of tree\n     */\n    function setMaxDepth (value) {\n      return (maxDepth = value);\n    }\n\n    /**\n      * Iterates through the tree. This provides two basic traversal of tree. This iteration happens on-demand.\n      * Hence faster.\n      * 1. Breath-first\n      * 2. depth-first\n      * @param  {TreeNode} rootNode       - Root node from where the traversal to be started\n      * @param  {Object}   controlOptions -\n      * @return {Object}                  - Object containg standard API for breadth-first-traversal  and depth-first-traversal\n      */\n    iterator = function (rootNode, controlOptions) {\n      var it = {},\n        exception = controlOptions && controlOptions.exception,\n        df,\n        bf;\n\n      /**\n        * Provides control to implement iterator in case the user wants have more than one iterator\n        * without waiting for the one to get exhausted.\n        */\n      class Iterable {\n        /**\n         * constructor\n         * @param {Object}  iterAPI - Iteration APIs [bf or df]\n         */\n        constructor (iterAPI) {\n          this.iterAPI = iterAPI;\n        }\n\n        /**\n         * Initialize all the traversing algorithm.\n         * @param {TreeNode}  rootNode - node from where iteration will initiated\n         * @return {Object}          - new DF or BF algorithm\n         */\n        initWith (rootNode) { // eslint-disable-line\n          return this.iterAPI(rootNode);\n        }\n      }\n      /*\n        * Depth first (df) iteration API.\n        * This exposes two functions\n        * next() - gives the next df node. If all nodes are iterated, the pointer is exhausted,\n        * it returns undefined\n        * reset() - reset the whole system to the initial state\n        * Here the iteration happens without saving the states separately. It is on demand. Means,\n        * the moment next is called, the callee node and immediate the children are only allocated.\n        *\n        * If there is a tree like this\n        * A -|\n        *    |--- B --|\n        *    |        | --- B1\n        *    |        | --- B2\n        *    |\n        *    |--- C --|\n        *    |        | --- C1\n        *    |        | --- C2\n        *    |        | --- C3\n        *    |\n        *    |--- D\n        *\n        * It creates array like the following\n        * init -  | A |\n        * next() - | B | C | D | and returns A\n        * next() - | B1 | B2 | C | D | and returns B (because B has children we place the children in front)\n        * next() - | B2 | C | D | and returns B1 (because B1 doesn't have children, we just returns it)\n        * reset() - | A |\n        */\n      it.df = function (node) {\n        var nextNode = node,\n          dfArr = [],\n          next,\n          reset,\n          isExhausted = false; // eslint-disable-line good-practices/no-single-usage-variable\n\n        // initial stage, start with the root node\n        dfArr.push(nextNode);\n\n        /*\n          * Apply depth first and returns the next node\n          * @param maxDepth{Number | undefined} - If there is a hardcoded maxDepth specified, beyond that depth\n            of the tree,its children information is not fetched.\n          * @return {TreeNode | undefined} - if the complete tree is iterated returns undefined\n          */\n        next = function (maxDepth) { // eslint-disable-line\n          var children,\n            fNode,\n            len;\n\n          if (isExhausted) {\n            // tree iteration complete, return undefined\n            return;\n          }\n\n          // returns the front node of the array\n          fNode = dfArr.shift();\n\n          if (exception && fNode === exception) {\n            fNode = dfArr.shift();\n\n            if (!fNode) {\n              isExhausted = true;\n              return;\n            }\n          }\n\n          // If maxdepth is defined, no children information is fetched for the node.\n          children = (maxDepth !== UNDEF) ? ((fNode.getDepth() >= maxDepth) ? [] : fNode.getChildren())\n            : fNode.getChildren();\n          len = (children && children.length) || 0; // eslint-disable-line good-practices/no-single-usage-variable\n\n          if (len) {\n            // place the children at the front of the array\n            [].unshift.apply(dfArr, children);\n          }\n\n          if (dfArr.length === 0) {\n            // Sets the exhaustion flag if the array is empty so that during the next iteration\n            // the iterator returns undefined\n            isExhausted = true;\n          }\n\n          return fNode;\n        };\n\n        /*\n          * Reset the state of the iterator. Every iterator instance needs to reset its state\n          * once it is done traversing. The caller will be responsible for this call.\n          */\n        reset = function () {\n          // Go back to initial state\n          isExhausted = false;\n          nextNode = node; // eslint-disable-line good-practices/no-single-usage-variable\n          dfArr.length = 0;\n          dfArr.push(nextNode);\n        };\n\n        return {\n          next: next,\n          reset: reset\n        };\n      };\n\n      /*\n        * Breadth first (bf) iteration API.\n        * This exposes two functions\n        * next() - gives the next df node. If all nodes are iterated, the pointer is exhausted,\n        * it returns undefined\n        * reset() - reset the whole system to the initial state\n        * Here the iteration happens without saving the states separately. It is on demand. Means,\n        * the moment next is called, the callee node and immediate the children are only allocated.\n        *\n        * If there is a tree like this\n        * A -|\n        *    |--- B --|\n        *    |        | --- B1\n        *    |        | --- B2\n        *    |\n        *    |--- C --|\n        *    |        | --- C1\n        *    |        | --- C2\n        *    |        | --- C3\n        *    |\n        *    | --- D\n        *\n        * It creates array like the following\n        * init -  | A |\n        * next() - | B | C | D | and returns A\n        * next() - | C | D | B1 | B2 | and returns B (because B has children we place the children in last)\n        * next() - | D | B1 | B2 | C1 | C2 | C3 | and returns C (because C has children\n        * we place the children in last)\n        * next() - | B1 | B2 | C1 | C2 | C3 | and returns D (because D doesn't have children, we just returns it)\n        * next() - | B2 | C1 | C2 | C3 | and returns B1 (because B1 doesn't have children, we just returns it)\n        * next() - | C1 | C2 | C3 | and returns B2 (because B2 doesn't have children, we just returns it)\n        * next() - | C2 | C3 | and returns C1 (because C1 doesn't have children, we just returns it)\n        * next() - | C3 | and returns C2 (because C2 doesn't have children, we just returns it)\n        * next() - | | and returns C3 (because C3 doesn't have children, we just returns it)\n        * reset() - | A |\n        */\n      // eslint-disable-next-line good-practices/no-function-dependency\n      it.bf = function (node) {\n        var nextNode = node,\n          bfArr = [],\n          next,\n          nextBatch,\n          reset,\n          bfBatchArray = [],\n          isExhausted = false;\n\n        // initial stage, start with the root node\n        bfArr.push(nextNode);\n        bfBatchArray.push(nextNode);\n\n        /*\n          * Apply breadth first and returns the next node\n          * @return {TreeNode | undefined} - if the complete tree is iterated returns undefined\n          */\n        next = function () {\n          var children,\n            fNode,\n            len;\n\n          if (isExhausted) {\n            return;\n          }\n\n          fNode = bfArr.shift();\n          children = fNode.getChildren();\n          len = (children && children.length) || 0; // eslint-disable-line good-practices/no-single-usage-variable\n\n          if (len) {\n            // Stores all the node of the same level\n            [].push.apply(bfArr, children);\n          }\n\n          if (bfArr.length === 0) {\n            isExhausted = true;\n          }\n\n          return fNode;\n        };\n\n        /*\n          * Custom function to return all the nodes of level by level\n          * @return {Array.<TreeNode>} - if the complete tree is iterated returns undefined\n          */\n        nextBatch = function () {\n          var children,\n            fNode,\n            len;\n\n          if (isExhausted) {\n            return;\n          }\n\n          fNode = bfBatchArray.shift(); // eslint-disable-line good-practices/no-single-usage-variable\n          children = fNode.getChildren();\n          len = (children && children.length) || 0; // eslint-disable-line good-practices/no-single-usage-variable\n\n          if (len) {\n            [].push.apply(bfBatchArray, children);\n          }\n\n          if (bfArr.length === 0) {\n            isExhausted = true;\n          }\n\n          return children;\n        };\n\n        /*\n          * Reset the state of the iterator. Every iterator instance needs to reset its state\n          * once it is done traversing. The caller will be responsible for this call.\n          */\n        reset = function () {\n          isExhausted = false;\n          nextNode = node; // eslint-disable-line good-practices/no-single-usage-variable\n          bfArr.length = 0;\n          bfArr.push(nextNode);\n        };\n\n        return {\n          next: next,\n          nextBatch: nextBatch,\n          reset: reset\n        };\n      };\n\n      // Everytime iterator is called, this creates new depth first algorithm API\n      df = (new Iterable(it.df)).initWith(rootNode); // eslint-disable-line good-practices/no-single-usage-variable\n      bf = (new Iterable(it.bf)).initWith(rootNode); // eslint-disable-line good-practices/no-single-usage-variable\n\n      return {\n        df: df,\n        bf: bf\n      };\n    };\n\n    /**\n      * Initialization operation to be performed before measuring space for label display.\n      * This takes one time information that is applied over all the text emasurement operation.\n      * @param  {Object} padding      - provides x and y padding of the label.\n      * @param  {number} lineHeightVal   - line height of text\n      * @param  {Object} attrs        - attributes\n      * @return {Function}            - a function that calculates and return the configuration to draw the text\n      */\n    function initConfigurationForlabel (padding, lineHeightVal, attrs) {\n      var lineHeight = lineHeightVal,\n        padX = padding.x, // eslint-disable-line good-practices/no-single-usage-variable\n        padY = padding.y, // eslint-disable-line good-practices/no-single-usage-variable\n        halfLineHeight = lineHeight / 2, // eslint-disable-line good-practices/no-single-usage-variable\n        titleHideFlag = attrs.showParent ? 0 : 1, // eslint-disable-line good-practices/no-single-usage-variable\n        showChildLabels = attrs.showChildLabels; // eslint-disable-line good-practices/no-single-usage-variable\n\n      /**\n        * Calculate the measurement of text.\n        * @param  {TreeNode} node        - node for which the label to be plotted\n        * @param  {Object}   rect        - bounding rectangle of node.\n        * @param  {boolean}  forcedLabel -\n        * @return {Object}               - the configuration object to draw the text and additional attribute primarily where\n        *                                  the visibility is maintained\n        */\n      return function (node, rect, forcedLabel) {\n        var // label,\n          isLeaf = false,\n          textCalConf = {\n            x: UNDEF,\n            y: UNDEF,\n            width: UNDEF,\n            height: UNDEF\n          },\n          conf = {},\n          rectShiftY = 0, // eslint-disable-line good-practices/no-single-usage-variable\n          textAttr = {}, // eslint-disable-line good-practices/no-single-usage-variable\n          highlightAttr = {},\n          visibility,\n          availableHeight,\n          meta;\n\n        meta = node.meta;\n\n        if (!node) {\n          return;\n        }\n\n        if (!node.isLeaf(maxDepth)) {\n          // Detect the child nodes and set a flag\n          isLeaf = true;\n        }\n\n        conf.label = node.getLabel();\n\n        textCalConf.width = rect.width - (2 * padX);\n        // Places it horizontally in the middle\n        textCalConf.x = rect.x + (rect.width / 2);\n\n        availableHeight = rect.height - (2 * padY); // eslint-disable-line good-practices/no-single-usage-variable\n\n        if (!isLeaf && availableHeight < lineHeight) {\n          textCalConf.height = -1;\n        }\n\n        if (!forcedLabel && isLeaf) {\n          // If it is a leaf node the label will be placed in the middle, horizontally and vertically\n          textCalConf.height = showChildLabels\n            ? textCalConf.height ? textCalConf.height : rect.height - (2 * padY) : -1;\n          textCalConf.y = rect.y + (rect.height / 2);\n        } else {\n          // If it is not leaf node the label will be placed at the top considering the padding and the\n          // children area will shrink\n          if (!titleHideFlag) {\n            // Places the label of the parent\n            textCalConf.height = textCalConf.height ? textCalConf.height : lineHeight;\n            textCalConf.y = rect.y + padY + halfLineHeight;\n          } else {\n            // Hides the label of parent.\n            textCalConf.y = -1;\n            padY = 0;\n            lineHeight = 0;\n            visibility = HIDDEN_STR;\n          }\n        }\n\n        // Calculation of shift which will be applied to move the starting point of chidren\n        rectShiftY += 2 * padY; // eslint-disable-line good-practices/no-single-usage-variable\n        rectShiftY += lineHeight; // eslint-disable-line good-practices/no-single-usage-variable\n\n        conf.rectShiftY = rectShiftY;\n        conf.textRect = textCalConf;\n\n        if (attrs.labelGlow) {\n          highlightAttr['stroke-width'] = attrs.labelGlowRadius;\n          highlightAttr.opacity = attrs.labelGlowIntensity;\n          highlightAttr.stroke = attrs.labelGlowColor;\n          highlightAttr.visibility = visibility === 'hidden' ? 'hidden' : 'visible';\n        } else {\n          highlightAttr.visibility = HIDDEN_STR;\n        }\n\n        // CSS for node labels\n        textAttr = { // eslint-disable-line good-practices/no-single-usage-variable\n          fontSize: attrs.labelFontSize || attrs.baseFontSize,\n          fontFamily: (attrs.labelFont || attrs.baseFont),\n          fill: convertColor((meta && meta.fontcolor && normalizeColorCode(meta.fontcolor)) ||\n                        attrs.labelFontColor || attrs.baseFontColor),\n          fontWeight: attrs.labelFontBold && 'bold',\n          fontStyle: attrs.labelFontItalic && 'italic',\n          visibility: visibility\n        };\n\n        return {\n          conf: conf,\n          attr: textAttr,\n          highlight: highlightAttr\n        };\n      };\n    }\n    /**\n     * This function tells that node is within the current range of gradient legend\n     * @param {Object} dsConf - contains reference to dataset configuration\n     * @param {number} nodeColorValue - contains the svalue of the node\n     * @return {boolean} true/false\n    */\n    function isInRange (dsConf, nodeColorValue) { // eslint-disable-line good-practices/no-function-dependency\n      let range = dsConf.range;\n      if (!range) {\n        return true;\n      } else if (range.min <= nodeColorValue && nodeColorValue <= range.max) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n      * Manages color of all the nodes. This colors the leaf node taking configuration from the xml/json\n      * by using ColorRangeManager.\n      * For non-leaf (title) nodes it provides color if user has provided one in defaultParentBGColor attribute.\n      * The title nodes are not colored from the ColorRangeManager.\n      * This takes the initial parameters and initialize the state and hold it until it is called again\n      * @param  {Object}            attrs            - All the chart attributes sanitized\n      * @param  {ColorRangeManager} colorRange       - instance of ColorRangeManager that has all the information about the\n      *                                               color distribution. This function merely calls the APIs\n      * @param  {boolean}           isNavigationBar  - whether it is for navigation bar or not\n      * @return {Function}                           - Returns a function that returns a color code when a node\n      *                                                is passed keeping in the state intact.\n      */\n    function mapColorManager (attrs, colorRange, isNavigationBar) {\n      // eslint-disable-next-line good-practices/no-single-usage-variable\n      var defaultParentBGColor = normalizeColorCode(isNavigationBar ? attrs.defaultNavigationBarBGColor\n        : attrs.defaultParentBGColor);\n\n      /**\n        * Uses the saved state and returns the color for a node calculating the node value.\n        * @param  {TreeNode} node             - node which is subjected to be colored\n        * @param  {boolean}  isNavigationBar  - whether it is for navigation bar or not\n        * @param  {object}  dsConf  - reference to dataset configuration\n        * @return {string}                    - color in hex\n        */\n      return function (node, isNavigationBar, dsConf) { // eslint-disable-line\n        var colorProp = {},\n          cssConf = node.cssConf,\n          meta = node.meta,\n          overriddenColor = meta.fillcolor ? normalizeColorCode(meta.fillcolor) : UNDEF,\n          parentColor,\n          parentStyle,\n          parentNode = node.getParent(), // eslint-disable-line good-practices/no-single-usage-variable\n          thisNodeColor,\n          nodeColorValue = node.getColorValue();\n\n        // temp CODE\n        attrs.isLegendEnabled = true;\n\n        if (attrs.isLegendEnabled && (nodeColorValue === 0 || nodeColorValue)) {\n          if (colorRange && colorRange.getColorByValue(nodeColorValue)) {\n            if (isInRange(dsConf, nodeColorValue)) {\n              node.presentColor = '#' + colorRange.getColorByValue(nodeColorValue);\n            } else {\n              node.presentColor = normalizeColorCode(dsConf.rangeOutBgColor);\n            }\n          } else {\n            node.presentColor = normalizeColorCode(colorRange && colorRange.rangeOutsideColor);\n          }\n        } else {\n          node.presentColor = UNDEF;\n        }\n        if (overriddenColor) {\n          node.presentColor = overriddenColor;\n        }\n        // Get the generalized color for a node. Later overriden for non-leaf nodes\n        thisNodeColor = attrs.isLegendEnabled && (nodeColorValue === 0 || nodeColorValue)\n          ? (colorRange && colorRange.getColorByValue(nodeColorValue) &&\n                         '#' + colorRange.getColorByValue(nodeColorValue)) ||\n                            normalizeColorCode(colorRange && colorRange.rangeOutsideColor) : UNDEF;\n\n        // Check if the current node in context is a leaf node which in turn is dependent if there is a depth\n        // restriction imposed.\n        if (node.isLeaf(maxDepth)) {\n          // If the node is not leaf node apply title colors property if available\n          colorProp.fill = overriddenColor || thisNodeColor || defaultParentBGColor;\n        } else {\n          parentStyle = (parentNode || node).cssConf;\n          parentColor = parentStyle && parentStyle.fill;\n\n          thisNodeColor = thisNodeColor || parentColor;\n          colorProp.fill = overriddenColor || thisNodeColor;\n        }\n\n        // apply node border thickness and color\n        colorProp.stroke = isNavigationBar ? attrs.navigationBarBorderColor : attrs.plotBorderColor;\n        colorProp.strokeWidth = isNavigationBar ? attrs.navigationBarBorderThickness\n          : attrs.plotBorderThickness;\n        colorProp['stroke-dasharray'] = NONE;\n        // applicable for only the treemap.\n        if (!isNavigationBar) {\n          if (cssConf && cssConf['stroke-dasharray'] === '--') {\n            colorProp['stroke-dasharray'] = cssConf['stroke-dasharray'];\n            colorProp.strokeWidth = cssConf.strokeWidth;\n          }\n        }\n        return colorProp;\n      };\n    }\n\n    /*\n         * Serves the purpose of application context. Any Object can be stored and retrieved through the lifetime\n         * of the chart instance. This gives back a singleton instance per id. Like if two different store is needed,\n         * this is called with two different id. If the ids are kept same same instance is returned.\n         */\n    // eslint-disable-next-line good-practices/no-function-dependency\n    context = (function () {\n      var objContainer = {},\n        pointer;\n\n      /**\n       * Constructor to create instance per id\n       */\n      function C_ () { // eslint-disable-line good-practices/no-function-dependency\n        // Container of instances of particular id\n        this.con = {};\n      }\n\n      C_.prototype.constructor = C_;\n\n      C_.prototype.get = function (key) { // eslint-disable-line good-practices/no-function-dependency\n        return this.con[key];\n      };\n\n      C_.prototype.set = function (key, value) { // eslint-disable-line good-practices/no-function-dependency\n        this.con[key] = value;\n      };\n\n      C_.prototype['delete'] = function (key) { // eslint-disable-line good-practices/no-function-dependency\n        return delete this.con[key];\n      };\n\n      return {\n        /**\n          * Returns singleton instances per id\n          * @param  {string} id - name of id\n          * @return {Object}    - returns object if already instantiated or create one and return\n          */\n        getInstance: function (id) { // eslint-disable-line\n          var _con;\n\n          if (objContainer[id]) {\n            _con = objContainer[id];\n            // Already instantiated, get the reference and return\n            pointer = _con;\n            return pointer;\n          }\n\n          // Not available in container means not instantiated, creates a new instance and returns\n          pointer = _con = objContainer[id] = new C_(); // eslint-disable-line good-practices/no-single-usage-variable\n          return pointer;\n        }\n      };\n    })();\n    /**\n      * Sets the visible root node.\n      * @param {TreeNode} node - On drill down/ up the visible root needs to be changed.\n      */\n    function setVisibleRoot (node) {\n      visibleRoot = node;\n    }\n    /**\n      * Fetch the visible root.\n      * @return {TreeRoot} - The visible root for the current view.\n      */\n    function getVisibleRoot () {\n      return visibleRoot;\n    }\n\n    /**\n      * It registers the different events and the functionality\n      * @param {algorithmFactory} algorithmAPI  - all the apis for the running algorithm\n      * @param {Object} dsStore - dataset instance\n      * @param {Object} canvasMeasurement  - Simple key-value pair of information\n      *                                      of the available drawing area.\n      * @param {Object} rendererAPI  - API needed to render the objects in the drawing area.\n      * @return {Object}             - contains event callback fn\n      */\n    function abstractEventRegisterer (algorithmAPI, dsStore, canvasMeasurement, rendererAPI) {\n      var chart = dsStore.getFromEnv('chart'),\n        btns = dsStore.getFromEnv('toolbarBtns'),\n        attrs = dsStore.conf,\n        // legend = dsStore.getFromEnv('gLegend'),\n        drawTreeFn = algorithmAPI.drawTree,\n        removeFn = rendererAPI.disposeChild,\n        backToParent,\n        context = afAPI.context, // eslint-disable-line\n        args = arguments,\n        stateContextId = CLICKEDSTATE,\n        visibleState = VISIBLEROOT,\n        plotClickEvt = DATAPLOTCLICK, // eslint-disable-line good-practices/no-single-usage-variable\n        plotRollOverEvt = DATAPLOTROLLOVER,\n        plotRollOutEvt = DATAPLOTROLLOUT,\n        stateContext,\n        resetTree,\n        dataUprootMap = {\n          colorValue: 'svalue',\n          label: 'name',\n          value: 'value',\n          rect: 'metrics'\n        };\n\n      stateContext = context.getInstance(stateContextId);\n\n      // Save reference of internal subroutines, for later use\n      chart._intSR = {};\n      /**\n       * function to extract event data\n       * @param {Object} node - tree node\n       * @return {Object}     - event data\n       */\n      function extractEventData (node) {\n        var res = {},\n          key,\n          resKey;\n\n        for (key in dataUprootMap) {\n          resKey = dataUprootMap[key];\n          res[resKey] = node[key];\n        }\n\n        res.fillColor = node.meta.fillcolor || node.cssConf.fill;\n        res.fontColor = node.meta.fontcolor || node.cssConf.stroke;\n\n        return res;\n      }\n\n      /**\n        * Goes back to immediate parent of the view.\n        * @param {boolean} raiseEventFlag - If true event will be raised. Otherwise no.\n        *\n        */\n      chart._intSR.backToParent = backToParent = function (raiseEventFlag) {\n        var target = this,\n          _t = target,\n          _p = _t && target.getParent(),\n          context = afAPI.context, // eslint-disable-line\n          stateContextId = CLICKEDSTATE, // eslint-disable-line\n          visibleState = VISIBLEROOT, // eslint-disable-line\n          stateContext = context.getInstance(stateContextId), // eslint-disable-line\n          clickedState = stateContext.get(visibleState) || {};\n\n        chart.config.trackerConfig.length = 0;\n        chart.triggerKDTreePartioning();\n        if (raiseEventFlag) {\n          /** @todo eventname should be taken from constants */\n          /** @todo common event handling API */\n          chart.fireChartInstanceEvent('beforedrillup', {\n            node: target,\n            withoutHead: !attrs.showParent\n          }, UNDEF, function () {\n            // If the event is not prevented in anyway\n\n            if (_p) {\n              clickedState.state = DRILLUP;\n              clickedState.node = [{ virginNode: afAPI.getVisibleRoot() }, _p];\n              // Remove all the elements from the paper and redraw the tree\n              // using a different root node.\n              removeFn(_t);\n              drawTreeFn.apply(_p, args);\n            }\n\n            // Render complete now raise the event\n            /** @todo eventname should be taken from constants */\n            chart.fireChartInstanceEvent(DRILLUP, {\n              node: target,\n              withoutHead: !attrs.showParent,\n              drillUp: backToParent,\n              drillUpToTop: resetTree\n            });\n\n            target = target && target.getParent();\n          }, function () {\n            // Event is prevented\n            chart.fireChartInstanceEvent('drillupcancelled', {\n              node: target,\n              withoutHead: !attrs.showParent\n            });\n          });\n        } else {\n          if (_p) {\n            clickedState.state = DRILLUP;\n            clickedState.node = [{ virginNode: afAPI.getVisibleRoot() }, _p];\n            // Remove all the elements from the paper and redraw the tree\n            // using a different root node.\n            removeFn(_t);\n            drawTreeFn.apply(_p, [algorithmAPI, dsStore, canvasMeasurement, rendererAPI]);\n          }\n\n          target = target && target.getParent();\n        }\n      };\n\n      /**\n        * Goes back to absolute parent of the view.\n        * @param {boolean} raiseEventFlag - If true event will be raised. Otherwise no.\n        *\n        * @todo donot pollute the chart object. Function access restructuring.\n        */\n      chart._intSR.resetTree = resetTree = function (raiseEventFlag) {\n        var target = this,\n          _p = target && target.getParent(),\n          _t,\n          context = afAPI.context, // eslint-disable-line\n          stateContextId = CLICKEDSTATE, // eslint-disable-line\n          visibleState = VISIBLEROOT, // eslint-disable-line\n          stateContext = context.getInstance(stateContextId), // eslint-disable-line\n          clickedState = stateContext.get(visibleState) || {};\n\n        chart.config.trackerConfig.length = 0;\n        chart.triggerKDTreePartioning();\n\n        while (_p) {\n          // Swaps the references. Keep clicked node in one variable and parent in\n          // another variable.\n          _t = _p;\n          _p = _p.getParent();\n        }\n\n        if (raiseEventFlag) {\n          // @todo eventname should be taken from constants\n          chart.fireChartInstanceEvent('beforedrillup', {\n            node: target,\n            withoutHead: !attrs.showParent\n          }, UNDEF, function () {\n            if (_t) {\n              clickedState.state = DRILLUP;\n              clickedState.node = [{ virginNode: afAPI.getVisibleRoot() }, _t];\n\n              // Remove all the elements from the paper and redraw the tree using\n              // a different root node.\n              removeFn(_t);\n              drawTreeFn.apply(_t, args);\n\n              /* @todo eventname should be taken from constants */\n              chart.fireChartInstanceEvent(DRILLUP, {\n                node: target,\n                sender: chart.fusionCharts,\n                withoutHead: !attrs.showParent,\n                drillUp: backToParent,\n                drillUpToTop: resetTree\n              });\n            }\n          }, function () {\n            chart.fireChartInstanceEvent('drillupcancelled', {\n              node: target,\n              withoutHead: !attrs.showParent\n            });\n          });\n        } else {\n          if (_t) {\n            clickedState.state = DRILLUP;\n            clickedState.node = [{ virginNode: afAPI.getVisibleRoot() }, _t];\n\n            // Remove all the elements from the paper and redraw the tree using a different\n            // root node.\n            removeFn(_t);\n            drawTreeFn.apply(_t, args);\n          }\n        }\n      };\n\n      return {\n        click: function (node, baseNode) {\n          var thisVNode = node.virginNode,\n            eventName,\n            parent,\n            animationManager = chart.getFromEnv('animationManager'),\n            target;\n          chart.state = CLICK_STR;\n          chart.fireChartInstanceEvent(plotClickEvt, extractEventData(node.virginNode));\n\n          parent = thisVNode.getParent();\n\n          if (!parent) {\n            // If the click is on root node, return since it is not possible to go back and\n            // display the parent\n            return;\n          }\n          if (thisVNode === baseNode) {\n            // If the top most rectangle is clicked show the parent rectangle of it. This\n            // is for iterative click (once drilled down)\n            target = parent;\n            // trackerConfig array made empty for new kd-tree\n            chart.flushKDTree();\n\n            eventName = DRILLUP;\n          } else {\n            if (thisVNode.next) {\n              // If the click is not on top most rectangle (base node)and base node\n              // has children, drill down to the clicked node\n              target = thisVNode;\n              // trackerConfig array made empty for new kd-tree\n              chart.flushKDTree();\n              eventName = DRILLDOWN;\n            } else {\n              // If the click is not on top most rectangle (base node)and base node\n              // doesnot have any more chidren drill down to the parent node of clicked node\n              target = parent;\n\n              if (baseNode === target) {\n                eventName = UNDEF;\n                return;\n              }\n              // trackerConfig array made empty for new kd-tree\n              /** @todo eventname should be taken from constants */\n              eventName = DRILLDOWN;\n            }\n          }\n\n          // Reset the legend once any traversal happens\n          // (legend && legend.enabled) && legend.resetLegend();\n          // algorithmAPI.applyShadeFiltering.reset();\n\n          eventName && chart.fireChartInstanceEvent('before' + eventName, {\n            node: target,\n            withoutHead: !attrs.showParent\n          }, UNDEF, function () {\n            chart.config.trackerConfig.length = 0;\n            stateContext.set(visibleState, {\n              node: node,\n              state: eventName\n            });\n\n            // Remove everything from the paper\n            removeFn.call(rendererAPI, target);\n            // reset the visible Root\n            setVisibleRoot(target);\n            // setting the animation state to drill for drill-down animation\n            animationManager.setAnimationState('drill');\n            chart.setState('drill', true);\n            // Redraw by assigning a new root\n            containerManager.draw();\n            // eslint-disable-next-line good-practices/no-function-dependency\n            animationManager.onAnimationComplete(() => {\n              chart.setState('drill', false);\n            });\n\n            // @todo eventname should be taken from constants\n\n            chart.fireChartInstanceEvent(eventName, {\n              node: target,\n              withoutHead: !attrs.showParent,\n              drillUp: backToParent,\n              drillUpToTop: resetTree\n            });\n          }, function () {\n            // Event is cancelled\n            chart.fireChartInstanceEvent(eventName + 'cancelled', {\n              node: target,\n              withoutHead: !attrs.showParent\n            });\n          });\n\n          chart.addJob('attachEventToBtns', function () {\n            chart._lastAttached.backToParent && btns.back &&\n            btns.back.removeEventListener('fc-click', chart._lastAttached.backToParent);\n\n            chart._lastAttached.resetTree && btns.home &&\n              btns.home.removeEventListener('fc-click', chart._lastAttached.resetTree);\n\n            chart._lastAttached.backToParent = backToParent.bind(target);\n            chart._lastAttached.resetTree = resetTree.bind(target);\n\n            btns.back && btns.back.addEventListener('fc-click', chart._lastAttached.backToParent);\n\n            btns.home && btns.home.addEventListener('fc-click', chart._lastAttached.resetTree);\n          }, priorityList.kdTree);\n          chart.resetSingleTracker();\n        },\n\n        mouseover: function (node) {\n          var evtData = extractEventData(node.virginNode);\n          chart.fireChartInstanceEvent(plotRollOverEvt, evtData, UNDEF, UNDEF,\n            function () {\n              chart.fireChartInstanceEvent(plotRollOverEvt + 'cancelled', evtData);\n            });\n        },\n\n        mouseout: function (node) {\n          var evtData = extractEventData(node.virginNode); // eslint-disable-line good-practices/no-single-usage-variable\n\n          chart.fireChartInstanceEvent(plotRollOutEvt, extractEventData(node.virginNode),\n            UNDEF, UNDEF,\n            function () {\n              chart.fireChartInstanceEvent(plotRollOutEvt + 'cancelled', evtData);\n            });\n        }\n      };\n    }\n\n    visibilityController = (function () { // eslint-disable-line good-practices/no-single-usage-variable\n      var restOfTheTreeArr = [],\n        nextVisibileTreeRoot,\n        inProgress = false, // eslint-disable-line good-practices/no-single-usage-variable\n        attrVisible = { visibility: 'visible', opacity: 1 };\n\n      return {\n        controlPreAnimVisibility: function (node, superNode) {\n          var rootNode,\n            tempNode,\n            itr,\n            dfItr,\n            nextNode,\n            overAttr;\n\n          if (!node) {\n            return;\n          }\n\n          tempNode = node;\n          while (true) {\n            tempNode = tempNode.getParent();\n\n            if (!tempNode) {\n              break;\n            }\n            rootNode = tempNode;\n          }\n\n          itr = iterator(rootNode, { exception: node }); // eslint-disable-line good-practices/no-single-usage-variable\n          dfItr = itr.df; // eslint-disable-line good-practices/no-single-usage-variable\n\n          while (true) {\n            nextNode = dfItr.next();\n            if (!nextNode) {\n              break;\n            }\n\n            overAttr = nextNode.overAttr || (nextNode.overAttr = {});\n            overAttr.visibility = HIDDEN_STR;\n            restOfTheTreeArr.push(nextNode);\n          }\n\n          nextVisibileTreeRoot = superNode || node.getParent();\n\n          inProgress = false;\n          return restOfTheTreeArr;\n        },\n\n        displayAll: function (node) {\n          var itr,\n            overAttr,\n            dfItr,\n            nextNode;\n\n          if (!node) { return; }\n\n          itr = iterator(node.getParent() || node); // eslint-disable-line good-practices/no-single-usage-variable\n          dfItr = itr.df; // eslint-disable-line good-practices/no-single-usage-variable\n\n          while (true) {\n            nextNode = dfItr.next();\n            if (!nextNode) {\n              break;\n            }\n\n            overAttr = nextNode.overAttr || (nextNode.overAttr = {});\n            overAttr.visibility = VISIBLE_STR;\n          }\n\n          nextVisibileTreeRoot = UNDEF;\n          restOfTheTreeArr.length = 0;\n          inProgress = false;\n        },\n\n        controlPostAnimVisibility: function () {\n          var textItem,\n            dirtyNode,\n            itr,\n            dfItr,\n            nextNode;\n\n          if (inProgress) {\n            return;\n          }\n\n          inProgress = true; // eslint-disable-line good-practices/no-single-usage-variable\n\n          if (!nextVisibileTreeRoot) { return; }\n\n          itr = iterator(nextVisibileTreeRoot); // eslint-disable-line good-practices/no-single-usage-variable\n          dfItr = itr.df; // eslint-disable-line good-practices/no-single-usage-variable\n\n          while (true) {\n            nextNode = dfItr.next(maxDepth);\n            if (!nextNode) {\n              break;\n            }\n\n            if (nextNode.dirtyNode) {\n              dirtyNode = nextNode.dirtyNode;\n              dirtyNode && dirtyNode.plotItem.attr(attrVisible);\n              textItem = dirtyNode && dirtyNode.textItem;\n              textItem && textItem.label && textItem.label.attr(attrVisible);\n              textItem && textItem.label && textItem.highlightMask.attr(attrVisible);\n            }\n          }\n\n          nextVisibileTreeRoot = UNDEF;\n          restOfTheTreeArr.length = 0;\n        }\n      };\n    })();\n\n    afAPI.AbstractTreeMaker = AbstractTreeMaker;\n    afAPI.iterator = iterator;\n    afAPI.initConfigurationForlabel = initConfigurationForlabel;\n    afAPI.context = context;\n    afAPI.mapColorManager = mapColorManager;\n    afAPI.abstractEventRegisterer = abstractEventRegisterer;\n    afAPI.setMaxDepth = setMaxDepth;\n    afAPI.getVisibleRoot = getVisibleRoot;\n    afAPI.setVisibleRoot = setVisibleRoot;\n    afAPI.visibilityController = visibilityController;\n\n    return afAPI;\n  },\n\n  /**\n    * Defines the tiling algorithm and exposes api to access those.\n    * @param {Object} afAPI - APIs to create algorithm factoy\n    * @param {Object} algorithmFactory - Algorithm Factory APIs\n    * @return {Object} algorithmFactory - Algorithm Factory APIs\n    */\n  algorithmFactoryCreator = function (afAPI, algorithmFactory) {\n    var algo,\n      AbstractTreeMaker = afAPI.AbstractTreeMaker, // eslint-disable-line good-practices/no-single-usage-variable\n      algorithm,\n      treeMaker,\n      tree,\n      bucketIterationMode,\n      depthIncrement,\n      maxDepth;\n    /**\n     * Function to set null/zero values to sum of its child values\n     * by traversing the tree in post-oder\n     * @param {Object} node, particular node of the tree\n     */\n    function postOrderTraversal (node) {\n      let children = node.getChildren(),\n        childNode,\n        sumOfvalues = 0; // eslint-disable-line good-practices/no-single-usage-variable\n      // traverse the children recursively and calculate the sum of values of its children\n      for (let i = 0; i < (children && children.length); i++) {\n        childNode = children[i];\n        postOrderTraversal(childNode);\n        sumOfvalues += childNode.getValue() || 0;\n      }\n      // assign sum of the values of childnodes to parent node only if value of parent node is null\n      if (isNaN(node.value)) {\n        node.value = sumOfvalues;\n      }\n    }\n    // drawingAreaMeasurement;\n\n    algo = {\n      'sliceanddice': {\n        /**\n          * Provides a more managed way to calculate space for child.\n          * This takes minimum space configuration and applies it over all the subsequent calculation\n          * @param {Integer} horizontalPadding  - space between parent and child in x direction\n          * @param {Integer} verticalPadding  - space between parent and child in y direction\n          * @return {Function} - A function to be called, everytime space for a new node needs to be\n          * calculated\n          */\n        areaBaseCalculator: function (horizontalPadding, verticalPadding) { // eslint-disable-line good-practices/no-function-dependency\n          var sx = horizontalPadding, sy = verticalPadding;\n\n          /*\n                     * Provides the basic information of the tree so that the current node can use that and\n                     * calculate the space\n                     * @param node {TreeNode} - node which is the subject to calculation\n                     * @param posOffsetApplyFn {Function} - logic of calculation. This function is called with\n                     *      meta information, immediate left sibling (if any) and parent. The context\n                     *      of this function is changed with the one which is subject to calculation.\n                     * @param options {Object} - provides additional options to the calculation.\n                                                Something like space for label.\n                     * @return {Object} - returns what ever posOffsetApplyFn returns.\n                     */\n          return function (node, posOffsetApplyFn, options) {\n            var parent,\n              leftSibling,\n              denominator,\n              meta = {},\n              eHeight,\n              eWidth,\n              parentRect,\n              textMargin = 0,\n              negSpacesY = 0;\n\n            if (!node) {\n              return;\n            }\n\n            if (options) {\n              textMargin = options.textMargin || textMargin;\n            }\n\n            negSpacesY = textMargin;\n\n            parent = node.getParent();\n            // Get immediate left sibling\n            leftSibling = node.getSibling('left');\n\n            if (parent) {\n              // Denomitor to calculate the area. Every parent value is the sum of all children value\n              denominator = parent.getValue();\n              parentRect = parent.rect;\n              // Calculate the width and hight of the space where children will be drawn.\n              // This ideally depend on the space that was passed when the outer most function\n              // was called\n              eHeight = parentRect.height - (2 * sy) - negSpacesY;\n              eWidth = parentRect.width - (2 * sx);\n\n              /*\n                             * This is the inner logical rectangle where the child is drawn. If horizontalPadding\n                               and verticalPadding\n                             * is zero it is as same as the outermost rectangle. Something like\n                             *\n                             *  Parent rect\n                             *  -----------------------\n                             * |  verticalPadding     s|\n                             * |  ------------------- p|\n                             * | | effective rect    |a|\n                             * | | where child will  |c|\n                             * | | be drawn          |e|\n                             * | |                   |x|\n                             */\n              meta.effectiveRect = {\n                height: eHeight,\n                width: eWidth,\n                x: parentRect.x + sx,\n                y: parentRect.y + sy + negSpacesY\n              };\n              meta.effectiveArea = eHeight * eWidth;\n              meta.ratio = node.getValue() / denominator;\n\n              if (leftSibling) {\n                // If this is not the first children, this will be drawn relative\n                // to the former children\n                return posOffsetApplyFn.call(node, meta, leftSibling, parent);\n              }\n              // Flag indication that the last retrieved is parent\n              meta.lastIsParent = true;\n              // First children. This will be drawn relative\n              return posOffsetApplyFn.call(node, meta, parent);\n            }\n            // If parent is not present the it is the root node. For root node use the\n            // original canvas area. If parent is not present there is also no chance to\n            // have siblings of the node. Since there can only be only one root node\n            return null;\n          };\n        },\n\n        /**\n          * Initializes the state required when the legend is dragged and effect to be applied\n          * @param {Object}   bucketInstance  - instace of bucket\n          * @param {Object}   overrideEffect  - style to be applied in key-value pair\n          * @param {Function} rangeOutFn      - Function to be executed when outliers are found\n          * @return {Function}                - Control function that operates on outliers by adjusting the range\n          */\n        applyShadeFiltering: function (bucketInstance, overrideEffect, rangeOutFn) { // eslint-disable-line good-practices/no-function-dependency\n          // Set style information\n          bucketInstance.setRangeOutEffect(overrideEffect, rangeOutFn);\n\n          this.applyShadeFiltering.reset = function () {\n            bucketInstance.resetPointers();\n          };\n\n          /**\n            * Control the effect to be executed on outliers.\n            * @param {Object} limits  - an simple javascript object containing the start and end limit of\n            *                           the legend\n            */\n          return function (limits) {\n            bucketInstance.moveLowerShadePointer(limits.start);\n            bucketInstance.moveHigherShadePointer(limits.end);\n          };\n        },\n        /**\n          * logic of calculation. This function is called with meta information, immediate left sibling\n          * (if any) and parent. The context of this function is changed with the one which is subject to\n          * calculation.\n          * @return {Object} -\n          */\n        alternateModeManager: function () { // eslint-disable-line good-practices/no-function-dependency\n          return function (meta, lastPoint) { // eslint-disable-line good-practices/no-function-dependency\n            var height,\n              width,\n              isDirectionVertical,\n              dx,\n              dy,\n              cNode = this,\n              baseArea = meta.effectiveArea, // eslint-disable-line good-practices/no-single-usage-variable\n              ratio = meta.ratio, // eslint-disable-line good-practices/no-single-usage-variable\n              childArea = baseArea * ratio,\n              effectiveRect = meta.effectiveRect,\n              lastRect = lastPoint.rect,\n              lastIsParent = meta.lastIsParent; // eslint-disable-line good-practices/no-single-usage-variable\n\n            if (lastIsParent) {\n              // If the node is the first children, take measurement of the effective rect\n              dx = effectiveRect.x;\n              dy = effectiveRect.y;\n              height = effectiveRect.height;\n              width = effectiveRect.width;\n\n              // First direction is vertical (or parameterized)\n              isDirectionVertical = cNode.isDirectionVertical = true;\n            } else {\n              // If the node is not the first child, get the remaining height and width where\n              // the drawing will happen\n              height = (effectiveRect.height + effectiveRect.y) - (lastRect.height + lastRect.y);\n              width = (effectiveRect.width + effectiveRect.x) - (lastRect.width + lastRect.x);\n\n              // Every child drawing direction will be opposite of what the immediate left\n              // sibling used to be\n              isDirectionVertical = cNode.isDirectionVertical = !lastPoint.isDirectionVertical;\n            }\n\n            if (isDirectionVertical) {\n              // If this orientation is vertical possible that the last one is horizontal\n              width = childArea / height;\n              dx = dx !== UNDEF ? dx : lastRect.x;\n              dy = dy !== UNDEF ? dy : (lastRect.y + lastRect.height);\n            } else {\n              height = childArea / width;\n              dx = dx !== UNDEF ? dx : (lastRect.x + lastRect.width);\n              dy = dy !== UNDEF ? dy : lastRect.y;\n            }\n\n            return {\n              height: height,\n              width: width,\n              x: dx,\n              y: dy\n            };\n          };\n        },\n\n        horizontalVerticalManager: function (slicingMode) { // eslint-disable-line good-practices/no-function-dependency\n          var isVerticalSlicing = Boolean((slicingMode === 'vertical')); // eslint-disable-line good-practices/no-single-usage-variable\n          return function (meta, lastPoint) {\n            var height,\n              width,\n              isDirectionVertical,\n              dx,\n              dy,\n              cNode = this,\n              baseArea = meta.effectiveArea, // eslint-disable-line good-practices/no-single-usage-variable\n              ratio = meta.ratio, // eslint-disable-line good-practices/no-single-usage-variable\n              childArea = baseArea * ratio,\n              effectiveRect = meta.effectiveRect,\n              lastRect = lastPoint.rect,\n              lastIsParent = meta.lastIsParent; // eslint-disable-line good-practices/no-single-usage-variable\n\n            if (lastIsParent) {\n              // If the node is the first children, take measurement of the effective rect\n              dx = effectiveRect.x;\n              dy = effectiveRect.y;\n              height = effectiveRect.height;\n              width = effectiveRect.width;\n\n              // First direction is vertical (or parameterized)\n              isDirectionVertical = cNode.isDirectionVertical = !lastPoint.isDirectionVertical;\n            } else {\n              // If the node is not the first child, get the remaining height and width where\n              // the drawing will happen\n              height = (effectiveRect.height + effectiveRect.y) - (lastRect.height + lastRect.y);\n              width = (effectiveRect.width + effectiveRect.x) - (lastRect.width + lastRect.x);\n\n              // Every child drawing direction will be opposite of what the immediate left\n              // sibling used to be\n              isDirectionVertical = cNode.isDirectionVertical = !arguments[2].isDirectionVertical;\n            }\n            // toogle the directional flag as per the slicing mode.\n            isDirectionVertical = isVerticalSlicing ? isDirectionVertical : !isDirectionVertical;\n            if (isDirectionVertical) {\n              // If this orientation is vertical possible that the last one is horizontal\n              if (height === 0) {\n                height = effectiveRect.height;\n                dx = dx !== UNDEF ? dx : (lastRect.x + lastRect.width);\n                dy = dy !== UNDEF ? dy : lastRect.y;\n              }\n              width = childArea / height;\n              dx = dx !== UNDEF ? dx : lastRect.x;\n              dy = dy !== UNDEF ? dy : (lastRect.y + lastRect.height);\n            } else {\n              if (width === 0) {\n                width = effectiveRect.width;\n                dx = dx !== UNDEF ? dx : lastRect.x;\n                dy = dy !== UNDEF ? dy : (lastRect.y + lastRect.height);\n              }\n              height = childArea / width;\n              dx = dx !== UNDEF ? dx : (lastRect.x + lastRect.width);\n              dy = dy !== UNDEF ? dy : lastRect.y;\n            }\n\n            return {\n              height: height,\n              width: width,\n              x: dx,\n              y: dy\n            };\n          };\n        },\n\n        /**\n          * Maps the logical tree to nested rectangle and render on the paper.\n          * @param {algorithmFactory} algorithmAPI  - all the apis for the running algorithm\n          * @param {Object} dsStore - dataset instance\n          * @param {Object} canvasMeasurement  - Simple key-value pair of information\n          *                                      of the available drawing area.\n          * @param {Object} rendererAPI  - API needed to render the objects in the drawing area.\n          */\n        drawTree: function (algorithmAPI, dsStore, canvasMeasurement, rendererAPI) {\n          var treeRoot = this,\n            chart = dsStore.getFromEnv('chart'),\n            config = chart.config || (chart.config = {}),\n            trackerConfig = config.trackerConfig || (config.trackerConfig = []), // eslint-disable-line good-practices/no-single-usage-variable\n            numberFormatter = dsStore.getFromEnv('number-formatter'),\n            btns = dsStore.getFromEnv('toolbarBtns'),\n            drawRectFn = rendererAPI.drawRect, // eslint-disable-line good-practices/no-single-usage-variable\n            drawTextFn = rendererAPI.drawText, // eslint-disable-line good-practices/no-single-usage-variable\n            drawHotFn = rendererAPI.drawHot, // eslint-disable-line good-practices/no-single-usage-variable\n            xShift = canvasMeasurement.horizontalPadding, // eslint-disable-line good-practices/no-single-usage-variable\n            yShift = canvasMeasurement.verticalPadding, // eslint-disable-line good-practices/no-single-usage-variable\n            smartLabel = dsStore.getFromEnv('smartLabel'),\n            lineHeight,\n            labelPadding = { // eslint-disable-line good-practices/no-single-usage-variable\n              x: 5,\n              y: 5\n            },\n            iterator = afAPI.iterator, // eslint-disable-line good-practices/no-single-usage-variable\n            itr = iterator(treeRoot), // eslint-disable-line good-practices/no-single-usage-variable\n            dfItr = itr.df,\n            baseNode,\n            getNextAreaBase = algorithmAPI.areaBaseCalculator(xShift, yShift), // eslint-disable-line good-practices/no-single-usage-variable\n            attrs = dsStore.conf,\n            highlightParentsOnHover = attrs.highlightParentsOnHover, // eslint-disable-line good-practices/no-single-usage-variable\n            getTextConf,\n            context = afAPI.context,\n            visController = afAPI.visibilityController,\n            colorRange = dsStore.conf.colorRange, // eslint-disable-line good-practices/no-single-usage-variable\n            localColorProvider = afAPI.mapColorManager(attrs, colorRange), // eslint-disable-line good-practices/no-single-usage-variable\n            abstractEvtReg = afAPI.abstractEventRegisterer(algorithmAPI, dsStore, canvasMeasurement, rendererAPI),\n            clickEvtImpl = abstractEvtReg.click, // eslint-disable-line good-practices/no-single-usage-variable\n            mouseoverEvtImpl = abstractEvtReg.mouseover, // eslint-disable-line good-practices/no-single-usage-variable\n            mouseoutEvtImpl = abstractEvtReg.mouseout, // eslint-disable-line good-practices/no-single-usage-variable\n            slicingMode = attrs.slicingMode,\n            temp = ((slicingMode === 'alternate') ? 'alternateModeManager' // eslint-disable-line good-practices/no-single-usage-variable\n              : 'horizontalVerticalManager'),\n            postNodeFetcher = algorithmAPI[temp](slicingMode), // eslint-disable-line good-practices/no-single-usage-variable\n            _baseNode,\n            _intSR = chart._intSR,\n            resetTree,\n            backToParent,\n            stateContextId = CLICKEDSTATE, // eslint-disable-line good-practices/no-single-usage-variable\n            visibleState = VISIBLEROOT, // eslint-disable-line good-practices/no-single-usage-variable\n            stateContext,\n            clickedState,\n            csNode;\n\n          stateContext = context.getInstance(stateContextId); // eslint-disable-line good-practices/no-single-usage-variable\n          clickedState = stateContext.get(visibleState) || {};\n          csNode = clickedState.node;\n\n          if (clickedState.node && clickedState.state) {\n            if (clickedState.state.toLowerCase() === DRILLUP) {\n              if (csNode instanceof Array) {\n                visController.controlPreAnimVisibility(csNode[0].virginNode, csNode[1]);\n              } else {\n                visController.controlPreAnimVisibility(csNode.virginNode);\n              }\n            } else {\n              visController.displayAll(clickedState.node.virginNode);\n            }\n          }\n\n          lineHeight = attrs.parentLabelLineHeight; // eslint-disable-line good-practices/no-single-usage-variable\n          // Gets label configuration\n          getTextConf = afAPI.initConfigurationForlabel(labelPadding, lineHeight, attrs); // eslint-disable-line good-practices/no-single-usage-variable\n\n          // First time iteration to get the root node\n          // maximum level of tree traversal is set to the value incremented with the current node depth\n          baseNode = dfItr.next((maxDepth = (afAPI.setMaxDepth(treeRoot.getDepth() + depthIncrement)))); // eslint-disable-line good-practices/no-single-usage-variable\n\n          _baseNode = baseNode;\n          while (_baseNode.getParent()) {\n            // The loop is added if the root of the tree is passed via attributes otherwise we could\n            // have done just by saving the reference in a variable.\n            _baseNode = _baseNode.getParent();\n          }\n          // traverse the tree and calculate effective node value\n          !config.valuesset && postOrderTraversal(_baseNode);\n          config.valuesset = true;\n          if (!attrs.showNavigationBar) {\n            if (_baseNode !== baseNode) {\n              btns.home.show();\n              btns.back.show();\n            } else {\n              btns.home.hide();\n              btns.back.hide();\n            }\n          } else {\n            btns.home.hide();\n            btns.back.hide();\n          }\n\n          smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);\n          smartLabel.setStyle((attrs._setStyle = {\n            fontSize: (attrs.labelFontSize || attrs.baseFontSize) + 'px',\n            fontFamily: (attrs.labelFont || attrs.baseFont),\n            lineHeight: (1.2 * (attrs.labelFontSize || attrs.baseFontSize)) + 'px'\n          }));\n          // Save the state in reflow conf\n          // reflowData.tree = baseNode;\n          backToParent = _intSR.backToParent; // eslint-disable-line good-practices/no-single-usage-variable\n          resetTree = _intSR.resetTree; // eslint-disable-line good-practices/no-single-usage-variable\n          chart.addJob('attachEventToBtns', function () {\n            chart._lastAttached.backToParent && btns.back &&\n            btns.back.removeEventListener('fc-click', chart._lastAttached.backToParent);\n\n            chart._lastAttached.resetTree && btns.home &&\n              btns.home.removeEventListener('fc-click', chart._lastAttached.resetTree);\n\n            chart._lastAttached.backToParent = backToParent.bind(baseNode);\n            chart._lastAttached.resetTree = resetTree.bind(baseNode);\n\n            btns.back && btns.back.addEventListener('fc-click', chart._lastAttached.backToParent);\n\n            btns.home && btns.home.addEventListener('fc-click', chart._lastAttached.resetTree);\n          }, priorityList.kdTree);\n\n          /**\n            * This function recursively draws the tree using depth first algorithm.\n            * @param node {TreeMap} - node to be drawn;\n            * @param drawingArea {Object} - ultimate drawing area of the node. By ultimate it means\n            *                              no more operation will be performed\n            */\n          (function rec (node, drawingArea) {\n            var nextNode,\n              _rect,\n              _textRect,\n              hotItem,\n              labelItem,\n              highlightItem,\n              textItem,\n              nodeDrawingArea,\n              rect,\n              textRect,\n              textConfObj,\n              textConf,\n              options = {},\n              label,\n              plotItem,\n              plotDetails = {},\n              evtFns = {},\n              hoverContextPointerName = HOVER,\n              cssConf = {},\n              colorDimension = BLANKSTRING, // eslint-disable-line good-practices/no-single-usage-variable\n              //   colorValue,\n              formattedValue,\n              formattedsValue;\n            // if there is no node or there is node value of node then skip drawing of that node\n            if (!node || !node.value) {\n              // break condition of recursive iteration\n              return;\n            }\n            formattedValue = numberFormatter.yAxis(node.getValue());\n            formattedsValue = numberFormatter.sYAxis(node.getColorValue());\n            node.setPath();\n            // cache the previous rectangular configurations for animating the rectangle.\n            _rect = node.rect || {};\n            _textRect = node.textRect || {};\n\n            rect = node.rect = {};\n            textRect = node.textRect = {};\n\n            // Get rectangle to draw the node\n            rect.width = drawingArea.width;\n            rect.height = drawingArea.height;\n            rect.x = drawingArea.x;\n            rect.y = drawingArea.y;\n\n            // Get the color and border configuration\n            cssConf = localColorProvider(node, UNDEF, dsStore.conf);\n            plotItem = node.plotItem;\n            // If plotItem exists, then its the interacted sub-tree which is updated with a\n            // different animations\n            if (plotItem) {\n              // dispose the graphic rectangle for the selected node.\n              rendererAPI.graphicPool(true, 'plotItem', plotItem, _rect);\n            }\n            node.__props || (node.__props = {});\n            node.__props.curr = Object.assign({}, rect);\n            node.__props.node = Object.assign({}, node);\n            plotItem = node.plotItem = drawRectFn(rect, Object.assign({}, cssConf, ((node.getColorValue() || node.getColorValue() === 0) && { fill: node.presentColor }) || {}), _rect, node.overAttr, node);\n            node.__props.prev = Object.assign({}, rect);\n            node.cssConf = cssConf;\n\n            // Get the configuration to draw text\n            textConfObj = getTextConf(node, rect);\n            textConf = textConfObj.conf;\n            // Offset that will be used to plot the children\n            options.textMargin = textConf.rectShiftY;\n            textRect = node.textRect = textConf.textRect;\n            // Get the normalized text\n            label = smartLabel.getSmartText(textConf.label, textRect.width, textRect.height).text; // eslint-disable-line good-practices/no-single-usage-variable\n\n            // Saves the reference so that the event listener can use it, and also useful for disposing.\n            node.plotItem = plotItem;\n            labelItem = node.labelItem;\n            if (labelItem) {\n              highlightItem = node.highlightItem;\n              rendererAPI.graphicPool(true, 'labelItem', labelItem, _rect);\n              rendererAPI.graphicPool(true, 'highlightItem', highlightItem, _rect);\n            } else {\n              _textRect = _textRect || {};\n            }\n            textItem = drawTextFn(label, textRect, {\n              textAttrs: textConfObj.attr,\n              highlightAttrs: textConfObj.highlight\n            }, _textRect, node.overAttr, node);\n\n            node.labelItem = textItem.label;\n            node.highlightItem = textItem.highlightMask;\n\n            // Save all the references so that it can be used as context\n            plotDetails.virginNode = node;\n            plotDetails.plotItem = plotItem;\n            plotDetails.textItem = textItem;\n            // Save circular reference for query\n            plotDetails.virginNode.dirtyNode = plotDetails;\n\n            if (node.getColorValue()) {\n              colorDimension = attrs.tooltipSeparationCharacter + formattedsValue;\n            }\n\n            if (attrs.showTooltip) {\n              plotDetails.toolText = parseTooltext(attrs.plotToolText, [1, 2, 3, 119, 122], {\n                label: node.getLabel(),\n                formattedValue: formattedValue,\n                formattedsValue: formattedsValue\n              }, {\n                value: node.getValue(),\n                svalue: node.getColorValue()\n              }) || node.getLabel() + attrs.tooltipSeparationCharacter + formattedValue + colorDimension;\n            } else {\n              plotDetails.toolText = BLANKSTRING;\n            }\n            plotDetails.rect = rect;\n\n            // @todo - the abstract event handler should come from algorithmAP\n            evtFns.hover = [function (forcedTracker) {\n              var elem = this,\n                parentElem,\n                targetElement,\n                virginNode,\n                hoverContext,\n                css,\n                maskRgba,\n                hoverMaskAlpha = 60; // eslint-disable-line good-practices/no-single-usage-variable\n\n              // Get the context if created or create a new one and get\n              hoverContext = context.getInstance(hoverContextPointerName); // eslint-disable-line good-practices/no-single-usage-variable\n              virginNode = elem.virginNode;\n\n              if (highlightParentsOnHover && !virginNode.next) {\n                // If all the sibling leaves to be hovered together attribute is set and\n                // the node is really a leaf\n                parentElem = virginNode.getParent();\n                targetElement = parentElem || virginNode;\n              } else {\n                // Set hover effect on the child itself\n                targetElement = elem.virginNode;\n              }\n\n              // Set it on context\n              hoverContext.set('element', targetElement);\n\n              css = targetElement.cssConf; // eslint-disable-line good-practices/no-single-usage-variable\n              maskRgba = convertColor(getLightColor(css.fill, 80), hoverMaskAlpha); // eslint-disable-line good-practices/no-single-usage-variable\n              forcedTracker.attr({ 'fill': maskRgba });\n\n              mouseoverEvtImpl(this);\n            }.bind(plotDetails), function (tracker) {\n              var hoverContext,\n                targetElement,\n                fill,\n                unmaskRgba,\n                hoverMaskAlpha = 0; // eslint-disable-line good-practices/no-single-usage-variable\n\n              // Get the context, which is most definitely created during the mouseover\n              hoverContext = context.getInstance(hoverContextPointerName); // eslint-disable-line good-practices/no-single-usage-variable\n              targetElement = hoverContext.get('element') || {};\n\n              fill = targetElement.cssConf && targetElement.cssConf.fill; // eslint-disable-line good-practices/no-single-usage-variable\n              unmaskRgba = convertColor(fill || '#fff', hoverMaskAlpha); // eslint-disable-line good-practices/no-single-usage-variable\n              tracker.attr({ 'fill': unmaskRgba });\n\n              mouseoutEvtImpl(this);\n            }.bind(plotDetails)];\n\n            evtFns.tooltip = [plotDetails.toolText];\n\n            evtFns.click = [function () {\n              clickEvtImpl(this, baseNode);\n            }.bind(plotDetails)];\n\n            hotItem = node.hotItem;\n            if (hotItem) {\n              rendererAPI.graphicPool(true, 'hotItem', hotItem, _rect);\n            }\n\n            // hotItem = node.hotItem = drawHotFn(plotDetails, evtFns);\n            trackerConfig.push({\n              node: node,\n              key: 'hotItem',\n              plotDetails: plotDetails,\n              evtFns: evtFns,\n              callback: drawHotFn\n            });\n            // Get the next node which will be plotted\n            nextNode = dfItr.next(maxDepth);\n            nodeDrawingArea = getNextAreaBase(nextNode, postNodeFetcher, options); // eslint-disable-line good-practices/no-single-usage-variable\n            // Recursively call the same function to draw the tree\n            rec(nextNode, nodeDrawingArea);\n          })(baseNode, canvasMeasurement);\n        }\n      },\n\n      'squarified': {\n        // eslint-disable-next-line good-practices/no-function-dependency\n        orderNodes: function () {\n          // eslint-disable-next-line good-practices/no-function-dependency\n          return this.sort(function (m, n) {\n            return parseFloat(m.value, 10) < parseFloat(n.value, 10) ? 1 : -1;\n          });\n        },\n\n        /**\n          * Provides a more managed way to calculate space for child.\n          * This takes minimum space configuration and applies it over all the subsequent calculation\n          * @param {Integer} horizontalPadding  - space between parent and child in x direction\n          * @param {Integer} verticalPadding  - space between parent and child in y direction\n          * @return {Function} - A function to be called, everytime space for a new node needs\n          *                      to be calculated\n          */\n        areaBaseCalculator: function (horizontalPadding, verticalPadding) { // eslint-disable-line good-practices/no-function-dependency\n          var sx = horizontalPadding, sy = verticalPadding;\n\n          /**\n            * Provides the basic information of the tree so that the current node can use that and\n            * calculate the space\n            * @param {TreeNode} nodes - node which is the subject to calculation\n            * @param {Function} posOffsetApplyFn - logic of calculation. This function is called with meta\n            *       information, immediate left sibling (if any) and parent. The context of this function\n            *       is changed with the one which is subject to calculation.\n            * @param {Object} options - provides additional options to the calculation.\n                                      Something like space for label.\n            * @return {Object} - returns what ever posOffsetApplyFn returns.\n            */\n          return function (nodes, posOffsetApplyFn, options) {\n            var parent,\n              meta = {},\n              eHeight,\n              eWidth,\n              textMargin = 0,\n              negSpacesY = 0,\n              anyNode,\n              parentRect;\n\n            if (!nodes || nodes.length === 0) {\n              return;\n            }\n\n            if (options) {\n              textMargin = options.textMargin || textMargin;\n            }\n\n            negSpacesY = textMargin;\n\n            anyNode = nodes[0];\n            parent = anyNode.getParent();\n\n            if (parent) {\n              parentRect = parent.rect;\n              // Calculate the width and hight of the space where children will be drawn.\n              // This ideally depend on the space that was passed when the outer most\n              // function was called\n              eHeight = parentRect.height - (2 * sy) - negSpacesY;\n              eWidth = parentRect.width - (2 * sx);\n\n              /*\n                             * This is the inner logical rectangle where the child is drawn.\n                             * If horizontalPadding and verticalPadding is zero\n                             * it is as same as the outermost rectangle. Something like\n                             *\n                             *  Parent rect\n                             *  -----------------------\n                             * |  verticalPadding     s|\n                             * |  ------------------- p|\n                             * | | effective rect    |a|\n                             * | | where child will  |c|\n                             * | | be drawn          |e|\n                             * | |                   |x|\n                             */\n              meta.effectiveRect = {\n                height: eHeight,\n                width: eWidth,\n                x: parentRect.x + sx,\n                y: parentRect.y + sy + negSpacesY\n              };\n              meta.effectiveArea = eHeight * eWidth;\n\n              return posOffsetApplyFn.call(anyNode, meta, parent);\n            }\n            // If parent is not present the it is the root node. For root node use the original\n            // canvas area. If parent is not present there is also no chance to have siblings\n            // of the node. Since there can only be only one root node\n            return null;\n          };\n        },\n\n        /**\n          * The squarified algorithm is a recursive way to find the best aspect ratio of a node, given an\n          * incremental state. Here we create layouts based on the aspect ratio of parent container.\n          * Inside this layout the rects are placed one by one and is checked for best aspect ratio.\n          * If at any given state the aspect ratio of a node increases than what it had before\n          * the layout manager restores the previous state.\n          * Here layout means the rectanglular plot inside which the new nodes are contained.\n          */\n        layoutManager: (function () { // eslint-disable-line good-practices/no-function-dependency\n          /**\n            * Creates a new layout depending on the value of width and height of the available area.\n            */\n          class RowLayout {\n            /**\n              * constructor\n              * @param {Object} root - parent rectangle of the current layout\n              * @param {Integer} totalValue - total value of the parent which will be set in denominator\n              *                               and is used when the plot assignment happens.\n              */\n            constructor (root, totalValue) {\n              this.totalValue = totalValue;\n              this._rHeight = root.height;\n              this._rWidth = root.width;\n              this._rx = root.x;\n              this._ry = root.y;\n              this._rTotalArea = root.height * root.width;\n              // Nodes which are placed in the current layout\n              this.nodes = [];\n              // Previous aspect ratio before the last node is added in the layout\n              this._prevAR = UNDEF;\n\n              if (this._rHeight < this._rWidth) {\n                // If the height of parent rectangle is larger than the width then the layout is\n                // formed in vertical direction.\n                this._hSegmented = true;\n              }\n            }\n            /**\n              * Adds node the current layout then calculates and compares the aspect ratio.\n              * @param {TreeNode} nodeObj  - node to be added in the current layout\n              * @return {TreeNode | boolean} - if the new layout (affter addition of node) is not stable\n              *                              (aspect ratio is more than the last one) return false, otherwise\n              *                              return the last added node\n              */\n            addNode (nodeObj) {\n              var node = nodeObj,\n                totalArea = this._rTotalArea, area, // eslint-disable-line good-practices/no-single-usage-variable\n                ratio,\n                width,\n                height,\n                i, len, length,\n                snVal, snArea, snHeight, snWidth,\n                rect,\n                _hSegmented = this._hSegmented,\n                _x = this._rx, _y = this._ry,\n                _nextX, _nextY,\n                _rect,\n                remainingHeight, remainingWidth,\n                maxSide, minSide,\n                aspectRatio,\n                valueSoFar = 0,\n                cRect;\n\n              // Push node in the current layout to calculate the current aspect ratio and to determine\n              // whether it is larger than the previous one;\n              this.nodes.push(node);\n\n              for (i = 0, length = this.nodes.length; i < length; i++) {\n                // The numeraic value of all the nodes which are in the layout stack currently.\n                // Using this we can calculate the assignment of area of the complete layout stack unit.\n                valueSoFar += parseFloat(this.nodes[i].getValue(), 10);\n              }\n\n              ratio = valueSoFar / this.totalValue; // eslint-disable-line good-practices/no-single-usage-variable\n              area = totalArea * ratio;\n\n              if (_hSegmented) {\n                // If width is greater than height of the parent rectangle, make vertical segmentation,\n                // since we can reach close to 1 aspect ratio in this way\n                height = this._rHeight;\n                width = area / height;\n                // Next point from where the next layout will be laid out\n                _nextX = _x + width;\n                _nextY = _y;\n\n                // Remaining area for after the current layout is laid\n                remainingHeight = this._rHeight;\n                remainingWidth = this._rWidth - width;\n              } else {\n                // If width is less than height of the parent rectangle, make horizontal segmentation,\n                // since we can reach close to 1 aspect ratio in this way\n                width = this._rWidth;\n                height = area / width;\n                // Next point from where the next layout will be laid out\n                _nextX = _x;\n                _nextY = _y + height;\n\n                // Remaining area for after the current layout is laid\n                remainingHeight = this._rHeight - height;\n                remainingWidth = this._rWidth;\n              }\n\n              for (i = 0, len = this.nodes.length; i < len; i++) { // eslint-disable-line good-practices/no-single-usage-variable\n                node = this.nodes[i];\n                snVal = node.getValue();\n                // Proportional area inside the layout\n                snArea = snVal / valueSoFar * area;\n\n                // Keeps reference to the measurement of previous rect so that in case the aspect ratio\n                // is smaller than the previous one, we can restore the state\n                node.hRect = node.rect || {};\n                node._hRect = node._rect || {};\n\n                // Holds information of the current rect\n                rect = node.rect = {};\n                if (_hSegmented) {\n                  rect.width = snWidth = width;\n                  rect.height = snHeight = snArea / snWidth;\n                  rect.x = _x;\n                  rect.y = _y;\n\n                  _y += snHeight;\n                } else {\n                  rect.height = snHeight = height;\n                  rect.width = snWidth = snArea / snHeight;\n                  rect.x = _x;\n                  rect.y = _y;\n\n                  _x += snWidth;\n                }\n\n                // Calculates the aspect ratio\n                maxSide = Math.max(rect.height, rect.width);\n                minSide = Math.min(rect.height, rect.width);\n\n                // aspectratio can be infinity if minSide is zero. Incase, it is infinite, change it to 0\n                aspectRatio = maxSide / minSide;\n                !isFinite(aspectRatio) && (aspectRatio = 0);\n                node.aspectRatio = aspectRatio;\n              }\n\n              if (this.nodes.length > 1) {\n                if (this.prevAR < node.aspectRatio) {\n                  // If the previous aspect ratio is less than the current one, we infer the\n                  // old layout is more stable. Hence we restore to the previous state.\n                  this.nodes.pop().rect = {};\n                  for (i = 0, length = this.nodes.length; i < length; i++) {\n                    // Restore all the newly calculated rect to the previous one.\n                    if (length === 1 && this.nodes[i].firstPassed) {\n                      this.nodes[i].rect = this.nodes[i]._hRect;\n                    } else {\n                      this.nodes[i].rect = this.nodes[i].hRect;\n                    }\n                    _rect = this.nodes[i]._rect = {};\n                    cRect = this.nodes[i].rect;\n                    _rect.width = cRect.width;\n                    _rect.height = cRect.height;\n                    _rect.x = cRect.x;\n                    _rect.y = cRect.y;\n                  }\n                  // Forcefully return false to inform the caller that the old layout was stable and\n                  // the system has restored from the new state to the old state\n                  return false;\n                }\n              } else {\n                if (node) {\n                  _rect = node._rect = {};\n                  cRect = node.rect;\n                  _rect.width = cRect.width;\n                  _rect.height = cRect.height;\n                  _rect.x = cRect.x;\n                  _rect.y = cRect.y;\n\n                  node.firstPassed = true;\n                }\n              }\n\n              this.prevAR = node.aspectRatio;\n\n              this.height = height;\n              this.width = width;\n\n              /**\n                * Provides the measurement of the remaining area for the next layout to be laid out.\n                * @return {Object} - {\n                *      height: {Integer},\n                *      width: {Integer},\n                *      x: {Integer},\n                *      y: {Integer},\n                * }\n                */\n              this.getNextLogicalDivision = function () {\n                return {\n                  height: remainingHeight,\n                  width: remainingWidth,\n                  x: _nextX,\n                  y: _nextY\n                };\n              };\n              // Keep on returning the node last added if the layout is stable\n              return node;\n            }\n          }\n          return {\n            RowLayout: RowLayout\n          };\n        })(),\n\n        /*\n          * Initializes the state required when the legend is dragged and effect to be applied\n          * @param overrideEffect {Object} - style to be applied in key-value pair\n          * @param rangeOutFn {Function} - Function to be executed when outliers are found\n          * @return {Function} - Control function that operates on outliers by adjusting the range\n          */\n        applyShadeFiltering: function (bucketInstance, overrideEffect, rangeOutFn) { // eslint-disable-line good-practices/no-function-dependency\n          bucketInstance.setRangeOutEffect(overrideEffect, rangeOutFn);\n\n          this.applyShadeFiltering.reset = function () {\n            bucketInstance.resetPointers();\n          };\n\n          /*\n            * Control the effect to be executed on outliers.\n            * @param limits {Object} - an simple javascript object containing the start and end limit of\n            *                          the legend\n            */\n          return function (limits) {\n            bucketInstance.moveLowerShadePointer(limits.start);\n            bucketInstance.moveHigherShadePointer(limits.end);\n          };\n        },\n\n        drawTree: function (algorithmAPI, dsStore, canvasMeasurement, rendererAPI) {\n          var treeRoot = this,\n            chart = dsStore.getFromEnv('chart'),\n            config = dsStore.getFromEnv('chartConfig'),\n            trackerConfig = config.trackerConfig || (config.trackerConfig = []), // eslint-disable-line good-practices/no-single-usage-variable\n            numberFormatter = dsStore.getFromEnv('number-formatter'),\n            btns = dsStore.getFromEnv('toolbarBtns'),\n            labelPadding = { // eslint-disable-line good-practices/no-single-usage-variable\n              x: 5,\n              y: 5\n            },\n            lineHeight,\n            xShift = canvasMeasurement.horizontalPadding, // eslint-disable-line good-practices/no-single-usage-variable\n            yShift = canvasMeasurement.verticalPadding, // eslint-disable-line good-practices/no-single-usage-variable\n            getNextAreaBase = algorithmAPI.areaBaseCalculator(xShift, yShift), // eslint-disable-line good-practices/no-single-usage-variable\n            RowLayout = algorithmAPI.layoutManager.RowLayout,\n            smartLabel = dsStore.getFromEnv('smartLabel'),\n            drawRectFn = rendererAPI.drawRect, // eslint-disable-line good-practices/no-single-usage-variable\n            drawTextFn = rendererAPI.drawText, // eslint-disable-line good-practices/no-single-usage-variable\n            drawHotFn = rendererAPI.drawHot, // eslint-disable-line good-practices/no-single-usage-variable\n            iterator = afAPI.iterator, // eslint-disable-line good-practices/no-single-usage-variable\n            itr = iterator(treeRoot), // eslint-disable-line good-practices/no-single-usage-variable\n            bfItr = itr.bf, // eslint-disable-line good-practices/no-single-usage-variable\n            baseNode,\n            attrs = dsStore.conf,\n            highlightParentsOnHover = attrs.highlightParentsOnHover, // eslint-disable-line good-practices/no-single-usage-variable\n            getTextConf,\n            context = afAPI.context,\n            colorRange = dsStore.conf.colorRange, // eslint-disable-line good-practices/no-single-usage-variable\n            localColorProvider = afAPI.mapColorManager(attrs, colorRange), // eslint-disable-line good-practices/no-single-usage-variable\n            abstractEvtReg = afAPI.abstractEventRegisterer(algorithmAPI, dsStore, canvasMeasurement, rendererAPI),\n            clickEvtImpl = abstractEvtReg.click, // eslint-disable-line good-practices/no-single-usage-variable\n            mouseoverEvtImpl = abstractEvtReg.mouseover, // eslint-disable-line good-practices/no-single-usage-variable\n            mouseoutEvtImpl = abstractEvtReg.mouseout, // eslint-disable-line good-practices/no-single-usage-variable\n            _baseNode,\n            _intSR = chart._intSR,\n            backToParent,\n            resetTree,\n            visController = afAPI.visibilityController,\n            stateContextId = CLICKEDSTATE, // eslint-disable-line good-practices/no-single-usage-variable\n            visibleState = VISIBLEROOT, // eslint-disable-line good-practices/no-single-usage-variable\n            stateContext,\n            clickedState,\n            csNode;\n\n          stateContext = context.getInstance(stateContextId); // eslint-disable-line good-practices/no-single-usage-variable\n          clickedState = stateContext.get(visibleState) || {};\n          csNode = clickedState.node;\n\n          if (clickedState.node && clickedState.state) {\n            if (clickedState.state.toLowerCase() === DRILLUP) {\n              if (csNode instanceof Array) {\n                visController.controlPreAnimVisibility(csNode[0].virginNode, csNode[1]);\n              } else {\n                visController.controlPreAnimVisibility(csNode.virginNode);\n              }\n            } else {\n              visController.displayAll(clickedState.node.virginNode);\n            }\n          }\n\n          lineHeight = attrs.parentLabelLineHeight; // eslint-disable-line good-practices/no-single-usage-variable\n          getTextConf = afAPI.initConfigurationForlabel(labelPadding, lineHeight, attrs); // eslint-disable-line good-practices/no-single-usage-variable\n\n          // Get the root node\n          // maximum level of tree traversal is set to the value incremented with the current node depth\n          baseNode = bfItr.next((maxDepth = (afAPI.setMaxDepth(treeRoot.getDepth() + depthIncrement))));\n\n          _baseNode = baseNode;\n          while (_baseNode.getParent()) {\n            _baseNode = _baseNode.getParent();\n          }\n          // traverse the tree and calculate effective node value\n          !config.valuesset && postOrderTraversal(_baseNode);\n          config.valuesset = true;\n          if (!attrs.showNavigationBar) {\n            if (_baseNode !== baseNode) {\n              btns.home.show();\n              btns.back.show();\n            } else {\n              btns.home.hide();\n              btns.back.hide();\n            }\n          } else {\n            btns.home.hide();\n            btns.back.hide();\n          }\n\n          smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);\n          smartLabel.setStyle((attrs._setStyle = {\n            fontSize: (attrs.labelFontSize || attrs.baseFontSize) + 'px',\n            fontFamily: (attrs.labelFont || attrs.baseFont),\n            lineHeight: (1.2 * (attrs.labelFontSize || attrs.baseFontSize)) + 'px'\n          }));\n\n          // Save the state in reflow conf\n          // reflowData.tree = baseNode;\n          backToParent = _intSR.backToParent; // eslint-disable-line good-practices/no-single-usage-variable\n          resetTree = _intSR.resetTree; // eslint-disable-line good-practices/no-single-usage-variable\n          chart.addJob('attachEventToBtns', function () {\n            chart._lastAttached.backToParent && btns.back &&\n              btns.back.removeEventListener('fc-click', chart._lastAttached.backToParent);\n\n            chart._lastAttached.resetTree && btns.home &&\n              btns.home.removeEventListener('fc-click', chart._lastAttached.resetTree);\n\n            chart._lastAttached.backToParent = backToParent.bind(baseNode);\n            chart._lastAttached.resetTree = resetTree.bind(baseNode);\n\n            btns.back && btns.back.addEventListener('fc-click', chart._lastAttached.backToParent);\n\n            btns.home && btns.home.addEventListener('fc-click', chart._lastAttached.resetTree);\n          }, priorityList.kdTree);\n          /*\n            * This function recursively draws the tree using breadth first algorithm.\n            * @param node {TreeMap} - node to be drawn;\n            * @param drawingArea {Object} - ultimate drawing area of the node. By ultimate it means\n            *                              no more operation will be performed\n            */\n          (function rec (node, drawingArea) {\n            var rect,\n              _rect = {},\n              highlightItem,\n              hotItem,\n              labelItem,\n              _textRect,\n              textRect,\n              nextNodes,\n              textItem,\n              index,\n              length,\n              totalValPlotted = 0, // eslint-disable-line good-practices/no-single-usage-variable\n              bfsQueue,\n              bfsNode,\n              plotItem,\n              textConf,\n              label,\n              options = {},\n              textConfObj,\n              plotDetails = {},\n              evtFns = {},\n              hoverContextPointerName = HOVER,\n              cssConf = {},\n              colorDimension = BLANKSTRING, // eslint-disable-line good-practices/no-single-usage-variable\n              //   colorValue,\n              formattedValue,\n              formattedsValue;\n            // if there is no node or there is node value of node then skip drawing of that node\n            if (!node || !node.value) {\n              return;\n            }\n            formattedValue = numberFormatter.yAxis(node.getValue());\n            formattedsValue = numberFormatter.sYAxis(node.getColorValue());\n            node.setPath();\n            // cache the previous rectangular configurations for animating the rectangle.\n            rect = node.__initRect;\n            if (rect) {\n              _rect.x = rect.x;\n              _rect.y = rect.y;\n              _rect.width = rect.width;\n              _rect.height = rect.height;\n            }\n            _textRect = node.textRect || {};\n\n            rect = (node.rect = node.__initRect = {});\n            textRect = (node.textRect = {});\n\n            // Get rectangle to draw the node\n            rect.width = drawingArea.width;\n            rect.height = drawingArea.height;\n            rect.x = drawingArea.x;\n            rect.y = drawingArea.y;\n\n            // Draws the rectangle\n            cssConf = localColorProvider(node, UNDEF, dsStore.conf);\n            // plotItem = drawRectFn(rect, cssConf);\n            plotItem = node.plotItem;\n            // If plotItem exists, then its the interacted sub-tree which is updated with a\n            // different animations\n            if (plotItem) {\n              // dispose the graphic rectangle for the selected node.\n              rendererAPI.graphicPool(true, 'plotItem', plotItem, _rect);\n            }\n            node.__props || (node.__props = {});\n            node.__props.curr = Object.assign({}, rect);\n            node.__props.node = Object.assign({}, node);\n            plotItem = node.plotItem = drawRectFn(rect, Object.assign({}, cssConf, ((node.getColorValue() || node.getColorValue() === 0) && { fill: node.presentColor }) || {}), _rect, node.overAttr, node);\n            node.__props.prev = Object.assign({}, rect);\n            node.cssConf = cssConf;\n\n            // Get the configuration to draw text\n            textConfObj = getTextConf(node, rect);\n            textConf = textConfObj.conf;\n\n            // Offset that will be used to plot the children\n            options.textMargin = textConf.rectShiftY;\n            textRect = node.textRect = textConf.textRect;\n            // Get the normalized text\n            label = smartLabel.getSmartText(textConf.label, textRect.width, textRect.height).text; // eslint-disable-line good-practices/no-single-usage-variable\n            labelItem = node.labelItem;\n\n            if (labelItem) {\n              highlightItem = node.highlightItem;\n              rendererAPI.graphicPool(true, 'labelItem', labelItem, _rect);\n              rendererAPI.graphicPool(true, 'highlightItem', highlightItem, _rect);\n            } else {\n              _textRect = _textRect || {};\n            }\n            textItem = drawTextFn(label, textRect, {\n              textAttrs: textConfObj.attr,\n              highlightAttrs: textConfObj.highlight\n            }, _textRect, node.overAttr, node);\n\n            node.labelItem = textItem.label;\n            node.highlightItem = textItem.highlightMask;\n\n            // Saves the reference so that the event listener can use it\n            node.plotItem = plotItem;\n\n            // Save all the references so that it can be used as context\n            plotDetails.virginNode = node;\n            plotDetails.plotItem = plotItem;\n            plotDetails.textItem = textItem;\n            // Save circular reference for query\n            plotDetails.virginNode.dirtyNode = plotDetails;\n\n            if (node.getColorValue()) {\n              colorDimension = attrs.tooltipSeparationCharacter + formattedsValue;\n            }\n\n            if (attrs.showTooltip) {\n              plotDetails.toolText = parseTooltext(attrs.plotToolText, [1, 2, 3, 119, 122], {\n                label: node.getLabel(),\n                formattedValue: formattedValue,\n                formattedsValue: formattedsValue\n              }, {\n                value: node.getValue(),\n                svalue: node.getColorValue()\n              }) || node.getLabel() + attrs.tooltipSeparationCharacter + formattedValue + colorDimension;\n            } else {\n              plotDetails.toolText = BLANKSTRING;\n            }\n\n            plotDetails.rect = rect;\n\n            evtFns.hover = [function (targetElementNew) {\n              var elem = this,\n                parentElem,\n                targetElement,\n                virginNode,\n                hoverContext,\n                css,\n                maskRgba,\n                hoverMaskAlpha = 60; // eslint-disable-line good-practices/no-single-usage-variable\n\n              // Get the context if created or create a new one and get\n              hoverContext = context.getInstance(hoverContextPointerName); // eslint-disable-line good-practices/no-single-usage-variable\n              virginNode = elem.virginNode;\n\n              if (highlightParentsOnHover && !virginNode.next) {\n                // If all the sibling leaves to be hovered together attribute is set and\n                // the node is really a leaf\n                parentElem = virginNode.getParent();\n                targetElement = parentElem || virginNode;\n              } else {\n                // Set hover effect on the child itself\n                targetElement = elem.virginNode;\n              }\n\n              // Set it on context\n              hoverContext.set('element', targetElement);\n\n              css = targetElement.cssConf;\n              maskRgba = convertColor(css.fill && getLightColor(css.fill, 80), hoverMaskAlpha); // eslint-disable-line good-practices/no-single-usage-variable\n              // targetElement.plotItem.tracker.attr({'fill' : maskRgba});\n              targetElementNew.attr({ 'fill': maskRgba });\n              mouseoverEvtImpl(this);\n            }.bind(plotDetails), function (targetElementNew) {\n              var hoverContext,\n                targetElement,\n                fill,\n                unmaskRgba,\n                hoverMaskAlpha = 0; // eslint-disable-line good-practices/no-single-usage-variable\n\n              // Get the context, which is most definitely created during the mouseover\n              hoverContext = context.getInstance(hoverContextPointerName); // eslint-disable-line good-practices/no-single-usage-variable\n              targetElement = hoverContext.get('element') || {}; // eslint-disable-line good-practices/no-single-usage-variable\n\n              fill = targetElement.cssConf && targetElement.cssConf.fill; // eslint-disable-line good-practices/no-single-usage-variable\n              unmaskRgba = convertColor(fill || '#fff', hoverMaskAlpha); // eslint-disable-line good-practices/no-single-usage-variable\n              // targetElement.plotItem.tracker.attr({'fill' : unmaskRgba});\n              targetElementNew.attr({ 'fill': unmaskRgba });\n              mouseoutEvtImpl(this);\n            }.bind(plotDetails)];\n\n            evtFns.tooltip = [plotDetails.toolText];\n\n            evtFns.click = [function () {\n              clickEvtImpl(this, baseNode);\n            }.bind(plotDetails)];\n\n            hotItem = node.hotItem;\n            if (hotItem) {\n              rendererAPI.graphicPool(true, 'hotItem', hotItem, _rect);\n            }\n\n            // hotItem = node.hotItem = drawHotFn(plotDetails, evtFns);\n            trackerConfig.push({\n              node: node,\n              key: 'hotItem',\n              plotDetails: plotDetails,\n              evtFns: evtFns,\n              callback: drawHotFn\n            });\n\n            // Get the next level (if it was in level n, the following function returns node of  n+1\n            // level) of nodes which belongs to this parent\n            nextNodes = (maxDepth !== UNDEF) ? ((node.getDepth() >= maxDepth) ? UNDEF\n              : node.getChildren()) : node.getChildren();\n            if (!nextNodes) {\n              // If its a leaf node, no further level is possible hence return\n              return;\n            }\n\n            // Get the nodes of next level which stable rect information. Which we canuse to call this\n            // function recursively to draw the complete tree\n            bfsQueue = getNextAreaBase(nextNodes, function (meta, parent) {\n              var row,\n                nodeLimit,\n                nodeIndex = 0,\n                node, // eslint-disable-line\n                layout,\n                nextDiv,\n                queue = [];\n\n              // Logically create a new layout\n              row = new RowLayout({\n                width: meta.effectiveRect.width,\n                height: meta.effectiveRect.height,\n                x: meta.effectiveRect.x,\n                y: meta.effectiveRect.y\n              }, parent.getValue());\n\n              nodeLimit = nextNodes.length; // eslint-disable-line good-practices/no-single-usage-variable\n\n              while (true) {\n                if (nodeIndex++ === nodeLimit) {\n                  break;\n                }\n\n                node = nextNodes[nodeIndex - 1];\n                // Adds node in the layout to calculate the stability\n                layout = row.addNode(node);\n\n                if (layout === false) {\n                  // The current layout is not stable. The layoutManager has already reverted the\n                  // changes. Get the remaining logical division so that a new layout is laid\n                  nextDiv = row.getNextLogicalDivision();\n                  // Create a new layout\n                  row = new RowLayout(nextDiv, parent.getValue() - totalValPlotted);\n                  nodeIndex--;\n                } else {\n                  // Layout is stable, adds it in the queue\n                  totalValPlotted += parseFloat(node.getValue(), 10);\n                  queue.push(node);\n                }\n              }\n\n              return queue;\n            }, options);\n            for (index = 0, length = bfsQueue.length; index < length; index++) { // eslint-disable-line good-practices/no-single-usage-variable\n              // For all nodes of level n andd common parent, call this function recursively\n              bfsNode = bfsQueue[index];\n              rec(bfsNode, bfsNode.rect);\n            }\n          })(baseNode, canvasMeasurement);\n        }\n      }\n    };\n\n    /**\n      * Gives the full implementation of the AbstractTreeMaker. Ususally AbstractTreeMaker can be used directly\n      * if the ordering is not intended. The more specific version of the treemap needs to have ordering of\n      * nodes. TreeMaker at this movement only give that implementation.\n      */\n    class TreeMaker extends AbstractTreeMaker {\n      /**\n       * Provides the name of the chart extension\n       *\n       * @static\n       * @return {string} The name of the chart extension\n       */\n      static getName () {\n        return 'TreeMaker';\n      }\n\n      /**\n        * Provides the order of the node. This order is algorithm specific. This function acts as a bridge to pass\n        * the ordering logic from algorithm to AbstractTreeMaker. This is called from AbstractTreeMaker only.\n        * @param {Array.<TreeNode>} children  - array of children at a praticular level for a particular parent.\n        */\n      // eslint-disable-next-line\n      order (children) {\n        var algorithmAPI = algo[algorithm],\n          orderNodeFn = algorithmAPI.orderNodes;\n        if (orderNodeFn) {\n          return orderNodeFn.apply(children, [algorithmAPI]);\n        }\n        return children;\n      }\n    }\n\n    /**\n      * Initialize the algorithm factory by passing information regarding the algorithm.\n      * @param {string} algoName  - name of the algorithm\n      * @param {boolean} flag  - flag to inform treemaker whether it should form bucket of the leaf nodes.\n      *                      Enable this if the legend is used\n      * @param {number | undefined} permitterDepth  - The maximum depth of visual that can be seen in the tree at once\n      * @return {Object} API for algo [squarified or sliceanddice]\n      */\n    function init (algoName, flag, permitterDepth) {\n      algorithm = algoName; // eslint-disable-line good-practices/no-single-usage-variable\n      bucketIterationMode = flag;\n      depthIncrement = (afAPI.setMaxDepth(permitterDepth));\n\n      return algo[algorithm];\n    }\n\n    /**\n      * Takes the syle and operation to be applied / performed on the outliers if the legend is dragged.\n      * @param {Object} css - key-value pair of the style to be applied on the outliers. Where the key is the\n      *                      name of the syle (like fill, stroke-width) and value is the value associated.\n      * @param {Function} shadeOutFN - function to be executed once new outliers are found. For every outliers\n      *                              this function is called once\n      * @return {Function} - a function that sets the range if legend is dragged to find the outliers. After\n      *                      finding out the new outliers it executes the shadeOutFN on it function.\n      */\n    function applyShadeFiltering (css, shadeOutFN) {\n      var algorithmAPI = algo[algorithm], // eslint-disable-line good-practices/no-single-usage-variable\n        args,\n        shadeFilter;\n\n      // Initializes the filter\n      shadeFilter = algorithmAPI.applyShadeFiltering(treeMaker.getBucket(), css, shadeOutFN); // eslint-disable-line good-practices/no-single-usage-variable\n\n      // Sets the range, find the outliers and apply / perform operation on them.\n      return function (limits) {\n        // Modifies the argument object to send it to the filter implementation. As part of the modification\n        // it pushes the limit in front of the argument object so that it become the first argument.\n        args = Array.prototype.slice.call(arguments, 0);\n        args.unshift(limits);\n        shadeFilter.apply(treeMaker.getBucket(), args);\n      };\n    }\n\n    /**\n      * Create tree from the data given. It requires a root to start with.\n      * @param  {Object}   nodes       - the configuration object of FusionCharts\n      * @param  {Function} cleansingFn - function to get the number formatted values.\n      * @param  {boolean}  update      - whether it is update state or not\n      * @return {TreeNode}             - the root of the newly prepared tee\n      */\n    function makeTree (nodes, cleansingFn, update) {\n      // todo cleansingFn should be defined when called from addData to get the number formatted values.\n      var tempTree;\n      treeMaker = new TreeMaker(nodes, bucketIterationMode, cleansingFn); // eslint-disable-line good-practices/no-single-usage-variable\n      tempTree = treeMaker.get();\n\n      if (update !== false) {\n        tree = tempTree;\n      }\n      afAPI.setVisibleRoot(tempTree);\n      return tempTree;\n    }\n\n    /**\n      * Prepares all the arguments and call the draw function of the algorithm in use.\n      * This function can not be called from outside and needs another function to return it after making\n      * use of initialization parameter and setting up all the algorithm related preprocessing.\n      */\n    function plotTree () {\n      var algorithmAPI = algo[algorithm],\n        args;\n      // initialise the realTimeModule with the configurations for drawing the nodes.\n      algorithmFactory.realTimeUpdate = realTimeUpdate.apply(this, arguments);\n      // Prepares the arguments\n      args = Array.prototype.slice.call(arguments, 0);\n      args.unshift(algorithmAPI);\n\n      // Calls the draw function of the algorithm\n      algorithmAPI.drawTree.apply(afAPI.getVisibleRoot(), args);\n    }\n    /**\n      * Adds or deletes the nodes dynamically to the chart.\n      * @return {Function} - fn to handle realtime data update\n      */\n    function realTimeUpdate () {\n      // Initialise the function with the drawing area and rendering API.\n      var rendererAPI,\n        args,\n        algorithmAPI = algo[algorithm];\n\n      // Prepares the arguments\n      args = Array.prototype.slice.call(arguments, 0);\n      args.unshift(algorithmAPI);\n      rendererAPI = args.slice(-1)[0]; // eslint-disable-line good-practices/no-single-usage-variable\n      return function () {\n        // modifier can be either for add or delete.\n        var _args = Array.prototype.slice.call(arguments, 0),\n          _getCleanValue = _args.shift(), // eslint-disable-line good-practices/no-single-usage-variable\n          // modifier determines if to add or delete the nodes/ subTree.\n          modifier = _args.shift(), // eslint-disable-line good-practices/no-single-usage-variable\n          // eslint-disable-next-line good-practices/no-function-dependency\n          api = treeOpt(tree, function (visibleRoot) { // eslint-disable-line good-practices/no-single-usage-variable\n            // Calls the draw function of the algorithm. Attached as a callback.\n            algorithmAPI.drawTree.apply(visibleRoot || tree, args);\n          }, rendererAPI, _getCleanValue);\n        // api to add or delete the nodes from the tree.\n        api[modifier].apply(this, _args);\n      };\n    }\n\n    /**\n      * Forcefully set the root of the tree. Try not to use it as this function was only created to keep state\n      * over successive call of renderer.\n      * @param {TreeNode} base - the root of the newly prepared tee\n      * @return {TreeNode}     - the root of the newly prepared tee\n      */\n    function setTreeBase (base) {\n      return (base && (tree = base));\n    }\n\n    /**\n      * Initermediate bridge function that performs the tree making operation and drawing area assignment.\n      * @param {Object}   nodes - the root of the newly prepared tee\n      * @param {Function} cleansingFn - function to return valid number or null if the value is invalid\n      * @return {Function} - returns plotTree to call the draw the function of the algorithm\n      */\n    function plotOnCanvas (nodes, cleansingFn) {\n      tree = makeTree(nodes, cleansingFn);\n      //   drawingAreaMeasurement = drawingArea;\n      return plotTree;\n    }\n\n    // AlgorithmFactory API\n    algorithmFactory.init = init;\n    algorithmFactory.plotOnCanvas = plotOnCanvas;\n    algorithmFactory.applyShadeFiltering = applyShadeFiltering;\n    algorithmFactory.setTreeBase = setTreeBase;\n    algorithmFactory.realTimeUpdate = realTimeUpdate;\n    algorithmFactory.makeTree = makeTree;\n\n    return algorithmFactory;\n  },\n  /*\n   * Does the additons / deletion operations on the tree\n  */\n  treeOpt = function (baseNode, drawTreeFn, rendererAPI, _getCleanValue) {\n    // incremental change that needs to be updated in the rest of the tree due to additions/ deletions of\n    // the node/subtree.\n    var change;\n    /**\n      * Takes the path of the node to be fetched and return the node element.\n      * @param {Array} path  - node reference wrt global node.\n      * @return {nodeElement} node  - a particular node in the tree as per specified in the traversal path.\n      */\n    function getNode (path) {\n      var childNode,\n        index = 0,\n        parentNode = baseNode;\n      if (!path.length) {\n        return baseNode;\n      }\n      while (parentNode) {\n        childNode = searchSibling.call(parentNode, path[index]);\n        if ((index === path.length - 1) && childNode) {\n          // sets the incremental change.\n          change = childNode.getValue();\n          return childNode;\n        }\n        parentNode = childNode;\n        index += 1;\n      }\n    }\n    /**\n      * Searches for a node by its name amongst the siblings.\n      * @param {string} label  - Label of the node being searched.\n      * @return {nodeElement} node  - The node element amongst the siblings having the same label name.\n      */\n    function searchSibling (label) { // eslint-disable-line good-practices/no-function-dependency\n      var index,\n        node,\n        sibling,\n        parentNode = this, // eslint-disable-line good-practices/no-single-usage-variable\n        childrenArr = parentNode.getChildren() || [],\n        len = childrenArr.length, // eslint-disable-line good-practices/no-single-usage-variable\n        sanitized = function (str) { // eslint-disable-line good-practices/no-function-dependency\n          return str.toLowerCase().trim();\n        };\n\n      for (index = 0; index < len; index += 1) {\n        sibling = childrenArr[index];\n        if (sanitized(sibling.label) === sanitized(label)) {\n          node = sibling;\n          break;\n        }\n      }\n      return node;\n    }\n    return {\n      /*\n             * Delete a node/ even a subTree from the original tree and redraw the tree if required.\n             * @param path {Array} - Contains the information of the node/subtree to be deleted in reference to the\n             global node.\n             * @param draw {Boolean} - Whether to redraw the tree immediately after the change.\n            */\n      deleteData: function (path, draw) {\n        // fetch the element to the corresonding path.\n        var afAPI, // todo: RED-3367 commit refer.\n          targetNode = getNode(path),\n          itr = afAPI.iterator(targetNode), // eslint-disable-line good-practices/no-single-usage-variable\n          dfItr = itr.df, // eslint-disable-line good-practices/no-single-usage-variable\n          // detach the node element from the actual tree.\n          parentNode = targetNode && targetNode.getParent(),\n          leftSiblingCount = targetNode && targetNode.getSiblingCount('left'), // eslint-disable-line good-practices/no-single-usage-variable\n          childrenArr = parentNode && parentNode.getChildren(), // eslint-disable-line good-practices/no-single-usage-variable\n          visibleRoot = afAPI.getVisibleRoot();\n        // incase the path specified is not a valid one or root node is asked to remove.\n        if (!targetNode || !parentNode) {\n          return;\n        }\n        // set parent node to undefined, to break the parent-child links.\n        childrenArr.splice(leftSiblingCount, 1);\n        if (targetNode === visibleRoot) {\n          visibleRoot = targetNode.getParent() || visibleRoot;\n        }\n        // generically dispose the tree to be deleted.\n        while (targetNode) {\n          rendererAPI.disposeItems(targetNode);\n          targetNode = dfItr.next();\n        }\n        // update the tree with the reduced value responsible for this detachment.\n        while (parentNode) {\n          // reduces the changed value from the existing value of the parent node.\n          parentNode.setValue(-change, true);\n          parentNode = parentNode.getParent();\n        }\n        if (draw) {\n          // draw the tree as per the specified algorithim.\n          drawTreeFn(visibleRoot);\n        }\n      },\n\n      addData: function (nodes, path, draw, index) {\n        var afAPI, // todo: RED-3367 commit refer.\n          algorithmFactory,\n          newNode,\n          tree,\n          parentNode,\n          oldValue,\n          //   childrenArr,\n          change = 0, // eslint-disable-line\n          incremental = true, // eslint-disable-line good-practices/no-single-usage-variable\n          visibleRoot = afAPI.getVisibleRoot(); // eslint-disable-line good-practices/no-single-usage-variable\n        while (nodes.length) {\n          newNode = nodes.pop();\n          tree = algorithmFactory.makeTree(newNode, _getCleanValue, false);\n          change = tree.getValue();\n          parentNode = getNode(path || []);\n          // incase the path specified is not a valid one\n          if (!parentNode) {\n            continue;\n          }\n          // if there is no child node for the insertion node, its value is over-ridden by its inserted child.\n          if (!parentNode.getChildren()) {\n            // cache the old value for the insertion node before the add child operation.\n            oldValue = parentNode.getValue();\n            // flag to set the absolute value for the node.\n            incremental = false;\n          }\n          parentNode.addChildren(tree, index);\n          // update the tree with the added value responsible for this attachment.\n          while (parentNode) {\n            // increases the changed value from the existing value of the parent node.\n            parentNode.setValue(change, incremental);\n            if (oldValue) {\n              change -= oldValue;\n              oldValue = UNDEF;\n              incremental = true;\n            }\n            parentNode = parentNode.getParent();\n          }\n        }\n\n        if (draw) {\n          // draw the tree as per the specified algorithim.\n          drawTreeFn(visibleRoot);\n        }\n      }\n    };\n  },\n  /**\n    * Useful in managing the container elements and folding/unfolding of them.\n    * @param  {Object}  afAPI             algorithm factory apis\n    * @param  {Object}  containerManager  containerManagerCreator APIs [initially it is blank object]\n    * @return {Object}                    contains containerManagerCreator APIs\n    */\n  containerManagerCreator = function (afAPI, containerManager) {\n    var datasetDefStore,\n      drawTreeFn,\n      metaInf,\n      dsConf,\n      rendererAPI,\n      updateContainers,\n      forceCSS = false, // eslint-disable-line good-practices/no-single-usage-variable\n      /**\n        * Draw the navigation bars - both the navigation history or the stacked children bar.\n        * @param  {Object}   drawingAreaMeasurement  - Entire drawing area information for the entire\n        *                                              bar to be drawn.\n        * @param  {boolean}  isStacked               - A flag to determine if the navigation bar is a stacked or not.\n        */\n      drawNavigation = function (drawingAreaMeasurement, isStacked) {\n        var navigationPath,\n          len,\n          colorRange = dsConf.colorRange, // eslint-disable-line good-practices/no-single-usage-variable\n          // map the color range for fetching the css colors for drawing the bars.\n          localColorProvider = afAPI.mapColorManager(dsConf, colorRange, true), // eslint-disable-line good-practices/no-single-usage-variable\n          /**\n            * Responsible for setting the elements to be placed in the navigation bar. In stacked bar, it is\n            * supposedly the childNodes, where as in the navigation History bar it is traversal path to reach\n            * to that node.\n            * @param {boolean} isStacked  - A flag to determine if the navigation bar is a stacked or not.\n            */\n          setNavigationPath = function (isStacked) { // eslint-disable-line\n            // fetch the visible root for any drilled state.\n            var visibleRoot = getVisibleRoot();\n            if (!isStacked) {\n              // fetches the traversal path of the visible root node element, i.e. fetch the traversal\n              // path that was taken to reach the cuurent visible state of the tree.\n              navigationPath = dsConf.navigationBarNodes = visibleRoot.getPath() || [].concat(visibleRoot);\n            } else {\n              // fetches the child nodes to construct the stacked bar.\n              navigationPath = visibleRoot.getChildren();\n            }\n            navigationPath.pop();\n            // sets the length for the navigation path\n            len = navigationPath.length;\n          },\n          /**\n            * Determine the width of indivual segments of the constituting elements inside the bar.\n            * @return {Function} - A function to overwrite the segmentRectangle to attain the above\n            *                      functionality\n            */\n          segmentRectangle = (function () {\n            // store the already allocated width, incremented after every segment is drawn.\n            var allocatedWidth;\n            return {\n              /**\n                * A function to fetch the rectangular area required by the segment element.\n                * @param  {Object}   drawingAreaMeasurement - Entire drawing area information for the entire\n                *                                             bar to be drawn.\n                * @param  {number}   pos                    - The posiiton index of the segment element to be drawn.\n                * @param  {boolean}  isStacked              - A flag to construct the stacked or navigation History bar\n                * @return {Object}                          - The rectangular area configuration for the segmented element.\n                */\n              get: function (drawingAreaMeasurement, pos, isStacked) { // eslint-disable-line\n                var segmentRect = {\n                    y: drawingAreaMeasurement.startY,\n                    height: drawingAreaMeasurement.effectiveHeight\n                  },\n                  node = navigationPath[pos],\n                  parentNode = node.getParent(); // eslint-disable-line good-practices/no-single-usage-variable\n                // The segmentRectangle starts from the drawingAreMeasurement start point.\n                if (allocatedWidth) {\n                  segmentRect._x = drawingAreaMeasurement.startX + drawingAreaMeasurement.effectiveWidth;\n                  segmentRect._width = 0;\n                } else {\n                  segmentRect._x = drawingAreaMeasurement.startX;\n                  segmentRect._width = drawingAreaMeasurement.effectiveWidth;\n                }\n\n                segmentRect.x = allocatedWidth || (allocatedWidth = drawingAreaMeasurement.startX);\n                // for stacked navigation path.\n                if (!isStacked) {\n                  // incrementally add the allocated width.\n                  // All the elements are equispaced.\n                  allocatedWidth += (segmentRect.width = drawingAreaMeasurement.effectiveWidth / len);\n                } else {\n                  // for simple hierarchial navigation history bar.\n                  // the unit width is proportional to the value of the childnodes wrt the parent node.\n                  // increment the width allocation\n                  allocatedWidth += (segmentRect.width = drawingAreaMeasurement.effectiveWidth *\n                                        (node.getValue() / parentNode.getValue()));\n                }\n                return segmentRect;\n              },\n              /**\n                * Reset the allocated Width.\n                */\n              resetAllocation: function () {\n                allocatedWidth = UNDEF;\n              }\n            };\n          })(),\n          // eslint-disable-next-line good-practices/no-function-dependency\n          fetchFlatnessPosition = function (startIndex, endIndex) {\n            var shape;\n            if (endIndex === 1) {\n              shape = BOTH;\n            } else if (startIndex === 0) {\n              shape = LEFT;\n            } else if (startIndex < (endIndex - 1)) {\n              shape = NO;\n            } else {\n              shape = RIGHT;\n            }\n            return shape;\n          },\n          labelPadding = { // eslint-disable-line good-practices/no-single-usage-variable\n            x: 5,\n            y: 5\n          },\n          lineHeight = dsConf.parentLabelLineHeight, // eslint-disable-line good-practices/no-single-usage-variable\n          // Gets label configuration\n          getTextConf = afAPI.initConfigurationForlabel(labelPadding, lineHeight, dsConf), // eslint-disable-line good-practices/no-single-usage-variable\n          drawPathFn = rendererAPI.drawPolyPath, // eslint-disable-line good-practices/no-single-usage-variable\n          drawTextFn = rendererAPI.drawText, // eslint-disable-line good-practices/no-single-usage-variable\n          drawHotFn = rendererAPI.drawHot, // eslint-disable-line good-practices/no-single-usage-variable\n          navigationMapper = {\n            navigationHistory: {\n              path: 'polyPathItem',\n              label: 'pathlabelItem',\n              highlightItem: 'pathhighlightItem',\n              hotItem: 'pathhotItem'\n            }\n          },\n          chart = datasetDefStore.getFromEnv('chart'),\n          trackerConfig = chart.config.trackerConfig,\n          // legend = datasetDefStore.getFromEnv('gLegend'),\n          smartLabel = datasetDefStore.getFromEnv('smartLabel'),\n          clickFn = function (node) {\n            return function () {\n              var context = afAPI.context, // eslint-disable-line good-practices/no-single-usage-variable\n                stateContextId = CLICKEDSTATE, // eslint-disable-line good-practices/no-single-usage-variable\n                visibleState = VISIBLEROOT, // eslint-disable-line good-practices/no-single-usage-variable\n                animationManager = chart.getFromEnv('animationManager'),\n                stateContext = context.getInstance(stateContextId), // eslint-disable-line good-practices/no-single-usage-variable\n                clickedState = stateContext.get(visibleState) || {};\n\n              trackerConfig.length = 0;\n              clickedState.state = DRILLUP;\n              clickedState.node = [{ virginNode: afAPI.getVisibleRoot() }, node];\n              rendererAPI.disposeChild(node);\n              // setting the animation state to drill for drill-up animation\n              animationManager.setAnimationState('drill');\n              chart.setState('drill', true);\n              // Reset the legend once any traversal happens\n              // (legend && legend.enabled) && legend.resetLegend();\n              containerManager.draw([node, node, node]);\n              // eslint-disable-next-line good-practices/no-function-dependency\n              animationManager.onAnimationComplete(() => {\n                chart.setState('drill', false);\n              });\n              chart.resetSingleTracker();\n            };\n          },\n          // eslint-disable-next-line good-practices/no-function-dependency\n          hoverInFn = function () {\n            // eslint-disable-next-line good-practices/no-function-dependency\n            return function () {\n              /* // set the height proportion.\n                            _heightProportion.set({\n                                treeMap: 0.9,\n                                navigationBar: 0,\n                                stackedNavigation: 0.1\n                            });\n                            // draw the container box.\n                            draw([node, fetchGlobalRoot(node), node]); */\n            };\n          },\n          // eslint-disable-next-line good-practices/no-function-dependency\n          hoverOutFn = function () {\n            // eslint-disable-next-line good-practices/no-function-dependency\n            return function () {\n              /* // set the height proportion.\n                                _heightProportion.set({\n                                    treeMap: 0.9,\n                                    navigationBar: 0.1,\n                                    stackedNavigation: 0\n                                });\n                                // draw the container box.\n                                draw(); */\n            };\n          },\n          // eslint-disable-next-line good-practices/no-function-dependency\n          toolTipFn = function (node) {\n            return dsConf.showTooltip ? node.getLabel() : BLANKSTRING;\n          },\n          i,\n          offset,\n          pathObj,\n          node,\n          segmentRect,\n          textConfObj,\n          label,\n          textConf,\n          pathText,\n          _setStyle = dsConf._setStyle, // eslint-disable-line good-practices/no-single-usage-variable\n          textRect,\n          navigationRatio = _heightProportion.get().navigationBar, // eslint-disable-line good-practices/no-single-usage-variable\n          verticalPadding = 2 * (_getVerticalPadding('navigationBar')), // eslint-disable-line good-practices/no-single-usage-variable\n          navigationHeight = navigationRatio * metaInf.effectiveHeight, // eslint-disable-line good-practices/no-single-usage-variable\n          logicalFontSize = Math.min((navigationHeight - (verticalPadding + 6)),\n            _setStyle.fontSize.replace(/\\D+/g, '')),\n          fontSizeStr = logicalFontSize + 'px';\n        navigationMapper.stacked = {\n          path: STACKED_STR + navigationMapper.navigationHistory.path,\n          label: STACKED_STR + navigationMapper.navigationHistory.label,\n          highlightItem: STACKED_STR + navigationMapper.navigationHistory.highlightItem,\n          hotItem: STACKED_STR + navigationMapper.navigationHistory.hotItem\n        };\n        segmentRectangle.resetAllocation();\n        // get the navigation history of the visibleRoot\n        setNavigationPath(isStacked);\n        smartLabel.setStyle({\n          fontSize: fontSizeStr,\n          lineHeight: fontSizeStr\n        });\n        for (i = 0; i < len; i += 1) {\n          node = navigationPath[i];\n          segmentRect = segmentRectangle.get(drawingAreaMeasurement, i, isStacked);\n          offset = (pathObj = createNavigationPath(segmentRect, isStacked ? 'both' : fetchFlatnessPosition(i,\n            len), UNDEF, node)).offset;\n          node[navigationMapper[isStacked ? 'stacked' : 'navigationHistory'].path] =\n                        drawPathFn(pathObj, localColorProvider(node, true, dsConf), node);\n          // Get the configuration to draw text\n          textConfObj = getTextConf(node, segmentRect, true);\n          textConf = textConfObj.conf;\n          textRect = textConf.textRect;\n          textRect.width -= (2 * offset);\n          // for vertically aligning the text.\n          textRect.y = segmentRect.y + (segmentRect.height / 2);\n          label = smartLabel.getSmartText(textConf.label, textRect.width, Math.max(logicalFontSize,\n            textRect.height)).text;\n\n          pathText = drawTextFn(label, textRect, {\n            textAttrs: textConfObj.attr,\n            highlightAttrs: textConfObj.highlight\n          }, {\n            y: segmentRect.height / 10,\n            'font-size': dsConf._setStyle.fontSize,\n            'font-family': dsConf._setStyle.fontFamily\n          }, (isStacked ? 'stacked' : '') + 'path', node);\n          node[navigationMapper[isStacked ? 'stacked' : 'navigationHistory'].label] = pathText.label;\n          node[navigationMapper[isStacked ? 'stacked' : 'navigationHistory'].highlightItem] =\n                        pathText.highlightMask;\n          trackerConfig.push({\n            node: node,\n            key: navigationMapper[isStacked ? 'stacked' : 'navigationHistory'].hotItem,\n            plotDetails: {\n              rect: segmentRect\n            },\n            evtFns: {\n              click: [clickFn(node, isStacked)],\n              hover: [hoverInFn(node), hoverOutFn()],\n              tooltip: [toolTipFn(node)]\n            },\n            callback: drawHotFn\n          });\n        }\n      },\n      /**\n        * Fetch the drawing function for a container element.\n        * @param  {string}    type  - Type of the container box\n        * @return {Function}        - A function to fecth the drawing function for that type.\n        */\n      getDrawFn = function (type) {\n        // map the type with the drawing functions.\n        var drawFn = { // eslint-disable-line good-practices/no-single-usage-variable\n          'treeMap': drawTree,\n          'navigationBar': drawNavigation,\n          'stackedNavigation': drawStackedNavigation\n        };\n        // Returns the drawing function for a type of the container box.\n        return drawFn[type];\n      },\n      /**\n        * Set and retrive the height allocations for navigation, treemap and stacked bar.\n        */\n      _heightProportion = (function () {\n        // initial height allocations.\n        var heightProportion = { // eslint-disable-line good-practices/no-single-usage-variable\n          'treeMap': 1,\n          'navigationBar': 0,\n          'stackedNavigation': 0\n        };\n        return {\n          /**\n            * sets the height allocation with the parameterised input value.\n            * @param {boolean}   hasNavigationBar  - whether there is navigation bar or not\n            */\n          set: function (hasNavigationBar) {\n            var singleLineRatio,\n              navigationRatio = pluckNumber(dsConf.navigationBarHeightRatio,\n                dsConf.navigationBarHeight / metaInf.effectiveHeight, 0.15),\n              maxFontSize = dsConf.labelFontSize ? Math.max(dsConf.labelFontSize, // eslint-disable-line good-practices/no-single-usage-variable\n                dsConf.baseFontSize) : dsConf.baseFontSize,\n              verticalPadding = 2 * (_getVerticalPadding('navigationBar')); // eslint-disable-line good-practices/no-single-usage-variable\n            // 3 px gap is maintained vertically.\n            singleLineRatio = (6 + maxFontSize + verticalPadding) / metaInf.effectiveHeight; // eslint-disable-line good-practices/no-single-usage-variable\n            navigationRatio = Math.max(singleLineRatio, navigationRatio);\n            if (navigationRatio < 0.05) {\n              navigationRatio = 0.05;\n            } else if (navigationRatio > 0.40) {\n              navigationRatio = 0.40;\n            }\n            dsConf.navigationBarHeightRatio = navigationRatio;\n            if (hasNavigationBar) {\n              heightProportion = {\n                treeMap: (1 - navigationRatio),\n                navigationBar: navigationRatio,\n                stackedNavigation: 0\n              };\n            } else {\n              heightProportion = {\n                treeMap: 1,\n                navigationBar: 0,\n                stackedNavigation: 0\n              };\n            }\n          },\n          /**\n            * Fetch the height allocation defination.\n            * @return {Object} - the height proportion.\n            */\n          get: function () {\n            return heightProportion;\n          }\n        };\n      })(),\n\n      allocatedHeightProp = 0,\n\n      _getVerticalPadding = function (type) {\n        var verticalPadding = dsConf.verticalPadding, // eslint-disable-line good-practices/no-single-usage-variable\n          plotBorderThickness = dsConf.plotBorderThickness, // eslint-disable-line good-practices/no-single-usage-variable\n          navigationBarBorderThickness = dsConf.navigationBarBorderThickness; // eslint-disable-line good-practices/no-single-usage-variable\n        return verticalPadding + (type === 'navigationBar' ? navigationBarBorderThickness\n          : plotBorderThickness);\n      },\n      /**\n        * Fectches the drawing area information for a particular type of container element.\n        * @param {string} type  - type of the container element\n        * @return {Function}    - a fucntion that takes type as input and calculate the area requirements using the\n        *                         heightProportion mapping.\n        */\n      getDrawingArea = function (type) {\n        var width = metaInf.effectiveWidth, // eslint-disable-line good-practices/no-single-usage-variable\n          height = metaInf.effectiveHeight,\n          verticalPadding = _getVerticalPadding(type),\n          // maps the height requirements for each type of the container element.\n          heightProportion = _heightProportion.get(), // eslint-disable-line good-practices/no-single-usage-variable\n          requiredHeightProp = heightProportion[type];\n        if (allocatedHeightProp >= 1) {\n          allocatedHeightProp = 0;\n        }\n        allocatedHeightProp += requiredHeightProp;\n        // take the vertical padding as the seperator between the box elements.\n        return {\n          effectiveHeight: Math.round(requiredHeightProp * height * 100) / 100 - (verticalPadding),\n          effectiveWidth: width,\n          startX: metaInf.startX,\n          startY: metaInf.startY + verticalPadding + Math.round((allocatedHeightProp - requiredHeightProp) *\n                        height * 100) / 100\n        };\n      };\n    /**\n      * Container to draw the navigation bar or the treemap within it.\n      */\n    class Container {\n      /**\n        * Initialise the container box with drawing configurations\n        * @param {Object}   configuration  - Contains the drawingAreaMeasurement and name for the container box element.\n        * @param {Function} drawFn         - Set the draw function defined for that type of container element.\n        */\n      init (configuration, drawFn) {\n        var container = this,\n          containerConf = container.conf || (container.conf = {}); // eslint-disable-line good-practices/no-single-usage-variable\n        containerConf.name = configuration.name;\n        container.setDrawingArea(configuration.drawingAreaMeasurement);\n        container.draw = container.draw(drawFn);\n      }\n      /**\n        * sets the drawing area for the container element\n        * @param {Object} drawingAreaMeasurement  - drawing area for the container element.\n        */\n      setDrawingArea (drawingAreaMeasurement) {\n        var containerConf = this.conf; // eslint-disable-line good-practices/no-single-usage-variable\n        containerConf.drawingAreaMeasurement = drawingAreaMeasurement;\n      }\n\n      /**\n       * drawing informations\n       * @param {Function} drawFn  - Set the draw function defined for that type of container element\n       * @return {Function} -\n       */\n      // eslint-disable-next-line\n      draw (drawFn) {\n        return function () {\n          var containerConf = this.conf,\n            drawingAreaMeasurement = containerConf.drawingAreaMeasurement; // eslint-disable-line good-practices/no-single-usage-variable\n          if (drawingAreaMeasurement.effectiveHeight > 0) {\n            drawFn(containerConf.drawingAreaMeasurement);\n          }\n        };\n      }\n      // eslint-disable-next-line\n      eventCallback () {\n      }\n    }\n\n    /**\n     * Initialise the containerManager\n     */\n    function init () {\n      var type,\n        containersArr = ['navigationBar', 'treeMap', 'stackedNavigation'],\n        args = Array.prototype.slice.call(arguments, 0);\n      datasetDefStore = args[0]; // eslint-disable-line good-practices/no-single-usage-variable\n      metaInf = args[1];\n      dsConf = datasetDefStore.conf;\n      rendererAPI = args[2];\n      // tree = args[3];\n      drawTreeFn = args[4];\n      if (updateContainers.get().length >= containersArr.length) {\n        updateContainers.set();\n      }\n\n      while (containersArr.length) {\n        type = containersArr.shift();\n        updateContainers.set({\n          type: type,\n          drawFn: getDrawFn(type),\n          drawingArea: getDrawingArea(type)\n        });\n      }\n    }\n    /**\n      * Fetch the visible root.\n      * @return {TreeRoot} - The visible root for the current view.\n      */\n    function getVisibleRoot () {\n      return afAPI.getVisibleRoot();\n    }\n    /**\n     * draws tree with specific treemap layout algorithm\n     * @param {Object} drawingAreaMeasurement effective area to inform layout algorithm how much space is available\n     */\n    function drawTree (drawingAreaMeasurement) {\n      var _temp = dsConf.plotBorderThickness; // eslint-disable-line good-practices/no-single-usage-variable\n      if (forceCSS) {\n        dsConf.plotBorderThickness = 0;\n      }\n      drawTreeFn.apply(afAPI.getVisibleRoot(), [datasetDefStore, {\n        width: drawingAreaMeasurement.effectiveWidth,\n        height: drawingAreaMeasurement.effectiveHeight,\n        x: drawingAreaMeasurement.startX,\n        y: drawingAreaMeasurement.startY,\n        horizontalPadding: dsConf.horizontalPadding,\n        verticalPadding: dsConf.verticalPadding\n      }, rendererAPI]);\n      dsConf.plotBorderThickness = _temp;\n    }\n    /**\n      * Creates a custom path for the navigation bar element.\n      * @param  {Object} rect    - Holds the basic configuration for the custom path.\n      * @param  {string} shape   - Decides the shape modification required.\n      * @param  {number} _offset - Decides the strech of the central angle of the navigation bar seperator.\n      * @return {Object}         - path is the actual custom required path._path is the path internally might be useful in\n      *                            folding in/out of the navigation bar\n      */\n    function createNavigationPath (rect, shape, _offset) {\n      var x = rect.x, // eslint-disable-line good-practices/no-single-usage-variable\n        y = rect.y,\n        width = rect.width,\n        height = rect.height,\n        centerHalfAngle = dsConf.seperatorAngle / 2,\n        init = ['M', x, y], // eslint-disable-line\n        offset = pluckNumber((centerHalfAngle ? ((height / 2) * (1 - Math.tan(centerHalfAngle))) : _offset), 15),\n        _init = ['M', rect._x, y], // eslint-disable-line good-practices/no-single-usage-variable\n\n        pathFetcher = function (width) { // eslint-disable-line\n          return {\n            'both': ['h', width, 'v', height / 2, 'v', height / 2, 'h', -width, 'v', -height / 2, 'v', -height / 2],\n            'right': ['h', width, 'v', height / 2, 'v', height / 2, 'h', -width, 'l', offset, -height / 2, 'l', -offset,\n              -height / 2],\n            'no': ['h', width, 'l', offset, height / 2, 'l', -offset, height / 2, 'h', -width, 'l', offset,\n              -height / 2, 'l', -offset, -height / 2],\n            'left': ['h', width, 'l', offset, height / 2, 'l', -offset, height / 2, 'h', -width, 'v', -height / 2,\n              'v', -height / 2]\n          };\n        };\n      return {\n        path: init.concat(pathFetcher(width)[shape]),\n        _path: _init.concat(pathFetcher(rect._width).both),\n        offset: offset\n      };\n    }\n    /**\n      * function to draw stacked navigation bar\n      */\n    function drawStackedNavigation () {\n      var args = Array.prototype.splice.call(arguments, 0);\n      args.push(true);\n      getDrawFn('navigationBar').apply(this, args);\n    }\n\n    updateContainers = (function () {\n      var containers = [];\n      return {\n        get: function () {\n          return containers;\n        },\n        set: function (config) {\n          var container;\n          if (config) {\n            container = new Container();\n            container.init({\n              name: config.type,\n              drawingAreaMeasurement: config.drawingArea\n            }, config.drawFn);\n            containers.push(container);\n          } else {\n            containers.length = 0;\n          }\n          return containers;\n        }\n      };\n    })();\n    /**\n      * Adds all the graphics element in a pool which is again reused.\n      */\n    function remove () {\n      var visibleRoot = afAPI.getVisibleRoot();\n      // dispose the elements\n      visibleRoot && rendererAPI.disposeChild(visibleRoot);\n    }\n    /**\n     * handles draw job of container\n     * @param {Array} visibleRootArr  visible roots\n     */\n    function draw (visibleRootArr) {\n      var i,\n        containersArr,\n        containerElement,\n        visibleRoot = afAPI.getVisibleRoot();\n        // mark nodes for removal\n      rendererAPI.disposeSelectedChildren(visibleRoot, visibleRootArr ? visibleRootArr[1] : visibleRoot);\n      // The height proportions are set as per the target Root of the treemap container.\n      visibleRootArr && (visibleRoot = visibleRootArr[1]);\n      // no navigation bar if the target Node is the Global node.\n      if (!visibleRoot.getParent()) {\n        containerManager.heightProportion.set(false);\n      } else if (dsConf.showNavigationBar) {\n        // on every drill the height proportions are changed.\n        containerManager.heightProportion.set(true);\n      }\n      // fetch the container elements.\n      containersArr = updateContainers.get();\n      for (i = 0; i < containersArr.length; i += 1) {\n        containerElement = containersArr[i];\n        containerElement.setDrawingArea(getDrawingArea(containerElement.conf.name));\n        visibleRootArr && afAPI.setVisibleRoot(visibleRootArr[i]);\n        containerElement.draw();\n      }\n      // remove the graphical elements of the nodes that are marked for removal after draw has occured\n      rendererAPI.hideNodes();\n    }\n    containerManager.init = init;\n    containerManager.draw = draw;\n    containerManager.heightProportion = _heightProportion;\n    containerManager.remove = remove;\n\n    return containerManager;\n  },\n  /**\n   * Returns the default color since no code is passed\n   * @param   {string} hex color code\n   * @return  {string}     a valid color code\n   */\n  normalizeColorCode = function (hex) {\n    if (!hex) {\n      // Returns the default color since no code is passed\n      return '#' + MOTHER_OF_ALL_COLOR;\n    }\n\n    return hex.replace(/^#*/, '#');\n  },\n  MOTHER_OF_ALL_COLOR = 'E5E5E5',\n  /**\n   * store refernece of APIs\n   * @return {Object} - API to create tree\n   */\n  ref = function () {\n    var afAPI = {},\n      algorithmFactory = {}, // eslint-disable-line good-practices/no-single-usage-variable\n      containerManager = {};\n\n    return {\n      afAPI: afAPICreator(afAPI, containerManager),\n      algorithmFactory: algorithmFactoryCreator(afAPI, algorithmFactory, containerManager),\n      containerManager: containerManagerCreator(afAPI, containerManager),\n      treeOpt: treeOpt\n    };\n  };\n/**\n * Nodes are resided in the bucket in a ascending order depending on their color value.\n * It applies range-out css on the nodes if it outlies of the range.\n */\nclass Bucket {\n  /**\n   * constructor\n   */\n  constructor () {\n    this._b = [];\n    this._css = UNDEF;\n    // Default function to be operated on outliers.\n    this.rangeOurEffectApplyFn = stubFN;\n\n    // statePointers are simple object that remembers state. It has two properties which get updated when the\n    // legend is dragged. The .value property is the value which the pointer is detecting. This value might not be\n    // the one from the array elements. It can be any number between the first and last range. The .index property\n    // is the index of the immediate element that just surpasses the value of .value\n\n    // This initially points to the first element of the array. Since the array is sorted, this in turns points\n    // the lowest value node. When the slider is dragged the lower pointer moves accordingly based on the value of\n    // legend slider. Any nodes that resides left side of the slider are outliers.\n    this.statePointerLow = {\n      value: UNDEF,\n      index: UNDEF\n    };\n\n    // This initially points to the last element of the array. Since the array is sorted, this in turns points\n    // the highest value node. When the slider is dragged the higher pointer moves accordingly based on the value of\n    // legend slider. Any nodes that resides right side of the slider are outliers.\n    this.statePointerHigh = {\n      value: UNDEF,\n      index: UNDEF\n    };\n  }\n  /**\n   * resets statePointers\n   */\n  resetPointers () {\n    this.statePointerLow = {\n      value: UNDEF,\n      index: UNDEF\n    };\n\n    this.statePointerHigh = {\n      value: UNDEF,\n      index: UNDEF\n    };\n  }\n\n  /**\n    * Sets what operation to be performed if a node remains in the outlier area.\n    * @param {Object}   css                    - the style object to be applied\n    * @param {Function} rangeOurEffectApplyFn  - the function to be executed. This function is called with the\n    *                                            outlier node and css.\n    */\n  setRangeOutEffect (css, rangeOurEffectApplyFn) {\n    this._css = css;\n    this.rangeOurEffectApplyFn = rangeOurEffectApplyFn;\n  }\n\n  /**\n    * Place node in the bucket cumulatively in sorted manner. This use binary search and insert policy.\n    * @param {TreeNode} node  - node to be inserted. Make sure the node is leaf. This does not check if the node passed\n    *                           is leaf node or not.\n    */\n  addInBucket (node) {\n    var arr = this._b,\n      val = node.getColorValue(),\n      minIndex = 0,\n      maxIndex = arr.length - 1,\n      targetIndex;\n\n    if (!val && val !== 0) {\n      return;\n    }\n\n    // Get position where the current node will fit in the ascending array. This position is based on the value of\n    // the node.\n    targetIndex = (function () { // eslint-disable-line good-practices/no-single-usage-variable\n      var _i, _elem, _elemVal;\n\n      // Initially the whole array is the window. And continue until the window is shrinked to zero.\n      while (minIndex <= maxIndex) {\n        // Apply sort of divide and conquer to get the middle index (floored if the index is not integer). This\n        // becomes the pivot element\n        targetIndex = _i = (minIndex + maxIndex) / 2 | 0;\n\n        _elem = arr[_i];\n        _elemVal = _elem.getColorValue();\n\n        if (_elemVal < val) {\n          // If value of the element to be entered is greater than the current calculated pivot element value\n          // shift the left hand of the window starting from the pivot element and recalculate.\n          minIndex = _i + 1;\n        } else if (_elemVal > val) {\n          // If value of the element to be entered is less than the current calculated pivot element value\n          // shift the right hand of the window starting from the pivot element and recalculate.\n          maxIndex = _i - 1;\n        } else {\n          // Both are same. Return the current position.\n          return _i;\n        }\n      }\n      // Return the index which is ready for use in splice\n      return ~maxIndex;\n    })();\n\n    // Add the element at that location\n    arr.splice(Math.abs(targetIndex), 0, node);\n  }\n\n  /**\n    * Moves the lowerStatePointer and perform operation on the outliers which resides at left side of the pointer.\n    * @param {Integer} value  - value according to which the lowerStatePointer would be moved.\n    */\n  moveLowerShadePointer (value) {\n    var arr = this._b,\n      index,\n      bucketElem,\n      _val,\n      statePtr = this.statePointerLow,\n      stateIndex = statePtr.index,\n      stateVal = statePtr.value,\n      pointerAheadFlag = false;\n\n    // Assign a initial pointer state if legend is dragged for the first time otherwise resume the previous state\n    index = stateIndex = stateIndex !== UNDEF ? stateIndex : 0;\n    stateVal = stateVal !== UNDEF ? stateVal : Number.NEGATIVE_INFINITY;\n\n    if (value === stateVal) {\n      // Do not move the pointer if the last state value and the current one is same.\n      return;\n    }\n\n    if (stateVal <= value) {\n      // If the legend is moved further right from the the last position.\n      while (true) {\n        // Iterate over the new changed range to find the outliers.\n        bucketElem = arr[index++];\n        _val = bucketElem ? bucketElem.getColorValue() : 0;\n\n        if (value <= _val || !bucketElem) {\n          // When no more outliers are to be iterated, break\n          break;\n        }\n\n        // A flag to bring the pointer back to its correct position.\n        pointerAheadFlag = true;\n        // Apply style and execute the operation on outliers\n        bucketElem.rangeOutEffect = this._css;\n        this.rangeOurEffectApplyFn.call(bucketElem, this._css);\n      }\n\n      // Fix the pointer position\n      index = pointerAheadFlag ? index - 2 : index - 1;\n    } else {\n      // If the legend is moved further left from the the last position.\n      while (true) {\n        // Remove some elements from outlier region. i.e. rollback the changes done when they were in outliers.\n        bucketElem = arr[index--];\n        _val = bucketElem ? bucketElem.getColorValue() : 0;\n\n        if (value > _val || !bucketElem) {\n          break;\n        }\n\n        // Restore the previous style which was in use before it had become a outliers\n        bucketElem.cssConf = bucketElem.cssConf || {};\n\n        // A flag to bring the pointer back to its correct position.\n        pointerAheadFlag = true;\n        delete bucketElem.rangeOutEffect;\n        // Forcefully made the opacity 1. This is against the guard that if the opacity is changed through\n        // configuration during legend dragging\n        bucketElem.cssConf.opacity = 1;\n        this.rangeOurEffectApplyFn.call(bucketElem, bucketElem.cssConf);\n      }\n\n      // Fix the pointer position\n      index = pointerAheadFlag ? index + 2 : index + 1;\n    }\n\n    // Saves the current state\n    statePtr.index = index;\n    statePtr.value = value;\n  }\n\n  /**\n    * Moves the higherStatePointer and perform operation on the outliers which resides at right side of the pointer.\n    * @param {Integer} value - value according to which the higherStatePointer would be moved.\n    */\n  moveHigherShadePointer (value) {\n    var arr = this._b,\n      length = arr.length, // eslint-disable-line good-practices/no-single-usage-variable\n      index,\n      bucketElem,\n      _val,\n      statePtr = this.statePointerHigh,\n      stateIndex = statePtr.index,\n      stateVal = statePtr.value,\n      pointerAheadFlag = false;\n\n    // Assign a initial pointer state if legend is dragged for the first time otherwise resume the previous state\n    index = stateIndex = stateIndex !== UNDEF ? stateIndex : length - 1;\n    stateVal = stateVal !== UNDEF ? stateVal : Number.POSITIVE_INFINITY;\n\n    if (value === stateVal) {\n      // Donot move the pointer if the last state value and the current one is same.\n      return;\n    }\n\n    if (stateVal > value) {\n      // If the legend is moved further left from the the last position.\n      while (true) {\n        // Iterate over the new changed range to find the outliers.\n        bucketElem = arr[index--];\n        _val = bucketElem ? bucketElem.getColorValue() : 0;\n\n        if (value >= _val || !bucketElem) {\n          // When no more outliers are to be iterated, break\n          break;\n        }\n\n        // A flag to bring the pointer back to its correct position.\n        pointerAheadFlag = true;\n        // Apply style and execute the operation on outliers\n        bucketElem.rangeOutEffect = this._css;\n        this.rangeOurEffectApplyFn.call(bucketElem, this._css);\n      }\n      // Fix the pointer position\n      index = pointerAheadFlag ? index + 2 : index + 1;\n    } else {\n      // If the legend is moved further right from the the last position.\n      while (true) {\n        // Remove some elements from outlier region. i.e. rollback the changes done when they were in outliers.\n        bucketElem = arr[index++];\n        _val = bucketElem ? bucketElem.getColorValue() : 0;\n\n        if (value < _val || !bucketElem) {\n          break;\n        }\n\n        // Restore the previous style which was in use before it had become a outliers\n        bucketElem.cssConf = bucketElem.cssConf || {};\n\n        // A flag to bring the pointer back to its correct position.\n        pointerAheadFlag = true;\n        delete bucketElem.rangeOutEffect;\n        // Forcefully made the opacity 1. This is against the guard that if the opacity is changed through\n        // configuration during legend dragging\n        bucketElem.cssConf.opacity = 1;\n        this.rangeOurEffectApplyFn.call(bucketElem, bucketElem.cssConf);\n      }\n      // Fix the pointer position\n      index = pointerAheadFlag ? index - 2 : index - 1;\n    }\n\n    // Saves the current state\n    statePtr.index = index;\n    statePtr.value = value;\n  }\n}\n/**\n  * Singular node in a tree. A node consists of label and value associated with it.\n  * One single node can have two references. One to the children and one to the parent.\n  * Using this references the complete tree can be traveresd.\n  * If the the node is a leaf then reference to children (next) would be undefined.\n  * If the node is the root node the refernce to the parent would be undefined.\n  */\nclass TreeNode {\n  /**\n   * connstructor function\n   * @param {string}  label       - label of the node. Usually a catagory or specific item.\n   * @param {Integer} value       - value of the node.\n   * @param {Float}   colorValue  - color value as the range in which this node belongs to\n   */\n  constructor (label, value, colorValue) {\n    // Currently this label is unique (which should be the case ideally). This label serves the purpose of id.\n    this.label = label;\n    this.id = id++;\n    this.value = parseFloat(value, 10);\n    this.colorValue = parseFloat(colorValue, 10);\n    // Refernce to child nodes. The tree here is a generic tree. Hence can have any number of child, and is a array.\n    this.next = UNDEF;\n    // Reference to the parent of the current node. Single treenode element, since only one node can be parent.\n    this.prev = UNDEF;\n    // Stores the meta information specific to set level like back ground color\n    this.meta = {};\n  }\n  /**\n   * fetches css property\n   * @return {Object} - css config\n   */\n  getCSSconf () {\n    return this.cssConf;\n  }\n  /**\n   * Fetches the path wrt the global root node.\n   * @return {Array}  path\n   */\n  getPath () {\n    return this.path;\n  }\n  /**\n    * Sets the path wrt the global root.\n    */\n  setPath () {\n    var node = this,\n      parentNode = node.getParent();\n    node.path = (parentNode ? parentNode.getPath() : []).concat(node);\n  }\n\n  /**\n    * Adds a child to the existing list of children of the current node.\n    * Link the child nodes with the ancestors. This linking is done one at a time.\n    * Since the tree is a generic one, the links are saved as sorted array.\n    * @param {TreeNode}         ref - reference to the next child\n    * @return {Array.<TreeNode>}    - Array of all children\n    */\n  addChild (ref) { // eslint-disable-line\n    if (ref instanceof TreeNode) {\n      // Add at the end of the existing child. If no child is present create a list.\n      this.next = this.next || [];\n      [].push.call(this.next, ref);\n      // Set the parent as well\n      ref.setParent(this);\n    }\n\n    // Return the list of updated child\n    return this.next;\n  }\n\n  /**\n    * Get all the children of the current node.\n    * @return {Array.<TreeNode>} - Array of all children\n    */\n  getChildren () {\n    return this.next;\n  }\n\n  /**\n    * add children to a specific node(parent node in this context) to a specified index.\n    * Can be a multiple child insertions at a time.\n    * Default index remains at the end of the object.\n    * @param {TreeNode}   newNode   new tree node\n    * @param {Integer}    indexVal     index where to add the node in the node array\n    */\n  addChildren (newNode, indexVal) {\n    var parentNode = this,\n      index = indexVal,\n      childrenArr = parentNode.getChildren() || (parentNode.next = []),\n      len = childrenArr.length;\n    // default place in the end\n    if (!index) {\n      index = len - 1;\n    }\n    // applying extreme conditions.\n    index = (index > (len - 1)) ? (len - 1) : ((index < 0) ? 0 : index);\n    childrenArr.splice(index, 0, newNode);\n    newNode.setParent(this);\n  }\n\n  /**\n    * Fetch the depth of the current node.\n    * @return {number} - Depth of the node element in the tree structure.\n    */\n  getDepth () {\n    return this.meta.depth;\n  }\n  /**\n    * Check if the node is a leaf node.\n    * @param  {number}   maxDepth  -  Depth Traversal restrictions.\n    * @return {boolean}            - If the node is a leaf node keeping the imposed restrictions intact.\n    */\n  isLeaf (maxDepth) {\n    var node = this;\n    //  if no depth restrictions being imposed, only node.next is used to determine its virginity\n    return ((maxDepth ? (node.getDepth() < maxDepth) : true) && node.next);\n  }\n\n  /**\n    * Set a parent node of the current node\n    * @param  {TreeNode}   ref - reference to the next child\n    * @return {TreeNode}       - Current node with updated parent reference.\n    */\n  setParent (ref) { // eslint-disable-line\n    if (ref instanceof TreeNode) {\n      this.prev = ref;\n    }\n    return this;\n  }\n\n  /**\n    * Get siblings' count of the current node\n    * @param  {Enum}  side  - specifies the side from which siblings are to be counted. Can be either 'left' or 'right'\n    * @return {Integer}       - sibling count including the current node\n    */\n  getSiblingCount (side) {\n    var parent,\n      counter = 0, // eslint-disable-line good-practices/no-single-usage-variable\n      node = this,\n      currentSibling = node;\n\n    if (!(this instanceof TreeNode)) {\n      // IF the instance is not of TreeNode which should not be case at any given point time.\n      return;\n    }\n\n    // Traverse up the parent node, so that we get the reference to list of children\n    parent = node.getParent();\n    //  get sibling count specific to a particular side.\n    if (side) {\n      while (currentSibling) {\n        currentSibling = currentSibling.getSibling(side);\n        if (currentSibling) {\n          counter += 1;\n        }\n      }\n      return counter;\n    }\n    if (parent) {\n      // If parent is present, which is not the case for the root node, return the count of children.\n      // Which in turns is the count of sibling.\n      return parent.getChildren().length;\n    }\n  }\n\n  /**\n    * Get the parent of the current node.\n    * @return {TreeNode} - parent\n    */\n  getParent () {\n    return this.prev;\n  }\n\n  /**\n    * Get the label of the current node.\n    * @return {string} - label\n    */\n  getLabel () {\n    return this.label;\n  }\n\n  /**\n    * Get the value of the current node.\n    * @return {Integer} - value\n    */\n  getValue () {\n    return this.value;\n  }\n\n  /**\n    * Sets the value of the current node.\n    * @param  {Integer} value        - The updated value for the node.\n    * @param  {boolean} incremental  - A flag to update the value incrementally and not on absolute scale.\n    */\n  setValue (value, incremental) {\n    var node = this;\n    if (incremental) {\n      node.value += value;\n    } else {\n      node.value = value;\n    }\n  }\n\n  /**\n    * Get the colorValue of the current node.\n    * @return {Integer} - value\n    */\n  getColorValue () {\n    return this.colorValue;\n  }\n\n  /**\n    * Get the immediate sibling of the current node. The sibling can be retrieved either from the left side or right.\n    * @param  {Enum} side  - specifies the side from which sibling to be retrieved. Can be either 'left' or 'right'\n    * @return {TreeMap} - the sibling of the specified side\n    */\n  getSibling (side) {\n    var nSideStr = side.toLowerCase(), // eslint-disable-line good-practices/no-single-usage-variable\n      parent = this.getParent(),\n      label = this.getLabel(), // eslint-disable-line good-practices/no-single-usage-variable\n      children,\n      index,\n      tLabel,\n      child;\n\n    if (!parent) {\n      // If the parent is not present, means the node is root node. Hence no sibling present.\n      return;\n    }\n\n    // Retrieves all the sibling\n    children = parent.getChildren();\n\n    // Searches node by label as label name is most likely to be same in one category.\n    for (index = 0; index < children.length; index++) {\n      child = children[index];\n      tLabel = child.getLabel();\n\n      if (tLabel === label) {\n        switch (nSideStr) {\n          case 'left':\n            return children[index - 1];\n\n          case 'right':\n            return children[index + 1];\n        }\n      }\n    }\n  }\n\n  /**\n    * Set the meta information. Like which is specific to a set label\n    * @param {string}          key    - the key of the set label attr like color\n    * @param {string | Object} value  - the value of the key\n    */\n  setMeta (key, value) {\n    this.meta[key] = value;\n  }\n\n  /**\n    * Set the depth information.\n    * @param {number} depth  - The level at which the node is present in reference to the tree.\n    */\n  setDepth (depth) {\n    this.meta.depth = depth;\n  }\n\n  /**\n    * Get the meta information by key or completely. If the key is passed it returns back the value or the complete\n    * meta information.\n    * @param  {string} key  - the key of the set label attr like color\n    * @return {string | Object | undefined} - the value of the key or if the key is not passed the complete meta obj.\n    */\n  getMeta (key) {\n    if (!key) {\n      return this.meta;\n    }\n\n    return this.meta[key];\n  }\n}\n\nexport default ref;\n"],"sourceRoot":""}