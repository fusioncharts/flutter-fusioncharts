{"version":3,"sources":["webpack:///./packages/fusioncharts/overlappedcolumn2d/index.js","webpack:///./packages/fusioncharts/viz/overlappedcolumn2d.js","webpack:///./packages/fc-charts/src/chart/overlappedcolumn2d/index.js","webpack:///./packages/fc-charts/src/dataset/overlappedcolumn2d/index.js"],"names":["name","type","requiresFusionCharts","extension","FusionCharts","addDep","crossline","OverlapperColumn2D","Overlappedcolumn2d","eiMethods","registerFactory","datasetFactory","getName","__setDefaultConfig","this","config","friendlyName","defaultDatasetType","enablemousetracking","getDSdef","OverlappedColumn","getDSGroupdef","OverlappedColumnManager","MSCartesian","checkOverlap","currDataDimensions","prevDataDimensions","i","len","prevLabelYPos","prevlabelHeight","currentLabelYPos","y","currentLabelHeight","height","length","labelShown","_labeldimensionMap","drawLabel","start","end","skipLabelDraw","dataObj","attr","j","graphic","setValue","showValue","label","tempGraphics","prevDataDims","dataLabelContainer","chart","getFromEnv","animationManager","toolTipController","chartConfig","xAxis","paper","visible","getState","smartLabel","style","dataLabelStyle","conf","getTicksLen","components","dataStore","data","pool","rotateValues","rotatevalues","currentDataDim","currDatasetIndex","getJSONIndex","skipInfo","getSkippingInfo","skippingApplied","plotDrawArray","labelDraw","plotDrawArrayLength","startIndex","pluckNumber","endIndex","notParticularLabeDraw","Math","abs","hideCallbackFn","hide","showCallbackFn","show","getContainer","css","fontFamily","fontSize","fontWeight","fontStyle","useEllipsesOnOverflow","useEllipsesWhenOverflow","setStyle","UNDEF","labelSkip","graphics","getDatasets","map","dataset","filter","Boolean","showValues","x","props","width","_state","labelWidth","labelHeight","transform","getSuggestiveRotation","splice","setAnimation","el","component","index","container","callback","outlineText","showTextOutline","fill","showtooltip","abbrArr","enableToolTip","addGraphicalElement","doNotRemove","labelDrawn","Column"],"mappings":"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","file":"fusioncharts.overlappedcolumn2d.js","sourcesContent":["import OverlapperColumn2D from '../viz/overlappedcolumn2d';\nimport crossline from '../features/crossline';\n\nexport { OverlapperColumn2D };\n\nexport default {\n  name: 'overlappedcolumn2d',\n  type: 'package',\n  requiresFusionCharts: true,\n  extension: FusionCharts => {\n    FusionCharts.addDep(crossline);\n    FusionCharts.addDep(OverlapperColumn2D);\n  }\n};\n","import Overlappedcolumn2d from '@fusioncharts/charts/src/chart/overlappedcolumn2d';\nexport default Overlappedcolumn2d;\n","/* eslint require-jsdoc: 'error', valid-jsdoc: [\"error\", { \"requireReturn\": false }] */\nimport MSCartesian from '../_internal/mscartesian';\nimport OverlappedColumn from '../../dataset/overlappedcolumn2d';\nimport OverlappedColumnManager from '../../dataset/groups/column-overlapped';\nimport datasetFactory from '../../factories/multiseries-dataset';\n\nconst CHART_STR = 'Multi-series Overlapped Column Chart',\n  COLUMN_STR = 'column';\n/**\n * Class for multiseries column charts and who depend on this class\n * @type {class}\n */\nclass OverlappedColumn2D extends MSCartesian {\n  /**\n   * constructor function of this class\n   */\n  constructor () {\n    super();\n    this.eiMethods = {};\n    this.registerFactory('dataset', datasetFactory, ['vCanvas']);\n  }\n  /**\n   * Sets the name of the component\n   * @return {string} name\n   */\n  getName () {\n    return 'OverlappedColumn2D';\n  }\n\n  /**\n   * Provides the name of the chart extension\n   *\n   * @static\n   * @return {string} The name of the chart extension\n   */\n  static getName () {\n    return 'OverlappedColumn2D';\n  }\n\n  /**\n   * parse defualt configuration of the chart\n   */\n  __setDefaultConfig () {\n    super.__setDefaultConfig();\n    this.config.friendlyName = CHART_STR;\n    this.config.defaultDatasetType = COLUMN_STR;\n    this.config.enablemousetracking = true;\n  }\n  /**\n   * This method return the dataset definations for this charts\n   * @return {Object}       Column dataset definition\n   */\n  getDSdef () {\n    return OverlappedColumn;\n  }\n  /**\n   * This method return the dataset-group definations for this charts\n   * @return {class} manager API for overlap column\n   */\n  getDSGroupdef () {\n    return OverlappedColumnManager;\n  }\n}\n\nexport default OverlappedColumn2D;\n","\n/* eslint require-jsdoc: 'error', valid-jsdoc: [\"error\", { \"requireReturn\": false }] */\nimport { pluckNumber } from '@fusioncharts/core/src/lib';\nimport Column from '../column';\n\nlet UNDEF;\n/**\n * This methods checks if current datalabel overlaps with any of the datalabels of same index\n * @param {Object} currDataDimensions current data object\n * @param {Array} prevDataDimensions previous data objects of different series but of same index.\n * @returns {Boolean} a boolean value that indicates whether the value overlaps with previous values.\n */\nfunction checkOverlap (currDataDimensions, prevDataDimensions) {\n  let i,\n    len,\n    currentLabelYPos = currDataDimensions.y,\n    prevLabelYPos,\n    currentLabelHeight = currDataDimensions.height,\n    prevlabelHeight;\n  for (i = 0, len = prevDataDimensions.length; i < len; i++) {\n    prevlabelHeight = prevDataDimensions[i].height;\n    prevLabelYPos = prevDataDimensions[i].y;\n    if (prevDataDimensions[i].labelShown && (currentLabelYPos + currentLabelHeight >= prevLabelYPos) &&\n       (prevLabelYPos + prevlabelHeight >= currentLabelYPos)) {\n      return true;\n    }\n  }\n  return false;\n}\nclass OverlappedColumn extends Column {\n  constructor () {\n    super();\n    // this map stores the dimensions of the datalabels.used for checking if two labels overlap\n    this._labeldimensionMap = {};\n  }\n  /**\n   * This function is used for drawing the data labels.\n   * This function is called once for each dataset when the are drawn and shown/hidden from the draw()\n   * function of the Column class.\n   * @param {number} start   start index\n   * @param {number} end     end index\n   */\n  drawLabel (start, end) {\n    var dataSet = this,\n      chart = dataSet.getFromEnv('chart'),\n      animationManager = dataSet.getFromEnv('animationManager'),\n      toolTipController = dataSet.getFromEnv('toolTipController'),\n      chartConfig = chart.config,\n      xAxis = dataSet.getFromEnv('xAxis'),\n      paper = dataSet.getFromEnv('paper'),\n      visible = dataSet.getState('visible'),\n      smartLabel = chart.getFromEnv('smartLabel'),\n      style = chart.config.dataLabelStyle,\n      conf = dataSet.config,\n      len = xAxis.getTicksLen(),\n      components = dataSet.components,\n      dataStore = components.data,\n      pool = components.pool,\n      skipLabelDraw,\n      dataObj,\n      attr,\n      i,\n      j,\n      rotateValues = chartConfig.rotatevalues ? 270 : 0,\n      graphic,\n      setValue,\n      config,\n      showValue,\n      label,\n      tempGraphics,\n      prevDataDims,\n      currentDataDim = {},\n      currDatasetIndex = dataSet.getJSONIndex(),\n      dataLabelContainer,\n      skipInfo = dataSet.getSkippingInfo && dataSet.getSkippingInfo(),\n      skippingApplied = skipInfo && skipInfo.skippingApplied,\n      plotDrawArray = (skipInfo && skipInfo.labelDraw) || [],\n      plotDrawArrayLength = plotDrawArray.length,\n      startIndex = pluckNumber(start, 0),\n      endIndex = pluckNumber(end, skippingApplied ? plotDrawArrayLength : len),\n      notParticularLabeDraw = plotDrawArrayLength === Math.abs(endIndex - (startIndex + 1)),\n      hideCallbackFn = function () {\n        this.attr({'text-bound': []});\n        this.hide();\n      },\n      showCallbackFn = function () {\n        this.show();\n      };\n\n    dataLabelContainer = dataSet.getContainer('labelGroup');\n    dataLabelContainer.css({\n      fontFamily: style.fontFamily,\n      fontSize: style.fontSize,\n      fontWeight: style.fontWeight,\n      fontStyle: style.fontStyle\n    });\n    dataLabelContainer.show();\n\n    smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);\n    smartLabel.setStyle(style);\n    for (j = startIndex; j < endIndex; j++) {\n      i = (skippingApplied && notParticularLabeDraw) ? plotDrawArray[j] : j;\n      dataObj = dataStore[i];\n      config = dataObj && dataObj.config;\n      setValue = config && config.setValue;\n\n      if (dataObj === UNDEF || setValue === UNDEF || setValue === null || config.labelSkip === true) {\n        config && (delete config.labelSkip);\n        tempGraphics = dataObj && dataObj.graphics;\n        if (tempGraphics) {\n          tempGraphics.label && tempGraphics.label.hide();\n        }\n        continue;\n      }\n      graphic = dataObj.graphics;\n\n      if (!graphic) {\n        continue;\n      }\n      showValue = config.showValue;\n      // get the dimensions of datalabels of same index but of previous datasets\n      prevDataDims = chart.getDatasets().map(\n        /* eslint-disable-next-line */\n        dataset => {\n          return (dataset.getJSONIndex() < currDatasetIndex) && dataset._labeldimensionMap[j];\n        }\n      ).filter(Boolean);\n      if (conf.showValues && config.showValue) {\n        // current datalabel dimensions\n        currentDataDim = {\n          x: config.props.label.attr.x,\n          y: config.props.label.attr.y,\n          width: config._state.labelWidth,\n          height: config._state.labelHeight\n        };\n        // check for overlap\n        skipLabelDraw = checkOverlap(currentDataDim, prevDataDims);\n      }\n      // update curent label dimensions\n      dataSet._labeldimensionMap[j] = currentDataDim;\n      if (!showValue || (setValue === null) || skipLabelDraw) {\n        if (graphic.label) {\n          animationManager.setAnimation({\n            el: graphic.label,\n            component: dataSet,\n            doNotRemove: true,\n            callback: hideCallbackFn,\n            label: 'plotLabel'\n          });\n        }\n        dataSet._labeldimensionMap[j].labelShown = false;\n        continue;\n      }\n\n      attr = config.props.label.attr;\n\n      attr.transform = paper.getSuggestiveRotation(rotateValues, attr.x, attr.y);\n\n      if (!(label = graphic.label)) {\n        if (pool && pool.label[0]) {\n          label = graphic.label = pool.label[0];\n          pool.label.splice(0, 1);\n        }\n      }\n      label = animationManager.setAnimation({\n        el: graphic.label || 'text',\n        attr: attr,\n        component: dataSet,\n        label: 'plotLabel',\n        index: i,\n        container: dataLabelContainer,\n        callback: !visible ? hideCallbackFn : showCallbackFn\n      });\n      label && label.outlineText(conf.showTextOutline, attr.fill);\n      if (chartConfig.showtooltip && label.abbrArr && label.abbrArr.length) {\n        toolTipController.enableToolTip(label, UNDEF);\n      }\n      if (visible) {\n        dataSet._labeldimensionMap[j].labelShown = true;\n      } else {\n        dataSet._labeldimensionMap[j].labelShown = false;\n      }\n\n      if (!graphic.label) {\n        graphic.label = dataSet.addGraphicalElement('plotLabel', label, true);\n      }\n    }\n\n    conf.labelDrawn = true;\n  }\n}\n\nexport default OverlappedColumn;\n"],"sourceRoot":""}